#!/usr/bin/env python3

import os
import sys
import json
import logging
import re
import threading
import subprocess
import shutil
from datetime import datetime
import secretstorage
import time
from urllib.parse import urlparse, quote_plus
import locale
import notify2
import gi
gi.require_version('Gtk', '3.0')
gi.require_version('WebKit2', '4.0')
gi.require_version("Gio", "2.0")
from gi.repository import Gtk, WebKit2, GLib, Gdk, Pango, Gio
gi.require_version("Secret", "1")
from gi.repository import Secret
import keyring
import requests
from bs4 import BeautifulSoup

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Disable hardware acceleration and compositing to prevent OpenGL context issues
import os

os.environ['LIBGL_ALWAYS_SOFTWARE'] = '0'
os.environ['WEBKIT_DISABLE_COMPOSITING_MODE'] = '1'
os.environ['WEBKIT_ACCELERATED'] = '0'
os.environ['LIBVA_DRIVER_NAME'] = 'intel'
os.environ['WEBKIT_DISABLE_SANDBOX_THIS_IS_DANGEROUS'] = '1'
os.environ['GDK_BACKEND'] = 'x11'



# Set locale for numeric operations to 'C'
locale.setlocale(locale.LC_NUMERIC, 'C')




class SiteStabilizer:
    def __init__(self, browser):
        """Initialize the SiteStabilizer with a reference to the browser."""
        self.browser = browser
        self.web_context = self.browser.web_context

    def stabilize_site(self, url):
        """Apply stabilization measures for `msnbc.com` only."""
        domain = urlparse(url).netloc

        if domain.endswith("msnbc.com"):
            self.disable_javascript()
            logger.info(f"Stabilization applied to: {domain}")
        else:
            logger.info(f"No stabilization needed for: {domain}")

    def disable_javascript(self):
        """Disable JavaScript for the current tab."""
        current_page = self.browser.get_current_page()
        if current_page:
            settings = current_page.webview.get_settings()
            settings.set_property("enable-javascript", False)
            logger.info("JavaScript disabled for the current tab.")

    def enable_javascript(self):
        """Enable JavaScript for the current tab."""
        current_page = self.browser.get_current_page()
        if current_page:
            settings = current_page.webview.get_settings()
            settings.set_property("enable-javascript", True)
            logger.info("JavaScript enabled for the current tab.")

    def disable_media_autoplay(self):
        """Disable media autoplay for the current tab."""
        current_page = self.browser.get_current_page()
        if current_page:
            script = """
            (function() {
                var videos = document.querySelectorAll('video, audio');
                videos.forEach(function(media) {
                    media.autoplay = false;
                    media.pause();
                });
            })();
            """
            current_page.webview.run_javascript(script, None, None, None)
            logger.info("Media autoplay disabled for the current tab.")












import os
import json
import logging
from urllib.parse import urlparse

logger = logging.getLogger(__name__)

class SettingsManager:
    """Handles storing and retrieving site-specific settings, ad-blocking, and whitelists."""

    def __init__(self):
        self.settings_dir = os.path.join(os.path.expanduser('~'), '.simple_browser')
        self.settings_file = os.path.join(self.settings_dir, 'site_settings.json')
        logger.debug(f"Settings file path: {self.settings_file}")

        # Initialize settings and ad-blocking rules
        self.settings = self.load_settings()
        self.adblock_rules = self.settings.get("adblock_rules", [])
        self.ad_blocking_enabled = self.settings.get("ad_blocking_enabled", True)

    # ------------------------------
    # Load and Save Settings
    # ------------------------------

    def load_settings(self):
        """Load settings from the JSON file."""
        try:
            if os.path.exists(self.settings_file):
                with open(self.settings_file, 'r') as file:
                    settings = json.load(file)
                    logger.info("Settings loaded successfully.")
                    return settings
            logger.info("Settings file not found. Will create upon saving.")
            return {}
        except Exception as e:
            logger.error(f"Error accessing settings file at {self.settings_file}: {e}")
            return {}

    def save_settings(self):
        """Save settings to the JSON file."""
        try:
            os.makedirs(os.path.dirname(self.settings_file), exist_ok=True)
            self.settings["ad_blocking_enabled"] = self.ad_blocking_enabled
            self.settings["adblock_rules"] = self.adblock_rules
            with open(self.settings_file, 'w') as file:
                json.dump(self.settings, file, indent=4)
            logger.info("Settings saved successfully.")
        except Exception as e:
            logger.error(f"Error saving settings at {self.settings_file}: {e}")

    # ------------------------------
    # Ad-Blocking Methods
    # ------------------------------

    def is_ad_blocking_enabled(self):
        """Check if ad-blocking is enabled."""
        return self.ad_blocking_enabled

    def set_ad_blocking_enabled(self, enabled):
        """Enable or disable ad-blocking and save the setting."""
        self.ad_blocking_enabled = enabled
        self.save_settings()

    def get_adblock_rules(self):
        """Return the ad-blocking rules."""
        if not self.adblock_rules:
            self.adblock_rules = [
                {
                    "trigger": {
                        "url-filter": ".*ads.*"
                    },
                    "action": {
                        "type": "block"
                    }
                },
                {
                    "trigger": {
                        "url-filter": ".*trackers.*"
                    },
                    "action": {
                        "type": "block"
                    }
                }
            ]
            self.save_settings()
        return self.adblock_rules

    # ------------------------------
    # Site-Specific Settings
    # ------------------------------

    def get_site_settings(self, url):
        """Retrieve settings for a specific site based on its URL."""
        parsed_url = urlparse(url)
        domain = parsed_url.netloc
        return self.settings.get(domain, {})

    def set_site_settings(self, url, setting_key, setting_value):
        """Set a specific setting for a site based on its URL."""
        parsed_url = urlparse(url)
        domain = parsed_url.netloc
        if domain not in self.settings:
            self.settings[domain] = {}
        self.settings[domain][setting_key] = setting_value
        self.save_settings()

    # ------------------------------
    # Whitelist Methods
    # ------------------------------

    def get_whitelist(self):
        """Get the list of whitelisted domains."""
        return self.settings.get("whitelist", [])

    def add_to_whitelist(self, domain):
        """Add a domain to the whitelist."""
        whitelist = self.settings.setdefault("whitelist", [])
        if domain not in whitelist:
            whitelist.append(domain)
            self.save_settings()
            logger.info(f"Added {domain} to whitelist.")

    def remove_from_whitelist(self, domain):
        """Remove a domain from the whitelist."""
        whitelist = self.settings.get("whitelist", [])
        if domain in whitelist:
            whitelist.remove(domain)
            self.save_settings()
            logger.info(f"Removed {domain} from whitelist.")



import threading
import time
import logging

logger = logging.getLogger(__name__)

class PageStabilizer:
    """Class to stabilize web pages by monitoring and recovering from crashes."""

    def __init__(self, browser, max_retries=3, retry_delay=2):
        self.browser = browser
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        self.current_retries = 0
        self.monitoring = {}

    def start_monitoring(self, webview):
        """Start monitoring the webview for potential crashes or freezes."""
        uri = webview.get_uri()
        if uri not in self.monitoring:
            self.monitoring[uri] = True
            logger.info(f"Started monitoring for: {uri}")

    def stop_monitoring(self, webview):
        """Stop monitoring the webview."""
        uri = webview.get_uri()
        if uri in self.monitoring:
            del self.monitoring[uri]
            logger.info(f"Stopped monitoring for: {uri}")

    def stabilize_page(self, webview, uri):
        """Attempt to recover a page by reloading if it fails to load."""
        if self.current_retries < self.max_retries:
            self.current_retries += 1
            logger.warning(f"Attempting to recover: {uri} (Retry {self.current_retries}/{self.max_retries})")
            threading.Thread(target=self._reload_page, args=(webview, uri)).start()
        else:
            logger.error(f"Max retries reached for {uri}. Unable to stabilize the page.")
            self.stop_monitoring(webview)

    def _reload_page(self, webview, uri):
        """Reload the page with a delay."""
        time.sleep(self.retry_delay)
        logger.info(f"Reloading page: {uri}")
        webview.load_uri(uri)
        self.start_monitoring(webview)  # Restart monitoring after reload

    def reset_retries(self, uri):
        """Reset retry counter for a given URI."""
        if uri in self.monitoring:
            self.current_retries = 0
            logger.info(f"Reset retries for: {uri}")






import json
import os
from datetime import datetime

class WebClipper:
    def __init__(self, save_file="saved_pages.json"):
        self.save_file = save_file
        self.saved_pages = self._load_saved_pages()

    def _load_saved_pages(self):
        """Load saved pages from the JSON file."""
        if os.path.exists(self.save_file):
            with open(self.save_file, 'r') as f:
                return json.load(f)
        return []

    def save_page(self, title, url):
        """Save the current page's title and URL."""
        self.saved_pages.append({
            "title": title,
            "url": url,
            "date_saved": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        })
        self._save_to_file()
        print(f"Page saved: {title} ({url})")

    def _save_to_file(self):
        """Save the pages list to the JSON file."""
        with open(self.save_file, 'w') as f:
            json.dump(self.saved_pages, f, indent=4)

    def get_saved_pages(self):
        """Return the list of saved pages."""
        return self.saved_pages

    def delete_page(self, index):
        """Delete a saved page by index."""
        if 0 <= index < len(self.saved_pages):
            deleted = self.saved_pages.pop(index)
            self._save_to_file()
            print(f"Deleted page: {deleted['title']}")












import gi
gi.require_version("Gtk", "3.0")
from gi.repository import Gtk, Gdk
from urllib.parse import quote_plus


class CombinedLauncher(Gtk.Dialog):
    def __init__(self, parent, bookmarks, save_bookmarks_callback):
        super().__init__(title="Open URL or Bookmark", transient_for=parent, modal=True, destroy_with_parent=True)
        self.set_default_size(800, 400)
        self.bookmarks = bookmarks
        self.save_bookmarks = save_bookmarks_callback
        self.selected_url = None

        self._build_ui()
        self._connect_signals()
        self._update_results()  # Populate with existing bookmarks

        self.show_all()
        self.run()
        self.destroy()

    def _build_ui(self):
        """Build the UI for the combined launcher."""
        content_area = self.get_content_area()
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        vbox.set_border_width(10)
        content_area.pack_start(vbox, True, True, 0)

        # Search Entry
        self.search_entry = Gtk.Entry()
        self.search_entry.set_placeholder_text("Enter URL, search query, or bookmark name...")
        vbox.pack_start(self.search_entry, False, False, 0)

        # Scrolled Window for Results
        self.result_list = Gtk.ListBox()
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        scrolled_window.add(self.result_list)
        vbox.pack_start(scrolled_window, True, True, 0)

        # OK and Cancel Buttons
        self.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OK, Gtk.ResponseType.OK)

    def _connect_signals(self):
        """Connect signals for the search entry and result list."""
        self.search_entry.connect("changed", self._on_search_entry_changed)
        self.search_entry.connect("activate", self._on_search_entry_activate)  # Handle Enter key
        self.search_entry.connect("key-press-event", self._on_key_press)       # Handle Ctrl+Enter
        self.result_list.connect("row-activated", self._on_row_activated)

    def _update_results(self, query=""):
        """Dynamically update the results list based on the search query."""
        self.result_list.foreach(lambda child: self.result_list.remove(child))  # Clear existing rows

        # Show search query as an option
        if query.strip():
            self._add_result_row(f"Search: {query}", query)

        # Display bookmarks
        for bookmark in self.bookmarks:
            name, uri = bookmark['name'], bookmark['uri']
            if query.lower() in name.lower() or query.lower() in uri.lower() or not query:
                self._add_result_row(f"{name} ({uri})", uri, bookmark)

        self.result_list.show_all()

    def _add_result_row(self, display_text, url, bookmark=None):
        """Create a result row with an optional delete button for bookmarks."""
        row = Gtk.ListBoxRow()
        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)

        # Label to display the text
        label = Gtk.Label(label=display_text, xalign=0)
        label.set_hexpand(True)
        hbox.pack_start(label, True, True, 0)

        # Add a delete button if it's a bookmark
        if bookmark:
            delete_button = Gtk.Button()
            delete_button.set_image(Gtk.Image.new_from_icon_name("user-trash-symbolic", Gtk.IconSize.BUTTON))
            delete_button.set_tooltip_text("Delete Bookmark")
            delete_button.connect("clicked", lambda btn, b=bookmark, r=row: self._on_delete_bookmark(b, r))
            hbox.pack_start(delete_button, False, False, 0)

        row.add(hbox)
        row.url = url  # Store the URL for launching
        self.result_list.add(row)

    def _on_search_entry_changed(self, widget):
        """Update the results dynamically when the search query changes."""
        query = widget.get_text().strip()
        self._update_results(query)

    def _on_search_entry_activate(self, widget):
        """Handle Enter key in the search entry to perform a search."""
        query = self.search_entry.get_text().strip()
        if query:
            url = f"https://www.duckduckgo.com/?q={quote_plus(query)}"
            self._launch_url(url)
            self.response(Gtk.ResponseType.CANCEL)

    def _on_key_press(self, widget, event):
        """Handle Ctrl+Enter to add www. and .com to the query."""
        if event.state & Gdk.ModifierType.CONTROL_MASK and event.keyval == Gdk.KEY_Return:
            query = self.search_entry.get_text().strip()
            if query:
                url = self._ensure_tld(query)
                self._launch_url(url)
                self.response(Gtk.ResponseType.CANCEL)

    def _on_row_activated(self, listbox, row):
        """Launch the URL when a row is activated (double-click or Enter)."""
        if hasattr(row, 'url'):
            self._launch_url(row.url)
            self.response(Gtk.ResponseType.CANCEL)

    def _on_delete_bookmark(self, bookmark, row):
        """Delete a bookmark and update the results."""
        self.bookmarks.remove(bookmark)  # Remove the bookmark
        self.save_bookmarks()            # Save the updated bookmarks list
        self.result_list.remove(row)     # Remove the row from the UI

    def _launch_url(self, query):
        """Launch the selected URL."""
        if self._is_probable_url(query):
            url = self._format_url(query)
        else:
            url = f"https://www.duckduckgo.com/?q={quote_plus(query)}"
        self.selected_url = url
        print(f"Launching URL: {url}")  # Debug print; replace with actual tab opening

    def _ensure_tld(self, domain):
        """Ensure the domain has a www. prefix and a .com suffix."""
        if not domain.startswith("www."):
            domain = "www." + domain
        if not any(domain.endswith(tld) for tld in ['.com', '.org', '.net', '.io']):
            domain += ".com"
        return domain

    def _is_probable_url(self, text):
        """Check if the text is a probable URL."""
        return '.' in text and ' ' not in text

    def _format_url(self, url):
        """Ensure the URL has a scheme."""
        if not url.startswith(("http://", "https://")):
            return f"https://{url}"
        return url








class DownloadManager:
    """Handles file downloads using Axel."""

    def __init__(self, browser):
        self.browser = browser
        #self.operation_lock = operation_lock  # Initialize the lock inside the DownloadManager
        self.download_folder = os.path.expanduser('~/Downloads')
        self.downloads = []
        os.makedirs(self.download_folder, exist_ok=True)

        self.download_history_file = os.path.join(self.download_folder, 'download_history.txt')

        self.load_download_history()

        # Check if Axel is installed
        if shutil.which("axel") is None:
            self.show_axel_not_found_error()

        # Initialize window attribute without creating it
        self.download_manager_window = None

    def create_download_manager_window(self):
        """Create the Download Manager window and its UI components."""
        if self.download_manager_window:
            self.download_manager_window.present()  # Bring the existing window to the front
            return

        # Create the Download Manager window
        self.download_manager_window = Gtk.Window(title="Simple Download Manager")
        self.download_manager_window.set_default_size(800, 400)
        self.download_manager_window.set_border_width(10)

        # Vertical Box to hold all download entries and buttons
        vbox_main = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)

        # ScrolledWindow to contain the downloads_box
        self.downloads_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.downloads_box.set_homogeneous(False)
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        scrolled_window.add(self.downloads_box)

        # Add the scrolled window to the main box
        vbox_main.pack_start(scrolled_window, True, True, 0)

        # Create a horizontal box to hold both buttons
        hbox_buttons = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)

        # Clear History Button
        clear_history_button = Gtk.Button(label="Clear Download History")
        clear_history_button.set_tooltip_text("Clear all completed downloads from history")
        clear_history_button.connect("clicked", self.on_clear_download_history)

        # Button to open downloads folder
        open_folder_button = Gtk.Button(label="Open Downloads Folder")
        open_folder_button.set_tooltip_text("Open the downloads folder in the file manager")
        open_folder_button.connect("clicked", self.open_downloads_folder)

        # Add both buttons to the horizontal box
        hbox_buttons.pack_start(clear_history_button, True, True, 0)
        hbox_buttons.pack_start(open_folder_button, True, True, 0)



        # Add the horizontal box to the main vertical box
        vbox_main.pack_start(hbox_buttons, False, False, 0)
        self.download_manager_window.add(vbox_main)

        # Connect the delete-event to hide the window instead of destroying it
        self.download_manager_window.connect("delete-event", self.on_download_manager_close)

        # Reload history when the window is shown
        self.download_manager_window.connect("show", self.on_download_manager_show)

        self.download_manager_window.show_all()

    def on_download_manager_close(self, widget, event):
        """Hide the download manager window instead of destroying it."""
        widget.hide()
        return True  # Prevents the default destroy behavior

    def open_downloads_folder(self, widget):
        """Open the downloads folder using the default file manager."""
        downloads_path = self.download_folder
        subprocess.run(["xdg-open", downloads_path])


    def open_download_manager(self, widget=None):
        """Open the download manager window, creating it if necessary."""
        if not self.download_manager_window:
            self.create_download_manager_window()
        self.download_manager_window.show_all()
        self.on_download_manager_show(self.download_manager_window)



    def on_download_manager_destroy(self, widget):
        """Handle closing the download manager window."""
        self.download_manager_window = None

    def on_download_manager_show(self, widget):
        """Refresh the downloads list when the window is shown."""
        self.refresh_downloads_ui()

    def load_download_history(self):
        """Load download history from the text file."""
        if os.path.exists(self.download_history_file):
            with open(self.download_history_file, 'r') as f:
                self.downloads = [line.strip() for line in f.readlines()]
        else:
            self.downloads = []





    def refresh_downloads_ui(self):
        """Refresh the download list UI."""
        for child in self.downloads_box.get_children():
            self.downloads_box.remove(child)

        for download in self.downloads:
            label = Gtk.Label(label=download)
            self.downloads_box.pack_start(label, False, False, 0)

        self.downloads_box.show_all()

    def on_clear_download_history(self, widget):
        """Clear the download history and update the UI."""
        # Clear the downloads list
        self.downloads = []

        # Delete the history file if it exists
        if os.path.exists(self.download_history_file):
            os.remove(self.download_history_file)

        # Refresh the UI to reflect the cleared history
        self.refresh_downloads_ui()



    def on_download_manager_destroy(self, widget):
        """Handle the download manager window being closed."""
        print("Download Manager window closed.")

    def on_download_manager_show(self, widget):
        """Reload download history when the window is shown."""
        self.load_download_history()
        self.refresh_downloads_ui()

    def refresh_downloads_ui(self):
        """Clear and recreate the download UI elements."""
        for child in self.downloads_box.get_children():
            self.downloads_box.remove(child)

        for download in self.downloads:
            self.create_download_progress_ui(download)

        self.download_manager_window.show_all()

    def show_axel_not_found_error(self):
        """Display an error dialog if Axel is not installed."""
        dialog = Gtk.MessageDialog(
            transient_for=self.browser,
            modal=True,
            destroy_with_parent=True,
            message_type=Gtk.MessageType.ERROR,
            buttons=Gtk.ButtonsType.OK,
            text="Axel Not Found",
        )
        dialog.format_secondary_text(
            "The 'axel' utility is required for downloading files, but it was not found on your system. Please install Axel and restart the application."
        )
        dialog.run()
        dialog.destroy()
        self.browser.destroy()

    def start_download(self, uri, suggested_filename):
        """Initiate a new download."""
        if not self.browser.operation_lock.acquire(blocking=False):
            self.browser.show_error_dialog("Another operation is in progress. Please wait.")
            return

        try:
            self._perform_download(uri, suggested_filename)
        finally:
            self.browser.operation_lock.release()


    def _perform_download(self, uri, suggested_filename):
        """Internal method to handle the download process."""
        self.open_download_manager()
        filename = self.sanitize_filename(suggested_filename)
        filepath = os.path.join(self.download_folder, filename)

        if os.path.exists(filepath):
            os.remove(filepath)

        start_time = datetime.now()

        cmd = ['axel', '-n', '8', '-v', '-o', filepath, uri]
        threading.Thread(target=self.run_axel, args=(cmd, filepath)).start()

        download = {
            'uri': uri,
            'filename': filename,
            'filepath': filepath,
            'progress': 0,
            'status': 'Downloading',
            'start_time': start_time.isoformat(),
            'end_time': None,
            'duration': None
        }
        self.downloads.append(download)
        self.save_download_history()
        GLib.idle_add(self.create_download_progress_ui, download)
        GLib.idle_add(self.refresh_downloads_ui)




    def run_axel(self, cmd, filepath):
        """Run the Axel subprocess and handle its output."""
        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True
        )
        start_time = datetime.now()


        for line in iter(process.stdout.readline, ''):
            logger.debug(f"Axel output: {line.strip()}")
            # Extract percentage using regex
            match = re.search(r'\[ *(\d+)%\]', line)
            if match:
                percentage = int(match.group(1))
                GLib.idle_add(self.update_download_progress, filepath, percentage)
            
            GLib.idle_add(self.append_download_output, filepath, line)

        process.wait()
        end_time = datetime.now()

        if process.returncode == 0:
            duration = (end_time - start_time).total_seconds()
            GLib.idle_add(self.complete_download, filepath, end_time.isoformat(), duration)
        else:
            GLib.idle_add(self.fail_download, filepath)


    def append_download_output(self, filepath, line):
        """Append a line of text to the download's TextView."""
        logger.debug(f"Appending output to {filepath}: {line.strip()}")
        for download in self.downloads:
            if download['filepath'] == filepath:
                text_buffer = download.get('text_buffer')
                scrolled_window = download.get('scrolled_window')
                
                if text_buffer and scrolled_window:
                    end_iter = text_buffer.get_end_iter()
                    text_buffer.insert(end_iter, line + "\n")
                    
                    # Auto-scroll to the bottom
                    adjustment = scrolled_window.get_vadjustment()
                    GLib.idle_add(adjustment.set_value, adjustment.get_upper())
                    
                break
        return False  # Remove the idle callback


    def complete_download(self, filepath, end_time, duration):
        """Handle download completion and update UI."""
        for download in self.downloads:
            if download['filepath'] == filepath:
                download['progress'] = 100
                download['status'] = 'Completed'
                download['end_time'] = end_time
                download['duration'] = duration
                
                # Call the method to update the UI
                self.mark_download_complete(download)

                # Calculate the duration in minutes and seconds
                minutes, seconds = divmod(duration, 60)
                duration_text = f"{minutes} minutes, {seconds} seconds" if minutes else f"{seconds} seconds"

                # Send a notification when the download is complete
                notification = notify2.Notification(
                    "Download Complete",
                    f"File saved to: {filepath}\nTime taken: {duration_text}",
                    "dialog-information"
                )
                notification.show()

                # Save download history
                self.save_download_history()
                break


    def mark_download_complete(self, download):
        """Update the download status to reflect completion in the UI."""
        if 'progress_bar' in download and download['progress_bar']:
            download['progress_bar'].set_fraction(1.0)
            download['progress_bar'].set_text("Completed")
        if 'label_widget' in download and download['label_widget']:
            download['label_widget'].set_text("Completed")



    def fail_download(self, filepath):
        """Handle download failure and update UI."""
        for download in self.downloads:
            if download['filepath'] == filepath:
                download['status'] = 'Failed'
                self.save_download_history()
                self.refresh_downloads_ui()
                break


    def save_download_history(self):
        """Save download history to a text file."""
        try:
            with open(self.download_history_file, 'w') as file:
                for download in self.downloads:
                    line = f"{download['filename']}|{download['filepath']}|{download['uri']}|{download['progress']}|{download['status']}|{download['start_time']}|{download['end_time']}|{download['duration']}\n"
                    file.write(line)
            logger.info("Download history saved to text file.")
        except Exception as e:
            logger.error(f"Failed to save download history: {e}")



    def load_download_history(self):
        """Load download history from a text file."""
        self.downloads = []
        if os.path.exists(self.download_history_file):
            try:
                with open(self.download_history_file, 'r') as file:
                    for line in file:
                        parts = line.strip().split('|')
                        if len(parts) == 8:
                            download = {
                                'filename': parts[0],
                                'filepath': parts[1],
                                'uri': parts[2],
                                'progress': int(parts[3]),
                                'status': parts[4],
                                'start_time': parts[5],
                                'end_time': parts[6] if parts[6] != 'None' else None,
                                'duration': float(parts[7]) if parts[7] != 'None' else None
                            }
                            self.downloads.append(download)
                logger.info("Download history loaded from text file.")
            except Exception as e:
                logger.error(f"Failed to load download history: {e}")


    def sanitize_filename(self, filename):
        """Sanitize filename by removing invalid characters."""
        return re.sub(r'[\\/*?:"<>|]', "_", filename)

    def create_download_progress_ui(self, download):
        """Create UI elements to display download information."""
        logger.debug(f"Creating UI for download: {download['filename']}")

        # Main vertical box for each download entry
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)

        # Horizontal box for filename, status, progress bar, and percentage
        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)

        # Filename label
        filename_label = Gtk.Label(label=download['filename'])
        filename_label.set_xalign(0)
        filename_label.set_hexpand(True)

        # Status label
        status_label = Gtk.Label(label=download['status'])
        status_label.set_xalign(0)

        # Progress bar
        progress_bar = Gtk.ProgressBar()
        progress_bar.set_show_text(True)
        progress_bar.set_fraction(download['progress'] / 100.0)
        progress_bar.set_hexpand(True)

        # Progress percentage label
        progress_label = Gtk.Label(label=f"{download['progress']}%")
        progress_label.set_xalign(0)

        # Pack elements into the horizontal box
        hbox.pack_start(filename_label, True, True, 0)
        hbox.pack_start(status_label, False, False, 0)
        hbox.pack_start(progress_bar, True, True, 0)
        hbox.pack_start(progress_label, False, False, 0)

        # Add the horizontal box to the vertical box
        vbox.pack_start(hbox, False, False, 0)

        # Store references for updating progress later
        download['status_label'] = status_label
        download['progress_bar'] = progress_bar
        download['progress_label'] = progress_label

        # Add the download entry to the downloads_box
        self.downloads_box.pack_start(vbox, False, False, 0)
        self.download_manager_window.show_all()


    def update_download_progress(self, filepath, percentage):
        """Update the progress label and progress bar for the download."""
        for download in self.downloads:
            if download['filepath'] == filepath:
                if 'progress_label' in download:
                    download['progress_label'].set_text(f"{percentage}%")
                if 'progress_bar' in download:
                    download['progress_bar'].set_fraction(percentage / 100.0)
                break



    def on_clear_download_output(self, widget, download):
        """Clear the verbose output for a specific download."""
        text_buffer = download.get('text_buffer')
        if text_buffer:
            text_buffer.set_text("")


class AutofillManager:
    """Manages form autofill data."""

    def __init__(self):
        self.autofill_dir = os.path.join(os.path.expanduser('~'), '.simple_browser')
        self.autofill_data_file = os.path.join(self.autofill_dir, 'autofill_data.json')
        self.autofill_data = self.load_autofill_data()

    def load_autofill_data(self):
        if os.path.exists(self.autofill_data_file):
            try:
                with open(self.autofill_data_file, 'r') as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"Failed to load autofill data: {e}")
        return {}

    def save_autofill_data(self):
        try:
            os.makedirs(os.path.dirname(self.autofill_data_file), exist_ok=True)
            with open(self.autofill_data_file, 'w') as f:
                json.dump(self.autofill_data, f, indent=4)
            logger.info("Autofill data saved successfully.")
        except Exception as e:
            logger.error(f"Failed to save autofill data: {e}")

    def get_suggestions(self, domain, field_name):
        return self.autofill_data.get(domain, {}).get(field_name, [])

    def save_field_data(self, domain, field_name, value):
        if domain not in self.autofill_data:
            self.autofill_data[domain] = {}
        if field_name not in self.autofill_data[domain]:
            self.autofill_data[domain][field_name] = []
        if value not in self.autofill_data[domain][field_name]:
            self.autofill_data[domain][field_name].append(value)
            self.save_autofill_data()
        logger.info(f"Saved autofill data for {domain}: {field_name} -> {value}")


class CredentialsManager:
    """Manages storing and retrieving saved credentials securely using keyring."""

    def __init__(self):
        pass  # No initialization needed for keyring



    def save_credentials(self, site, username, password):
        """Save credentials securely using KDE Wallet via secretstorage."""
        try:
            # Check for None values and log them
            if not site:
                logger.error("Site is missing.")
                raise ValueError("Site cannot be None.")
            if not username:
                logger.error("Username is missing.")
                raise ValueError("Username cannot be None.")
            if not password:
                logger.error("Password is missing.")
                raise ValueError("Password cannot be None.")

            # Establish connection to KDE Wallet (Secret Service)
            connection = secretstorage.dbus_init()
            collection = secretstorage.get_default_collection(connection)

            # Create a new secret item with site, username, and password
            attributes = {'site': site, 'username': username}
            label = f"Credentials for {site}"
            
            # Ensure the password is bytes
            secret_bytes = password.encode('utf-8')
            
            # Create and store the secret item
            collection.create_item(label, attributes, secret_bytes, replace=True)

            logger.info(f"Credentials for {site} saved successfully.")
        except Exception as e:
            logger.error(f"Error saving credentials: {e}")




    def get_credentials(self, site):
        """Retrieve saved credentials."""
        try:
            username = keyring.get_password(site, 'username')
            password = keyring.get_password(site, 'password')
            if username and password:
                logger.info(f"Credentials for {site} retrieved.")
                return username, password
        except Exception as e:
            logger.error(f"Error retrieving credentials: {e}")
        return None, None






import gi
import logging
from gi.repository import Gtk, GLib

logger = logging.getLogger(__name__)

class CrashControl:
    """Class to handle WebView crashes and recover gracefully."""

    def __init__(self, browser):
        self.browser = browser

    def monitor_webview(self, webview, tab):
        """Monitor the WebView for crashes."""
        webview.connect("web-process-crashed", self.on_web_process_crashed, tab)

    def on_web_process_crashed(self, webview, tab):
        """Handle the web process crash event."""
        logger.error("Web process crashed. Attempting to recover...")

        # Notify the user
        dialog = Gtk.MessageDialog(
            transient_for=self.browser,
            modal=True,
            message_type=Gtk.MessageType.ERROR,
            buttons=Gtk.ButtonsType.OK,
            text="Page Crashed",
        )
        dialog.format_secondary_text("The web process crashed. The tab will be reloaded.")
        dialog.run()
        dialog.destroy()

        # Reload the tab to recover
        self.reload_tab(tab)

    def reload_tab(self, tab):
        """Reload the given tab after a crash."""
        if tab.current_uri:
            tab.webview.load_uri(tab.current_uri)
            logger.info(f"Reloaded tab with URL: {tab.current_uri}")
        else:
            logger.info("Reloading tab with homepage.")
            tab.webview.load_uri(self.browser.homepage)










class BrowserTab(Gtk.Box):
    """A class representing a single browser tab."""

    def __init__(self, browser, ad_block_rules=None):
        super().__init__(orientation=Gtk.Orientation.VERTICAL)
        self.browser = browser
        self.is_muted = False
        self.current_uri = None

        # Initialize the UserContentManager for handling scripts
        self.user_content_manager = WebKit2.UserContentManager()
        self.user_content_manager.register_script_message_handler("loginDetector")
        self.user_content_manager.register_script_message_handler("autofill")
        self.user_content_manager.register_script_message_handler("mediaControl")


        # Register the message handler in __init__
        self.user_content_manager.register_script_message_handler("freeWithAdsHandler")
        self.user_content_manager.connect("script-message-received::freeWithAdsHandler", self.on_free_with_ads_detected)


        # Connect message handlers
        self.user_content_manager.connect("script-message-received::loginDetector", self.on_login_form_detected)
        self.user_content_manager.connect("script-message-received::autofill", self.on_autofill_message_received)
        self.user_content_manager.connect("script-message-received::mediaControl", self.on_script_message_received)

        # Initialize the webview with the user content manager
        self.webview = WebKit2.WebView.new_with_user_content_manager(self.user_content_manager)

        # Configure webview settings
        self.settings = self.webview.get_settings()
        self.settings.set_property("enable-javascript", True)
        self.settings.set_property("enable-html5-database", True)
        self.settings.set_property("enable-html5-local-storage", True)
        self.settings.set_property("enable-page-cache", True)
        self.settings.set_property("enable-media-stream", True)
        self.settings.set_property("enable-mediasource", True)
        self.settings.set_property("enable-media-capabilities", True)
        self.settings.set_property("enable-webgl", True)  # Enable WebGL for better video playback support
        self.settings.set_property("enable-plugins", True)  # Enable plugins if needed
        self.apply_content_blocking_rules([])  # Disable ad-blocking for Plex
        self.webview.load_uri("https://watch.plex.tv/en-GB")

        self.webview.connect("load-failed", self.on_load_failed)



        # Set a Chrome user-agent
        self.settings.set_property(
            "user-agent",
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
        )
        self.webview.set_settings(self.settings)

        # Pack the webview into the tab
        self.pack_start(self.webview, True, True, 0)

        # Managers for settings, autofill, and credentials
        self.settings_manager = self.browser.settings_manager
        self.autofill_manager = self.browser.autofill_manager
        self.credentials_manager = self.browser.credentials_manager

        # Setup the tab label with a refresh button
        self.setup_tab_label()

        # Cookie manager settings
        cookie_manager = self.browser.web_context.get_cookie_manager()
        cookie_manager.set_accept_policy(WebKit2.CookieAcceptPolicy.ALWAYS)
        logger.info("Cookies are accepted to improve site compatibility.")


        # Initialize CrashControl and monitor the webview
        self.crash_control = CrashControl(browser)
        self.crash_control.monitor_webview(self.webview, self)



        # Connect signals
        self.webview.connect("notify::title", self.on_title_changed)
        self.webview.connect("load-changed", self.on_load_changed)
        self.webview.connect("notify::estimated-load-progress", self.on_load_progress)
        self.webview.connect("notify::uri", self.on_uri_changed)
        self.webview.connect("decide-policy", self.on_decide_policy)
        self.webview.connect("load-failed", self.on_load_failed)
        




        # Inject necessary scripts
        self.inject_login_detection_script()
        self.inject_autofill_script()
        self.inject_adblock_script(ad_block_rules)

        # Load the homepage
        self.webview.load_uri(self.browser.homepage)

        # Auto-accept cookies
        self.inject_auto_accept_cookies()

        self.show_all()


    def load_uri(self, uri):
        """Clear the cache before loading the specified URI."""
        self.browser.clear_browser_cache()
        self.webview.load_uri(uri)




    def apply_content_blocking_rules(self, rules):
        """Apply content blocking rules to the WebKit2 context."""
        try:
            if hasattr(self.browser.web_context, 'set_content_blockers'):
                content_blocker_rules = json.dumps(rules)
                self.browser.web_context.set_content_blockers(content_blocker_rules)
                logger.info("Content blocking rules applied.")
            else:
                logger.warning("WebContext does not support direct content blockers in this environment.")
        except Exception as e:
            logger.error(f"Error applying content blockers: {e}")


    def on_refresh_clicked(self, widget):
        """Reload the WebView content of this tab."""
        self.webview.reload()
        logger.info("Tab reloaded.")


    def on_new_tab(self, widget=None):
        """Open a new tab with a refresh button in the tab label."""
        new_tab = BrowserTab(self)
        label = new_tab.tab_label
        self.notebook.append_page(new_tab, label)
        self.notebook.set_current_page(-1)
        logger.info("New tab opened.")


    def inject_auto_accept_cookies(self):
        """Inject JavaScript to auto-accept cookies on common consent banners."""
        auto_accept_cookies_js = """
        (function() {
            const selectors = [
                'button[aria-label="Accept cookies"]',
                'button[aria-label="Accept all cookies"]',
                'button:contains("Accept All")',
                'button:contains("Accept Cookies")',
                'button:contains("I Agree")',
                'button:contains("Got it")',
                'button:contains("Accept")'
            ];

            function clickConsentButton() {
                selectors.forEach(selector => {
                    document.querySelectorAll(selector).forEach(button => {
                        button.click();
                        console.log("Cookie consent button clicked:", button);
                    });
                });
            }

            if (document.readyState === 'complete') {
                clickConsentButton();
            } else {
                window.addEventListener('load', clickConsentButton);
            }
        })();
        """

        user_script = WebKit2.UserScript.new(
            auto_accept_cookies_js,
            WebKit2.UserContentInjectedFrames.ALL_FRAMES,
            WebKit2.UserScriptInjectionTime.END
        )

        self.user_content_manager.add_script(user_script)
        logger.info("Auto-accept cookies script injected.")

    









    def on_free_with_ads_detected(self, user_content_manager, message):
        """Handle detection of 'Free with Ads' YouTube videos."""
        current_uri = self.webview.get_uri()
        logger.info(f"Detected 'Free with Ads' video. Launching mpv for: {current_uri}")
        self.play_with_mpv(current_uri)








    def get_site_configuration(self, uri):
        """
        Retrieve custom configuration for specific sites.
        """
        site_configurations = {
            "msnbc.com": {"enable_javascript": True, "allow_video": True},
            "cnn.com": {"enable_javascript": True, "allow_video": True},
            "example.com": {"enable_javascript": False, "allow_video": False},
            "watch.plex.tv": {"enable_javascript": True, "allow_video": True},
        }

        for site, config in site_configurations.items():
            if site in uri:
                return config

        # Default settings for other sites
        return {"enable_javascript": True, "allow_video": True}












    def on_decide_policy(self, webview, decision, decision_type):
        if decision_type == WebKit2.PolicyDecisionType.RESPONSE:
            response = decision.get_response()
            mime_type = response.get_mime_type()
            uri = response.get_uri()

            logger.debug(f"Response MIME type: {mime_type}, URI: {uri}")

            # Define MIME types for direct downloads
            download_mime_types = [
                'application/octet-stream',
                'application/x-iso9660-image',
                'application/zip',
                'application/x-tar',
                'application/x-bzip2',
                'application/x-gzip',
                'application/x-7z-compressed',
                'application/pdf',
                'video/mp4',
                'video/mp2t',
                'video/x-matroska',
            ]

            suggested_filename = response.get_suggested_filename() or os.path.basename(urlparse(uri).path) or 'download'

            if mime_type in download_mime_types:
                logger.info(f"Starting download for type {mime_type}: {suggested_filename}")
                try:
                    # Use the download_manager from the parent browser
                    self.browser.download_manager.start_download(uri, suggested_filename)

                    # Cancel the default behavior to avoid double handling
                    decision.ignore()
                    return True
                except Exception as e:
                    logger.error(f"Error starting download: {e}")
                    return False

        # Allow normal handling for other MIME types
        return False












    def setup_tab_label(self):
        def safe_repack(box, widget, expand, fill, padding):
            """Safely repack a widget by removing it from its parent if necessary."""
            if widget.get_parent():
                widget.get_parent().remove(widget)
            box.pack_start(widget, expand, fill, padding)

        self.tab_label_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)

        # Create the label and entry for renaming
        self.tab_label = Gtk.Label(label="New Tab")
        self.tab_label.set_xalign(0)
        self.tab_entry = Gtk.Entry()
        self.tab_entry.set_text("New Tab")
        self.tab_entry.set_no_show_all(True)
        self.tab_entry.connect("activate", self.on_tab_rename_confirm)
        self.tab_entry.connect("focus-out-event", self.on_tab_rename_cancel)

        # Repack widgets safely
        safe_repack(self.tab_label_box, self.tab_label, True, True, 0)
        safe_repack(self.tab_label_box, self.tab_entry, True, True, 0)

        # Add Mute Button
        self.mute_button = Gtk.Button.new_from_icon_name("audio-volume-high", Gtk.IconSize.BUTTON)
        self.mute_button.set_tooltip_text("Mute/Unmute Tab")
        self.mute_button.set_relief(Gtk.ReliefStyle.NONE)
        self.mute_button.set_focus_on_click(False)
        self.mute_button.connect("clicked", self.on_mute_toggle)
        safe_repack(self.tab_label_box, self.mute_button, False, False, 0)

        # Combined Stop/Reload Button
        self.tab_reload_stop_button = Gtk.Button.new_from_icon_name("view-refresh", Gtk.IconSize.BUTTON)
        self.tab_reload_stop_button.set_tooltip_text("Reload")
        self.tab_reload_stop_button.set_relief(Gtk.ReliefStyle.NONE)
        self.tab_reload_stop_button.set_focus_on_click(False)
        self.tab_reload_stop_button.connect("clicked", self.on_reload_stop_clicked)
        safe_repack(self.tab_label_box, self.tab_reload_stop_button, False, False, 0)

        # Add Plus Button (New Tab)
        self.plus_button = Gtk.Button.new_from_icon_name("list-add", Gtk.IconSize.BUTTON)
        self.plus_button.set_tooltip_text("Open New Tab")
        self.plus_button.set_relief(Gtk.ReliefStyle.NONE)
        self.plus_button.set_focus_on_click(False)
        self.plus_button.connect("clicked", self.browser.on_new_tab)
        safe_repack(self.tab_label_box, self.plus_button, False, False, 0)

        # Add Close Button
        self.close_button = Gtk.Button.new_from_icon_name("window-close", Gtk.IconSize.BUTTON)
        self.close_button.set_tooltip_text("Close Tab")
        self.close_button.set_relief(Gtk.ReliefStyle.NONE)
        self.close_button.set_focus_on_click(False)
        self.close_button.connect("clicked", self.browser.on_close_tab, self)
        safe_repack(self.tab_label_box, self.close_button, False, False, 0)

        # Enable right-click to rename the tab
        self.tab_label_box.set_events(Gdk.EventMask.BUTTON_PRESS_MASK)
        self.tab_label_box.connect("button-press-event", self.on_tab_right_click)

        self.tab_label_box.show_all()
        self.browser.notebook.append_page(self, self.tab_label_box)
        self.browser.notebook.set_tab_reorderable(self, True)
        self.browser.notebook.set_current_page(-1)


    def on_reload_stop_clicked(self, button):
        """Reload the page if not loading, or stop loading if currently loading."""
        if self.is_loading:
            self.webview.stop_loading()
        else:
            self.webview.reload()



    def on_load_changed(self, webview, load_event):
        """Handle changes in the load state and attempt stabilization if needed."""
        if load_event == WebKit2.LoadEvent.STARTED:
            self.is_loading = True
            self.tab_reload_stop_button.set_image(Gtk.Image.new_from_icon_name("process-stop", Gtk.IconSize.BUTTON))
            self.tab_reload_stop_button.set_tooltip_text("Stop Loading")
            logger.info("Loading started.")
            
            # Start monitoring the page load
            if hasattr(self.browser, 'page_stabilizer'):
                self.browser.page_stabilizer.start_monitoring(webview)

        elif load_event == WebKit2.LoadEvent.FINISHED:
            self.is_loading = False
            self.tab_reload_stop_button.set_image(Gtk.Image.new_from_icon_name("view-refresh", Gtk.IconSize.BUTTON))
            self.tab_reload_stop_button.set_tooltip_text("Reload")
            logger.info("Page loaded successfully.")
            
            # Stop monitoring when the page loads successfully
            if hasattr(self.browser, 'page_stabilizer'):
                self.browser.page_stabilizer.stop_monitoring(webview)
                self.browser.page_stabilizer.reset_retries(webview.get_uri())







    def on_load_failed(self, webview, load_event, uri, error):
        """Handle page load failures and attempt stabilization unless a download is in progress."""
        # Check if the failure is for a known download type
        response = webview.get_main_resource().get_response()
        mime_type = response.get_mime_type() if response else None

        # List of known download MIME types
        DOWNLOAD_MIME_TYPES = [
            'application/octet-stream',       # General binary files
            'application/x-iso9660-image',    # ISO files
            'application/zip',                # ZIP files
            'application/x-tar',              # TAR files
            'application/x-bzip2',            # BZ2 files
            'application/x-gzip',             # GZ files
            'application/x-7z-compressed',    # 7Z files
            'application/pdf',                # PDF files
            'video/mp4',                      # MP4 files
            'video/x-matroska',               # MKV files
            'video/webm',                     # WebM files
        ]

        # If the MIME type indicates a download, skip stabilization
        if mime_type in DOWNLOAD_MIME_TYPES:
            logger.info(f"Download detected ({mime_type}), skipping stabilization for: {uri}")
            return  # Skip stabilization for downloads

        # Log the load failure
        logger.error(f"Page load failed for: {uri}. Error: {error.message}")

        # Attempt stabilization if the browser has a page stabilizer
        if hasattr(self.browser, 'page_stabilizer'):
            self.browser.page_stabilizer.stabilize_page(webview, uri)






    def on_tab_right_click(self, widget, event):
        """Show context menu to rename the tab on right-click."""
        if event.button == 3:  # Right-click
            menu = Gtk.Menu()

            rename_item = Gtk.MenuItem(label="Rename Tab")
            rename_item.connect("activate", self.on_rename_tab)
            menu.append(rename_item)

            menu.show_all()
            menu.popup_at_pointer(event)

    def on_rename_tab(self, widget):
        """Switch to the entry widget to rename the tab."""
        self.tab_label.hide()
        self.tab_entry.set_text(self.tab_label.get_text())
        self.tab_entry.show()
        self.tab_entry.grab_focus()

    def on_tab_rename_confirm(self, widget):
        """Confirm and save the new tab name."""
        new_name = self.tab_entry.get_text().strip()
        if new_name:
            self.tab_label.set_text(new_name)
        self.tab_entry.hide()
        self.tab_label.show()

    def on_tab_rename_cancel(self, widget, event):
        """Cancel renaming and revert to the original tab name."""
        self.tab_entry.hide()
        self.tab_label.show()

    def show_tab_context_menu(self, event):
        """Display context menu for renaming the tab."""
        menu = Gtk.Menu()

        rename_item = Gtk.MenuItem(label="Rename Tab")
        rename_item.connect("activate", self.on_rename_tab)
        menu.append(rename_item)

        menu.show_all()
        menu.popup_at_pointer(event)        


    def on_switch_page(self, notebook, page, page_num):
        """Update the address bar when switching tabs."""
        current_page = self.get_current_page()
        if current_page and hasattr(current_page, 'webview'):
            uri = current_page.webview.get_uri()
            if uri:
                self.address_bar.set_text(uri)
            else:
                self.address_bar.set_text("")




    def on_rename_tab(self, widget):
        """Prompt the user to rename the tab."""
        dialog = Gtk.Dialog(
            title="Rename Tab",
            transient_for=self.browser,
            modal=True,
            destroy_with_parent=True,
        )
        dialog.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OK, Gtk.ResponseType.OK)

        content_area = dialog.get_content_area()
        entry = Gtk.Entry()
        entry.set_text(self.tab_label.get_text())
        content_area.pack_start(entry, True, True, 10)

        dialog.show_all()
        response = dialog.run()

        if response == Gtk.ResponseType.OK:
            new_name = entry.get_text().strip()
            if new_name:
                self.tab_label.set_text(new_name)

        dialog.destroy()



























    def is_video_link(self, url):
        """Check if the URL points to a video file or streaming site."""
        video_extensions = (".mp4", ".mkv", ".webm", ".avi", ".mov", ".flv")
        parsed_url = urlparse(url)
        return parsed_url.path.endswith(video_extensions) or "youtube.com" in url or "vimeo.com" in url or "" 





    def on_download_started(self, webview, download):
        download.connect("decide-destination", self.on_decide_destination)
        download.connect("received-data", self.on_received_data)
        download.connect("finished", self.on_download_finished)

    def on_decide_destination(self, download, suggested_filename):
        downloads_dir = os.path.join(os.path.expanduser('~'), 'Downloads')
        os.makedirs(downloads_dir, exist_ok=True)
        destination = f"file://{downloads_dir}/{suggested_filename}"
        download.set_destination(destination)
        return True  # Indicate that the destination has been set

    def on_received_data(self, download, data_length):
        total = download.get_estimated_progress() * 100
        # Update a progress bar or similar UI element here
        logger.info(f"Download progress: {total:.2f}%")

    def on_download_finished(self, download):
        logger.info("Download finished.")
        # Update the UI to reflect the download completion


    def set_user_agent(self, url):
        """Set the user agent dynamically based on the URL and apply additional headers."""

        # Custom user agent for Pluto TV and Distrowatch
        if "pluto.tv" in url or "distrowatch.com" in url:
            pluto_user_agent = (
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                "AppleWebKit/537.36 (KHTML, like Gecko) "
                "Chrome/120.0.0.0 Safari/537.36"
            )
            self.settings.set_property("user-agent", pluto_user_agent)
            logger.info(f"User agent set for {url} (Pluto TV or Distrowatch).")

        # Empty user agent for YouTube
        elif "youtube.com" in url:
            self.settings.set_property("user-agent", "")
            logger.info("User agent set to empty for YouTube.")

        # Custom user agent and headers for specific sites
        elif "kcbd.com" in url:
            kcbd_user_agent = (
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                "AppleWebKit/537.36 (KHTML, like Gecko) "
                "Chrome/120.0.0.0 Safari/537.36"
            )
            self.settings.set_property("user-agent", kcbd_user_agent)
            logger.info(f"User agent set for {url} (KCBD).")

            # Inject additional headers specifically for KCBD
            script = """
                (function() {
                    const originalFetch = window.fetch;
                    window.fetch = function(url, options = {}) {
                        options.headers = {
                            ...options.headers,
                            'Referer': 'https://www.kgbd.com/',  // Use the actual site as the referer
                            'Accept-Language': 'en-US,en;q=0.9',
                            'Accept-Encoding': 'gzip, deflate, br'
                        };
                        return originalFetch(url, options);
                    };

                    const originalXhrOpen = XMLHttpRequest.prototype.open;
                    XMLHttpRequest.prototype.open = function(method, url, ...args) {
                        this.setRequestHeader('Referer', 'https://www.kgbd.com/');
                        this.setRequestHeader('Accept-Language', 'en-US,en;q=0.9');
                        this.setRequestHeader('Accept-Encoding', 'gzip, deflate, br');
                        return originalXhrOpen.call(this, method, url, ...args);
                    };
                })();
            """
            # Execute the script in the webview
            self.webview.run_javascript(script)
            logger.info("Injected additional headers for KCBD.")

        # Custom user agent for other specific sites
        elif any(domain in url for domain in [
            "therokuchannel.com",
            "watch.plex.tv",
            "crackle.com",
            "sourceforge.net",
            "deepai.org"
        ]):
            spoofed_user_agent = (
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                "AppleWebKit/537.36 (KHTML, like Gecko) "
                "Chrome/120.0.0.0 Safari/537.36"
            )
            self.settings.set_property("user-agent", spoofed_user_agent)
            logger.info(f"User agent set to spoofed default for {url}.")

        # Default user agent for all other sites
        else:
            default_user_agent = (
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                "AppleWebKit/537.36 (KHTML, like Gecko) "
                "Chrome/120.0.0.0 Safari/537.36"
            )
            self.settings.set_property("user-agent", default_user_agent)
            logger.info("Default user agent applied.")

        # Apply the updated settings to the webview
        self.webview.set_settings(self.settings)





    def on_uri_changed(self, webview, param):
        """Update current URI, apply user agent, and apply site-specific settings."""
        self.current_uri = webview.get_uri()
        logger.info(f"Current URI: {self.current_uri}")

        # Set user agent dynamically
        self.set_user_agent(self.current_uri)

        # Check if the current YouTube link is a "free with ads" movie
        if "youtube.com" in self.current_uri and self.is_youtube_movie_with_ads(self.current_uri):
            logger.info("Detected a YouTube 'free with ads' movie. Launching mpv...")
            self.play_with_mpv(self.current_uri)
            return  # Skip loading in WebKit

        # Update the address bar with the current URI
        self.browser.update_address_bar(self.current_uri)

        # Define sites to disable content blocking
        whitelist_sites = ["watch.plex.tv", "crackle.com", "distrowatch.com", "kcbd.com", "deepai.org"]
        if any(site in self.current_uri for site in whitelist_sites):
            self.apply_content_blocking_rules([])  # Clear adblock rules for whitelisted sites
            logger.info(f"Ad blocking disabled for {self.current_uri}.")
        else:
            self.apply_content_blocking_rules(self.settings_manager.get_adblock_rules())

        # Apply site-specific settings
        self.apply_site_settings(self.current_uri)



    def is_youtube_movie_with_ads(self, url):
        """Check if the YouTube URL corresponds to a 'free with ads' movie."""
        # Simple regex to check for YouTube movie URLs with ads
        return bool(re.search(r"youtube\.com/watch\?v=.*&pp=.+", url))








    def inject_login_detection_script(self):
        """Inject JavaScript to detect login forms."""
        login_detection_js = """
        (function() {
            function detectLoginForms() {
                const forms = document.querySelectorAll('form');
                forms.forEach(form => {
                    if (form.querySelector('input[type="password"]')) {
                        window.webkit.messageHandlers.loginDetector.postMessage(JSON.stringify({
                            action: 'loginFormDetected',
                            form: {
                                action: form.getAttribute('action'),
                                method: form.getAttribute('method')
                            }
                        }));
                    }
                });
            }

            if (document.readyState === 'complete') {
                detectLoginForms();
            } else {
                window.addEventListener('load', detectLoginForms);
            }
        })();
        """
        user_script = WebKit2.UserScript.new(
            login_detection_js,
            WebKit2.UserContentInjectedFrames.ALL_FRAMES,
            WebKit2.UserScriptInjectionTime.END
        )
        self.user_content_manager.add_script(user_script)

    def inject_autofill_script(self):
        """Inject JavaScript to listen for form submissions and send data to Python."""
        autofill_script = """
        (function() {
            function notifyPython(message) {
                window.webkit.messageHandlers.autofill.postMessage(JSON.stringify(message));
            }

            document.addEventListener('submit', function(event) {
                var form = event.target;
                var inputs = form.querySelectorAll('input[type="text"], input[type="email"], input[type="password"]');
                var formData = {};
                inputs.forEach(function(input) {
                    if (input.name || input.id) {
                        formData[input.name || input.id] = input.value;
                    }
                });
                notifyPython({
                    action: 'formSubmitted',
                    data: formData
                });
            }, true);
        })();
        """
        user_script = WebKit2.UserScript.new(
            autofill_script,
            WebKit2.UserContentInjectedFrames.ALL_FRAMES,
            WebKit2.UserScriptInjectionTime.START
        )
        self.user_content_manager.add_script(user_script)

        
    def inject_adblock_script(self, ad_block_rules=None):
        """Inject a user script to block ads, excluding whitelisted domains."""
        adblock_script = """
        (function() {
            const whitelist = ['deepai.org'];

            // Check if the current site is whitelisted
            if (whitelist.some(domain => window.location.hostname.includes(domain))) {
                console.log("Ad-blocking disabled for:", window.location.hostname);
                return; // Skip ad-blocking for whitelisted domains
            }

            const adSelectors = [
                'iframe[src*="ads"]',
                'div[id^="ad-"]',
                'div[class^="ad-"]',
                'div[class*="sponsored"]',
                'div[id*="sponsor"]',
                'span[class*="sponsor"]',
                'a[href*="utm_source=ad"]'
            ];

            adSelectors.forEach(selector => {
                document.querySelectorAll(selector).forEach(el => {
                    console.log("Removing element:", el);
                    el.remove();
                });
            });
        })();
        """

        self.user_content_manager.add_script(
            WebKit2.UserScript.new(
                adblock_script,
                WebKit2.UserContentInjectedFrames.ALL_FRAMES,
                WebKit2.UserScriptInjectionTime.END,
                None,
                None
            )
        )



    def on_login_form_detected(self, user_content_manager, message):
        """Handle login form detection."""
        try:
            data = json.loads(message.get_js_value().to_string())
            if data.get('action') == 'loginFormDetected':
                logger.info("Login form detected via JavaScript.")
                self.prompt_to_save_credentials()
                
                # Attempt to autofill if credentials are already saved
                if self.current_uri:
                    domain = urlparse(self.current_uri).netloc
                    username, password = self.credentials_manager.get_credentials(domain)
                    if username and password:
                        self.perform_autofill(username, password)
        except Exception as e:
            logger.error(f"Failed to parse loginDetector message: {e}")


    def perform_autofill(self, username, password):
        """Automatically fill saved credentials into the login form, including handling dynamic content and iframes."""
        if not self.current_uri:
            logger.warning("No current URI to perform autofill.")
            return

        parsed_url = urlparse(self.current_uri)
        domain = parsed_url.hostname

        if not domain:
            logger.warning("Cannot perform autofill without domain information.")
            return

        # JavaScript to fill in the username and password fields, including inside iframes
        autofill_js = f"""
        (function() {{
            function autofillFields(doc) {{
                var usernameField = doc.querySelector('input[type="text"], input[type="email"]');
                var passwordField = doc.querySelector('input[type="password"]');
                
                if (usernameField && passwordField) {{
                    usernameField.value = "{username}";
                    passwordField.value = "{password}";
                    console.log("Autofilled username and password.");
                }} else {{
                    console.warn("Could not find username or password fields to autofill.");
                }}
            }}

            function tryAutofill() {{
                autofillFields(document);

                var iframes = document.querySelectorAll('iframe');
                iframes.forEach(function(iframe) {{
                    try {{
                        var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                        autofillFields(iframeDoc);
                    }} catch (e) {{
                        console.warn("Could not access iframe due to cross-origin restrictions.");
                    }}
                }});
            }}

            // Run autofill immediately and on future content changes
            tryAutofill();

            // Observe dynamic changes to the DOM and try autofill again when changes occur
            var observer = new MutationObserver(function(mutations) {{
                tryAutofill();
            }});

            observer.observe(document.body, {{ childList: true, subtree: true }});
        }})();
        """

        # Inject the JavaScript into the current page
        self.webview.run_javascript(autofill_js, None, self.on_autofill_injected, None)
        logger.info(f"Autofill script injected for domain: {domain}")



    def set_default_user_agent(self):
        """Optionally revert to a standard user-agent for problematic sites."""
        # Revert to WebKit's default user-agent when needed
        default_agent = self.webview.get_settings().get_property("user-agent")
        self.settings.set_property("user-agent", default_agent)
        logger.info("Reverted to browser's default user-agent for better compatibility.")




    def log_captcha_attempts(self, url):
        """Logs details around CAPTCHA activities for debugging."""
        logger.info(f"CAPTCHA encountered. Verifying for page: {url}")

        # Use this method where interaction or form activity is detected via JavaScript messages.
        self.user_content_manager.connect("script-message-received::autofill", self.log_captcha_attempts)




    def execute_captcha_js(self):
        captcha_js = """
        (function() {
            console.log("Executing CAPTCHA interaction script.");
            var iframe = document.querySelector('iframe');
            if (iframe) {
                iframe.contentWindow.location.reload();
            }
        })();
        """
        self.webview.run_javascript(captcha_js, None, None, None)
        logger.info("Executed CAPTCHA interaction script.")




    def handle_load_errors(self, webview, load_event):
        if load_event == WebKit2.LoadEvent.FAILED:
            logger.error("Failed to load a page, initiating CAPTCHA handling logic.")
            if "captcha" in webview.get_uri().lower():
                self.execute_captcha_js()  # Run any necessary fallback logic to reattempt page load

    # Trigger this function when load events occur:
        self.webview.connect("load-changed", self.handle_load_errors)



    def on_autofill_message_received(self, user_content_manager, message):
        """Handle autofill form submission messages."""
        try:
            data = json.loads(message.get_js_value().to_string())
            if data.get('action') == 'formSubmitted':
                form_data = data.get('data', {})
                logger.info(f"Form submitted with data: {form_data}")
                self.handle_form_submission(form_data)
        except Exception as e:
            logger.error(f"Failed to parse autofill message: {e}")


    def on_autofill_injected(self, web_view, result, user_data):
        """Handle the result of the autofill JavaScript execution."""
        try:
            web_view.run_javascript_finish(result)
            logger.info("Autofill JavaScript executed successfully.")
        except Exception as e:
            logger.error(f"Failed to execute autofill JavaScript: {e}")



    def handle_form_submission(self, form_data):
        """Process form submission data."""
        # Extract username and password from form_data
        username = None
        password = None
        for key, value in form_data.items():
            if 'user' in key.lower():
                username = value
            elif 'pass' in key.lower():
                password = value

        if username and password:
            domain = urlparse(self.current_uri).netloc
            self.prompt_to_save_credentials(username, password, domain)

    def prompt_to_save_credentials(self, site, username, password):
        """Prompt the user to save credentials unless they've previously declined."""
        if site in self.declined_sites:
            logger.info(f"User previously declined to save credentials for {site}. Skipping prompt.")
            return

        dialog = Gtk.MessageDialog(
            parent=self,
            modal=True,
            destroy_with_parent=True,
            message_type=Gtk.MessageType.QUESTION,
            buttons=Gtk.ButtonsType.YES_NO,
            text="Save Credentials?",
        )
        dialog.format_secondary_text(f"Would you like to save credentials for {site}?")

        response = dialog.run()
        dialog.destroy()

        if response == Gtk.ResponseType.YES:
            self.save_credentials(site, username, password)
        elif response == Gtk.ResponseType.NO:
            self.declined_sites.append(site)
            self.save_declined_sites()

    def clear_declined_sites(self):
        """Clear the list of declined sites."""
        self.declined_sites = []
        self.save_declined_sites()
        logger.info("Declined sites list cleared.")




    def on_script_message_received(self, user_content_manager, message):
        """Handle media control messages (play/pause)."""
        body = message.get_js_value().to_string()
        logger.info(f"Script message received: {body}")

        if body == 'play':
            self.handle_media_play()
        elif body == 'pause':
            self.handle_media_pause()

    def handle_media_play(self):
        logger.info("Media started playing.")

    def handle_media_pause(self):
        logger.info("Media paused.")

    def apply_site_settings(self, url):
        """Apply site-specific settings like mute."""
        site_settings = self.settings_manager.get_site_settings(url)
        logger.info(f"Retrieved settings for {url}: {site_settings}")
        if 'mute' in site_settings:
            self.is_muted = site_settings['mute']
            if self.is_muted:
                self.mute_audio(url)
            else:
                self.unmute_audio(url)
            logger.info(f"Applied mute setting for {url}: {self.is_muted}")

    def save_site_settings(self, url, setting_key, setting_value):
        """Save site-specific settings."""
        parsed_url = urlparse(url)
        domain = parsed_url.netloc
        if domain:
            self.browser.settings_manager.set_site_settings(url, setting_key, setting_value)


    def on_tab_right_click(self, widget, event):
        """Show context menu on right-click of the tab."""
        if event.type == Gdk.EventType.BUTTON_PRESS and event.button == 3:
            self.show_context_menu(event)

    def show_context_menu(self, event):
        """Display context menu for the tab."""
        menu = Gtk.Menu()

        mute_label = "Unmute" if self.is_muted else "Mute"
        mute_item = Gtk.MenuItem(label=mute_label)
        mute_item.connect("activate", self.on_mute_toggle)
        menu.append(mute_item)

        reload_item = Gtk.MenuItem(label="Reload Tab")
        reload_item.connect("activate", self.on_reload_tab)
        menu.append(reload_item)

        close_item = Gtk.MenuItem(label="Close Tab")
        # Corrected the method name here
        close_item.connect("activate", self.browser.on_close_tab, self)
        menu.append(close_item)

        menu.show_all()
        menu.popup_at_pointer(event)

    def on_mute_toggle(self, widget):
        """Toggle mute state of the tab."""
        current_url = self.webview.get_uri()
        if self.is_muted:
            self.unmute_audio(current_url)
        else:
            self.mute_audio(current_url)

    def on_reload_tab(self, widget):
        """Reload the current tab."""
        self.webview.reload()
        logger.info("Tab reloaded.")

    def on_title_changed(self, webview, param):
        """Update the tab label with the page title."""
        title = webview.get_title() or "New Tab"
        shortened_title = self.shorten_title(title, max_length=30)
        GLib.idle_add(self.tab_label.set_text, shortened_title)
        logger.info(f"Tab title updated to: {shortened_title}")

    def shorten_title(self, title, max_length=30):
        """Shorten the tab title if it exceeds max_length."""
        if len(title) > max_length:
            return title[:max_length] + '...'
        return title

    def mute_audio(self, url):
        """Mute all media elements on the page."""
        self.is_muted = True
        self.save_site_settings(url, 'mute', True)
        mute_script = """
        var mediaElements = document.querySelectorAll('audio, video');
        mediaElements.forEach(ele => ele.muted = true);
        """
        self.mute_button.set_image(Gtk.Image.new_from_icon_name("audio-volume-muted", Gtk.IconSize.BUTTON))
        self.webview.run_javascript(mute_script, None, None, None)
        logger.info(f"Muted audio for: {url}")

    def unmute_audio(self, url):
        """Unmute all media elements on the page."""
        self.is_muted = False
        self.save_site_settings(url, 'mute', False)
        unmute_script = """
        var mediaElements = document.querySelectorAll('audio, video');
        mediaElements.forEach(ele => ele.muted = false);
        """
        self.mute_button.set_image(Gtk.Image.new_from_icon_name("audio-volume-high", Gtk.IconSize.BUTTON))
        self.webview.run_javascript(unmute_script, None, None, None)
        logger.info(f"Unmuted audio for: {url}")



    def on_autofill_injected(self, web_view, result, user_data):
        """Handle the result of the autofill JavaScript execution."""
        try:
            web_view.run_javascript_finish(result)
            logger.info("Autofill JavaScript executed successfully.")
        except Exception as e:
            logger.error(f"Failed to execute autofill JavaScript: {e}")


        
        # Attempt to autofill if credentials exist
        if self.current_uri:
            domain = urlparse(self.current_uri).netloc
            username, password = self.credentials_manager.get_credentials(domain)
            if username and password:
                self.perform_autofill(username, password)
        elif load_event == WebKit2.LoadEvent.FAILED:
            self.browser.progress_bar.hide()
            logger.error("Page load failed.")


    def on_load_progress(self, webview, param):
        """Update the browser's progress bar based on page load progress."""
        progress = webview.get_estimated_load_progress() * 100
        self.browser.update_progress(progress)
        logger.debug(f"Load progress updated: {progress}%")

    # ------------------------------
    # Context Menu and Media Control
    # ------------------------------
    def show_context_menu(self, event):
        """Display context menu for the tab."""
        menu = Gtk.Menu()

        mute_label = "Unmute" if self.is_muted else "Mute"
        mute_item = Gtk.MenuItem(label=mute_label)
        mute_item.connect("activate", self.on_mute_toggle)
        menu.append(mute_item)

        reload_item = Gtk.MenuItem(label="Reload Tab")
        reload_item.connect("activate", self.on_reload_tab)
        menu.append(reload_item)

        close_item = Gtk.MenuItem(label="Close Tab")
        # Corrected the method name here
        close_item.connect("activate", self.browser.on_close_tab, self)
        menu.append(close_item)

        menu.show_all()
        menu.popup_at_pointer(event)

    # ------------------------------
    # Media Control Functions
    # ------------------------------
    def on_script_message_received_autofill(self, user_content_manager, message):
        """Handle autofill form submission messages."""
        self.on_autofill_message_received(user_content_manager, message)

    # Additional methods can be added here as needed




import threading
import requests
from gi.repository import GLib, WebKit2
import logging

logger = logging.getLogger(__name__)

class PerformanceManager:
    """Manages performance optimizations and stability for the browser."""

    def __init__(self, browser):
        self.browser = browser
        self.watchdog_timer = None

    # ------------------------------
    # Asynchronous Content Fetching
    # ------------------------------
    def fetch_content_async(self, url, on_success, on_error):
        """Fetch content asynchronously to prevent blocking the main thread."""
        threading.Thread(target=self._fetch_content, args=(url, on_success, on_error), daemon=True).start()

    def _fetch_content(self, url, on_success, on_error):
        try:
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            content = response.text
            GLib.idle_add(on_success, content)
        except Exception as e:
            GLib.idle_add(on_error, e)

    # ------------------------------
    # Watchdog Timer for Page Loads
    # ------------------------------
    def start_watchdog(self, webview, timeout=15):
        """Start a watchdog timer to monitor page load time."""
        self.stop_watchdog()  # Ensure no existing watchdog is running
        self.watchdog_timer = threading.Timer(timeout, self._on_watchdog_timeout, args=(webview,))
        self.watchdog_timer.start()

    def stop_watchdog(self):
        """Stop the watchdog timer."""
        if self.watchdog_timer:
            self.watchdog_timer.cancel()
            self.watchdog_timer = None

    def _on_watchdog_timeout(self, webview):
        """Handle watchdog timeout by stopping the load and logging a warning."""
        GLib.idle_add(webview.stop_loading)
        logger.warning("Page load took too long and was stopped by watchdog.")

    # ------------------------------
    # Content Blocking Management
    # ------------------------------
    def apply_content_blocking_rules(self, webview, rules, whitelist_sites):
        """Apply content blocking rules unless the current URI is whitelisted."""
        current_uri = webview.get_uri()
        if any(site in current_uri for site in whitelist_sites):
            webview.get_user_content_manager().remove_all_scripts()
            logger.info(f"Content blocking disabled for {current_uri}.")
        else:
            # Apply content blocking rules
            webview.get_user_content_manager().remove_all_scripts()
            for rule in rules:
                webview.get_user_content_manager().add_script(rule)
            logger.info(f"Content blocking applied for {current_uri}.")

    # ------------------------------
    # Inject Additional Headers
    # ------------------------------
    def inject_headers(self, webview):
        """Inject additional headers to improve compatibility with some sites."""
        script = """
            (function() {
                const originalFetch = window.fetch;
                window.fetch = function(url, options = {}) {
                    options.headers = {
                        ...options.headers,
                        'Referer': 'https://www.google.com/',
                        'Accept-Language': 'en-US,en;q=0.9',
                        'Accept-Encoding': 'gzip, deflate, br'
                    };
                    return originalFetch(url, options);
                };

                const originalXhrOpen = XMLHttpRequest.prototype.open;
                XMLHttpRequest.prototype.open = function(method, url, ...args) {
                    this.setRequestHeader('Referer', 'https://www.google.com/');
                    this.setRequestHeader('Accept-Language', 'en-US,en;q=0.9');
                    this.setRequestHeader('Accept-Encoding', 'gzip, deflate, br');
                    return originalXhrOpen.call(this, method, url, ...args);
                };
            })();
        """
        webview.run_javascript(script)
        logger.info("Injected additional headers for enhanced compatibility.")










from gi.repository import Gio, WebKit2
import re
import os




import threading
class SimpleBrowser(Gtk.Window):
    """Main browser window."""

    # Add the DOWNLOAD_MIME_TYPES list here at the class level
    DOWNLOAD_MIME_TYPES = [
        'application/octet-stream',       # General binary files
        'application/x-iso9660-image',    # ISO files
        'application/zip',                # ZIP files
        'application/x-tar',              # TAR files
        'application/x-bzip2',            # BZ2 files
        'application/x-gzip',             # GZ files
        'application/x-7z-compressed',    # 7Z files
        'application/pdf',                # PDF files
        'video/mp4',                      # MP4 files
        'video/x-matroska',               # MKV files
        'video/webm',                     # WebM files
    ]



    TLD_SET = {".com", ".org", ".net", ".io", ".co"}
    PROBABLE_URL_REGEX = re.compile(r'^\S+?\.\S+')

    def __init__(self):
        super(SimpleBrowser, self).__init__()
        self.set_default_size(1200, 800)
        self.set_title("Simple Browser")
        self.connect('destroy', self.on_destroy)
        
        # Initialize notify2 for sending notifications
        notify2.init("Simple Browser")


        


        # Automatically maximize the window
        self.maximize()


        # Initialize URL history before any other operations
        self.url_history_file = os.path.join(os.path.expanduser('~'), '.simple_browser', 'url_history.json')
        self.url_history = self.load_url_history()

      
        # Initialize operation lock for download management
        self.operation_lock = threading.Lock()


        # Initialize webclip directory
        self.webclip_dir = os.path.join(os.path.expanduser('~'), '.simple_browser', 'webclips')
        os.makedirs(self.webclip_dir, exist_ok=True)


        # Initialize Download Manager
        self.download_manager = DownloadManager(self)




        

        self.web_context = WebKit2.WebContext.get_default()

        # Initialize SiteStabilizer
        self.site_stabilizer = SiteStabilizer(self)

        self.setup_cookie_manager()

        # Initialize managers
        self.settings_manager = SettingsManager()
        self.autofill_manager = AutofillManager()
        self.credentials_manager = CredentialsManager()
        self.performance_manager = PerformanceManager(self)

        # Initialize Page Stabilizer
        self.page_stabilizer = PageStabilizer(self)  # <--- Place it here

        self.DECLINED_SITES_FILE = os.path.join(os.path.expanduser("~"), ".simple_browser", "declined_sites.json")
        self.declined_sites = self.load_declined_sites()

        # Initialize MPV player
        #self.mpv_player = mpv.MPV()
        #self.mpv_player.observe_property('idle-active', self.on_mpv_idle)
        #self.mpv_player = mpv.MPV(ytdl=True)  # Enable youtube-dl support for streaming URLs


        # Initialize Download Manager

        # Create download manager UI components
        self.create_download_manager_window()

        self.connect("window-state-event", self.on_window_state_event)

        # WebKit2 context
        self.web_context = WebKit2.WebContext.get_default()
        cookie_manager = self.web_context.get_cookie_manager()
        cookie_manager.set_accept_policy(WebKit2.CookieAcceptPolicy.ALWAYS)

        # Set up persistent cookie storage
        cookie_storage_path = os.path.join(os.path.expanduser("~"), ".simple_browser", "cookies.sqlite")
        cookie_manager.set_persistent_storage(cookie_storage_path, WebKit2.CookiePersistentStorage.SQLITE)
        logger.info(f"Cookie storage path set to: {cookie_storage_path}")

        # Additional logging to confirm setup
        logger.debug("CookieManager accept policy set to ALWAYS.")


        


        # Global keyboard shortcuts
        self.connect("key-press-event", self.on_key_press_global)

        # GTK Theme
        settings = Gtk.Settings.get_default()
        settings.set_property("gtk-application-prefer-dark-theme", True)

        # Header Bar
        header_bar = Gtk.HeaderBar()
        header_bar.set_show_close_button(True)
        self.set_titlebar(header_bar)
        self.connect("key-press-event", self.on_key_press_global)

        # Address Bar
        self.address_bar = Gtk.Entry()
        self.address_bar.set_placeholder_text("Enter URL or search DuckDuckGo")
        self.address_bar.set_width_chars(80)
        self.address_bar.connect("activate", self.on_enter_address)
        self.address_bar.connect("key-press-event", self.on_key_press)
        header_bar.set_custom_title(self.address_bar)

        # Navigation Buttons
        self.add_navigation_buttons(header_bar)


        self.add_session_buttons(header_bar)  # Add session buttons


        # New Tab Button
        new_tab_button = Gtk.Button.new_with_label("+")
        new_tab_button.set_tooltip_text("New Tab")
        new_tab_button.connect("clicked", self.on_new_tab)
        header_bar.pack_end(new_tab_button)

        # Add Progress Bar to Header Bar
        self.progress_bar = Gtk.ProgressBar()
        self.progress_bar.set_show_text(True)
        self.progress_bar.set_fraction(0.0)
        self.progress_bar.set_hexpand(True)
        self.progress_bar.set_valign(Gtk.Align.CENTER)
        self.progress_bar.set_margin_start(10)
        self.progress_bar.set_margin_end(10)
        header_bar.pack_start(self.progress_bar)

        # Apply custom CSS for styling tabs and browser background with dark royal purple
        css = """
        * {
            background-color: black; /* Black for non-tab elements */
            color: #ffffff; /* White text for non-tab elements */
        }

        headerbar {
            background-color: #660000; /* Blood red for the header */
            color: #ffffff;
        }

        button, entry, progressbar {
            background-color: #800000; /* Slightly lighter blood red for interactive elements */
            color: #ffffff;
            border: none;
            border-radius: 4px;
        }

        button:hover {
            background-color: #990000; /* Lighter blood red on hover */
        }

        /* Blue progress bar */
        progressbar {
            background-color: #990000; /* Red background for the progress bar */
        }

        progressbar trough {
            background-color: #660000; /* Dark red for the trough */
        }

        progressbar progress {
            background-color: #000080;  /* Dark blue for the progress indicator */
        }

        .notebook tab {
            background-image: linear-gradient(to bottom right, #003366, #002244); /* Gradient from dark navy blue to darker blue */
            color: #ffffff; /* White text */
            font-weight: bold; /* Bold text */
            border: 2px solid #00008b; /* Dark blue border */
            outline: 3px solid #002244; /* Additional outline around tabs */
            box-shadow: 0 0 5px 2px rgba(0, 0, 139, 0.5); /* Subtle box shadow in dark blue */
            padding: 4px;
            margin: 2px;
            min-height: 20px;
            border-radius: 8px; /* Rounded corners */
        }

        .notebook tab:checked {
            background-image: linear-gradient(to bottom right, #004488, #003366); /* Inverted gradient for active tab */
            color: #ffffff; /* White text for active tab */
            font-weight: bold; /* Bold text */
            border: 2px solid #00008b; /* Dark blue border for active tab */
            outline: 3px solid #002244; /* Accent outline around active tabs */
            box-shadow: 0 0 8px 3px rgba(0, 0, 139, 0.7); /* More pronounced box shadow for active tab */
            padding: 4px;
            margin: 2px;
            min-height: 20px;
            border-radius: 8px; /* Rounded corners */
        }

        entry selection {
            background-color: yellow; /* Yellow highlight for selected text */
            color: black;  /* Change text color when highlighted */
        }

        /* Highlighted session button */
        .session-button.highlight {
            background-color: lime; /* Dark blue background for the highlighted session button */
            color: #ffffff;            /* White text */
            font-weight: bold;
            border: 2px solid yellow; /* Darker blue border */
            box-shadow: 0 0 5px 2px rgba(0, 0, 139, 0.5); /* Subtle box shadow */
        }
        """

        provider = Gtk.CssProvider()
        provider.load_from_data(css.encode('utf-8'))
        Gtk.StyleContext.add_provider_for_screen(
            Gdk.Screen.get_default(),
            provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )




        # Add Save WebClip Button
        save_webclip_button = Gtk.Button.new_from_icon_name("document-save", Gtk.IconSize.BUTTON)
        save_webclip_button.set_tooltip_text("Save WebClip")
        save_webclip_button.connect("clicked", self.on_save_webclip_with_js)

        header_bar.pack_end(save_webclip_button)




        # Add WebClip Manager Button
        webclip_button = Gtk.Button.new_from_icon_name("document-save-as", Gtk.IconSize.BUTTON)
        webclip_button.set_tooltip_text("Open WebClip Manager")
        webclip_button.connect("button-press-event", self.on_webclip_button_press)
        header_bar.pack_end(webclip_button)









        self.notebook = Gtk.Notebook()
        self.notebook.set_scrollable(True)
        self.notebook.set_tab_pos(Gtk.PositionType.TOP)
        self.notebook.connect("switch-page", self.on_switch_page)
        self.add(self.notebook)

        # Add Adblock Toggle
        self.add_adblock_toggle(header_bar)

        # Add Whitelist Manager Button
        self.add_whitelist_manager_button(header_bar)

        # Add Additional Buttons
        about_button = Gtk.Button.new_from_icon_name("help-about", Gtk.IconSize.BUTTON)
        about_button.set_tooltip_text("About Us")
        about_button.connect("clicked", self.on_about_us)
        header_bar.pack_end(about_button)

        # Create a download manager button with a download folder icon
        download_manager_button = Gtk.Button.new_from_icon_name("folder-download", Gtk.IconSize.BUTTON)
        download_manager_button.set_tooltip_text("Open Download Manager")
        download_manager_button.connect("clicked", self.download_manager.open_download_manager)


        # Add the button to the header bar
        header_bar.pack_end(download_manager_button)


        print_button = Gtk.Button.new_from_icon_name("document-print", Gtk.IconSize.BUTTON)
        print_button.set_tooltip_text("Print")
        print_button.connect("clicked", self.on_print_page)
        header_bar.pack_end(print_button)

        screenshot_button = Gtk.Button.new_from_icon_name("camera-photo", Gtk.IconSize.BUTTON)
        screenshot_button.set_tooltip_text("Take Screenshot")
        screenshot_button.connect("clicked", self.on_take_screenshot)
        header_bar.pack_end(screenshot_button)

        self.add_bookmark_buttons(header_bar)

        #save_tabs_button = Gtk.Button.new_from_icon_name("document-save", Gtk.IconSize.BUTTON)
        #save_tabs_button.set_tooltip_text("Save Current Tabs")
        #save_tabs_button.connect("clicked", self.on_save_tabs)
        #header_bar.pack_end(save_tabs_button)

        #clear_tabs_button = Gtk.Button.new_from_icon_name("edit-delete", Gtk.IconSize.BUTTON)
        #clear_tabs_button.set_tooltip_text("Clear Saved Tabs")
        #clear_tabs_button.connect("clicked", self.on_clear_saved_tabs)
        #header_bar.pack_end(clear_tabs_button)

        self.switch_tabs_icon = Gtk.Image.new_from_icon_name("go-down-symbolic", Gtk.IconSize.BUTTON)
        self.switch_tabs_button = Gtk.Button()
        self.switch_tabs_button.set_image(self.switch_tabs_icon)
        self.switch_tabs_button.set_tooltip_text("Toggle Tabs Position")
        self.switch_tabs_button.connect("clicked", self.toggle_tab_position)
        header_bar.pack_end(self.switch_tabs_button)

        # Initialize bookmarks
        self.bookmarks = []
        self.bookmarks_file = os.path.join(os.path.expanduser('~'), '.simple_browser', 'bookmarks.json')
        self.load_bookmarks()

        self.homepage = "https://www.duckduckgo.com"

        # Load saved tabs or open a new one
        tabs_loaded = self.load_open_tabs()
        if tabs_loaded == 0:
            self.on_new_tab_with_url(self.homepage)

        # Create the clear cache button with an icon
        self.clear_cache_icon = Gtk.Image.new_from_icon_name("edit-clear", Gtk.IconSize.BUTTON)
        self.clear_cache_button = Gtk.Button()
        self.clear_cache_button.set_image(self.clear_cache_icon)
        self.clear_cache_button.set_tooltip_text("Clear Cache")
        self.clear_cache_button.connect("clicked", self.clear_browser_cache)

        # Add the clear cache button to the header bar
        header_bar.pack_end(self.clear_cache_button)

    import os
    import logging

    # Configure logging
    logging.basicConfig(level=logging.DEBUG)

    # Method to clear the browser cache
    def clear_browser_cache(self, _):
        """Clear the browser cache and show a notification."""
        cache_path = os.path.expanduser("~/.cache/webkitgtk")
        
        # Log the cache contents before clearing
        if os.path.exists(cache_path):
            logging.debug(f"Cache before clearing: {os.listdir(cache_path)}")
        else:
            logging.debug("Cache directory does not exist before clearing.")
        
        # Clear the browser cache
        self.web_context.clear_cache()
        
        # Log the cache contents after clearing
        if os.path.exists(cache_path):
            logging.debug(f"Cache after clearing: {os.listdir(cache_path)}")
        else:
            logging.debug("Cache directory does not exist after clearing.")

        # Show a notification
        self.show_notification("Cache cleared successfully.")

    # Method to show a notification (if not already present)
    def show_notification(self, message):
        """Display a notification dialog with the given message."""
        dialog = Gtk.MessageDialog(
            transient_for=self,
            flags=0,
            message_type=Gtk.MessageType.INFO,
            buttons=Gtk.ButtonsType.OK,
            text="Notification",
        )
        dialog.format_secondary_text(message)
        dialog.run()
        dialog.destroy()



    def on_page_load(self, webview, url):
        """Handle actions when a page is loaded."""
        self.site_stabilizer.stabilize_site(url)



    def inject_ad_blocking_script(self, webview):
        """Inject JavaScript to block ads on TypingTest website specifically."""
        ad_blocking_script = """
        (function blockAds() {
            function removeAds() {
                const adSelectors = [
                    'iframe[src*="ads"]',
                    'iframe[src*="doubleclick.net"]',
                    'div[id*="ad"]',
                    'div[class*="ad"]',
                    'div[id*="sponsor"]',
                    'div[class*="sponsor"]',
                    'div[class*="advertisement"]',
                    'div[id*="advertisement"]',
                    'div[class*="promo"]',
                    'div[id*="promo"]'
                ];

                adSelectors.forEach(selector => {
                    document.querySelectorAll(selector).forEach(el => el.remove());
                });
            }

            removeAds();

            const observer = new MutationObserver(mutations => {
                mutations.forEach(() => removeAds());
            });

            observer.observe(document.body, { childList: true, subtree: true });

            console.log("Ad-blocking script applied.");
        })();
        """

        webview.run_javascript(ad_blocking_script, None, None, None)



    def highlight_session(self, session_name):
        """Highlight the button for the active session (S1 or S2)."""

        # Remove the 'highlight' class from both buttons
        for button in [self.s1_button, self.s2_button]:
            button.get_style_context().remove_class("highlight")

        # Add the 'highlight' class to the active session button
        if session_name == "session1":
            self.s1_button.get_style_context().add_class("highlight")
        elif session_name == "session2":
            self.s2_button.get_style_context().add_class("highlight")


    def save_session(self, session_name):
        """Save the current tabs to the specified session file and highlight the button."""
        session_file = os.path.join(os.path.expanduser("~"), f".simple_browser/{session_name}.json")
        try:
            tabs = []
            for i in range(self.notebook.get_n_pages()):
                page = self.notebook.get_nth_page(i)
                if isinstance(page, BrowserTab):
                    uri = page.webview.get_uri()
                    if uri:
                        tabs.append(uri)

            os.makedirs(os.path.dirname(session_file), exist_ok=True)
            with open(session_file, 'w') as f:
                json.dump(tabs, f, indent=4)

            logger.info(f"Session '{session_name}' saved successfully.")
            self.highlight_session(session_name)  # Highlight the button after saving
        except Exception as e:
            logger.error(f"Failed to save session '{session_name}': {e}")


    def load_session(self, session_name):
        """Load the specified session and highlight it."""
        session_file = os.path.join(os.path.expanduser("~"), f".simple_browser/{session_name}.json")
        if os.path.exists(session_file):
            self.on_clear_all_tabs()
            try:
                with open(session_file, 'r') as f:
                    urls = json.load(f)
                    for url in urls:
                        self.on_new_tab_with_url(url)
                logger.info(f"Session '{session_name}' loaded successfully.")
                
                # Highlight the active session button and show a notification
                self.highlight_session(session_name)
                self.show_session_notification(session_name)
                
            except Exception as e:
                logger.error(f"Failed to load session '{session_name}': {e}")
        else:
            logger.warning(f"Session '{session_name}' file not found.")





    def highlight_session(self, session_name):
        """Highlight the currently active session button."""
        # Remove the highlight class from all session buttons
        for button in [self.s1_button, self.s2_button]:
            button.get_style_context().remove_class("highlight")

        # Add the highlight class to the active session button
        if session_name == "session1":
            self.s1_button.get_style_context().add_class("highlight")
        elif session_name == "session2":
            self.s2_button.get_style_context().add_class("highlight")



    def on_clear_all_tabs(self):
        """Close all open tabs."""
        while self.notebook.get_n_pages() > 0:
            page = self.notebook.get_nth_page(0)
            if isinstance(page, BrowserTab):
                self.notebook.remove(page)
                page.webview.destroy()
                page.destroy()
        logger.info("All tabs cleared.")



    def clear_all_tabs(self):
        """Close all open tabs."""
        while self.notebook.get_n_pages() > 0:
            page = self.notebook.get_nth_page(0)
            if isinstance(page, BrowserTab):
                self.notebook.remove(page)
                page.webview.destroy()
                page.destroy()








    def add_session_buttons(self, header_bar):
        """Add buttons for session 1 and session 2 to the header bar."""
        self.s1_button = Gtk.Button(label="S1")
        self.s1_button.get_style_context().add_class("session-button")
        self.s1_button.connect("clicked", lambda w: self.load_session("session1"))
        header_bar.pack_end(self.s1_button)

        self.s2_button = Gtk.Button(label="S2")
        self.s2_button.get_style_context().add_class("session-button")
        self.s2_button.connect("clicked", lambda w: self.load_session("session2"))
        header_bar.pack_end(self.s2_button)




    def show_session_notification(self, session_name):
        """Show a notification indicating which session was loaded."""
        if session_name == "session1":
            message = "Switched to Session 1"
        elif session_name == "session2":
            message = "Switched to Session 2"
        else:
            message = f"Switched to {session_name.capitalize()}"

        notification = notify2.Notification("Session Loaded", message)
        notification.show()









    def add_to_url_history(self, url):
        """Add a URL to the history if it's not already in the list and refresh suggestions."""
        if url and url not in self.url_history:
            self.url_history.append(url)
            self.save_url_history()
            # Update the ListStore with the new URL
            self.url_liststore.append([url])
            logger.info(f"Added URL to history: {url}")







    def setup_address_bar_completion(self):
        """Set up autocomplete for the address bar using URL history."""
        # Create a ListStore to hold the history entries (only one column for URLs)
        self.completion_store = Gtk.ListStore(str)

        # Populate the ListStore with the saved URL history
        for url in self.url_history:
            self.completion_store.append([url])

        # Create a Gtk.EntryCompletion and set it up
        completion = Gtk.EntryCompletion()
        completion.set_model(self.completion_store)
        completion.set_text_column(0)
        completion.set_inline_completion(True)  # Enable inline completion
        completion.set_popup_completion(True)   # Enable dropdown completion
        completion.set_popup_single_match(True) # Automatically select a single match

        # Attach the completion to the address bar
        self.address_bar.set_completion(completion)

    def on_enter_address(self, entry):
        """Load the entered URL in the current tab and save it to history."""
        raw_input = entry.get_text().strip()
        current_page = self.get_current_page()
        if current_page:
            if self.is_probable_url(raw_input):
                url = self.format_url(raw_input)
            else:
                query = quote_plus(raw_input)
                url = f"https://www.duckduckgo.com/?q={query}"

            current_page.webview.load_uri(url)
            logger.info(f"Navigating to: {url}")

            # Save the URL to history and update the completion model
            if url not in self.url_history:
                self.url_history.append(url)
                self.save_url_history()
                self.completion_store.append([url])  # Add to the completion store





    def on_save_webclip_with_js(self, widget=None):
        """Save the current page's HTML and resources using JavaScript, embedding images as base64."""
        current_page = self.get_current_page()
        if not current_page:
            self.show_error_dialog("No active page to save.")
            return

        def on_js_finished(webview, result, user_data):
            try:
                js_result = webview.run_javascript_finish(result)
                html_content = js_result.get_js_value().to_string()
                title = current_page.webview.get_title() or "webclip"
                sanitized_title = re.sub(r'[^\w\-_. ]', '_', title)
                save_path = os.path.join(self.webclip_dir, f"{sanitized_title}.html")

                with open(save_path, "w", encoding="utf-8") as f:
                    f.write(html_content)

                self.show_info_dialog(f"WebClip saved successfully:\n{save_path}")
            except Exception as e:
                self.show_error_dialog(f"Error saving WebClip: {e}")

        # JavaScript to embed images as base64 and capture the HTML
        script = """
        (function() {
            function getBase64Image(img) {
                const canvas = document.createElement('canvas');
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                return canvas.toDataURL('image/png');
            }

            function embedImages() {
                const images = document.querySelectorAll('img');
                images.forEach(img => {
                    if (img.src && !img.src.startsWith('data:')) {
                        const imgCopy = img;
                        const imgSrc = img.src;
                        const xhr = new XMLHttpRequest();
                        xhr.open('GET', imgSrc, true);
                        xhr.responseType = 'blob';
                        xhr.onload = function() {
                            const reader = new FileReader();
                            reader.onloadend = function() {
                                imgCopy.src = reader.result;
                            };
                            reader.readAsDataURL(xhr.response);
                        };
                        xhr.onerror = function() {
                            console.warn('Failed to load image:', imgSrc);
                        };
                        xhr.send();
                    }
                });
            }

            embedImages();

            // Return the outer HTML of the document
            return document.documentElement.outerHTML;
        })();
        """

        current_page.webview.run_javascript(script, None, on_js_finished, None)


















    def show_info_dialog(self, message):
        dialog = Gtk.MessageDialog(
            transient_for=self,
            flags=0,
            message_type=Gtk.MessageType.INFO,
            buttons=Gtk.ButtonsType.OK,
            text=message
        )
        dialog.run()
        dialog.destroy()

    def show_error_dialog(self, message):
        dialog = Gtk.MessageDialog(
            transient_for=self,
            flags=0,
            message_type=Gtk.MessageType.ERROR,
            buttons=Gtk.ButtonsType.OK,
            text=message
        )
        dialog.run()
        dialog.destroy()




    def show_message_dialog(self, message, message_type=Gtk.MessageType.INFO):
        """Display a message dialog with the given message."""
        dialog = Gtk.MessageDialog(
            transient_for=self,
            modal=True,
            destroy_with_parent=True,
            message_type=message_type,
            buttons=Gtk.ButtonsType.OK,
            text=message
        )
        dialog.run()
        dialog.destroy()


    def get_current_page(self):
        """Return the currently active browser tab."""
        page_num = self.notebook.get_current_page()
        return self.notebook.get_nth_page(page_num)




    def list_webclips(self):
        """List all saved WebClips."""
        webclips = []
        if os.path.exists(self.webclip_dir):
            webclips = [f for f in os.listdir(self.webclip_dir) if f.endswith(".html")]
        return webclips

    def open_webclip(self, path):
        """Open the selected MHTML webclip in a new tab."""
        if os.path.exists(path):
            uri = f"file://{path}"
            self.on_new_tab_with_url(uri)
        else:
            self.show_error_dialog(f"WebClip not found: {path}")






    def on_webclip_button_press(self, widget, event):
        """Handle the webclip button press event."""
        if event.button == 1:  # Left mouse button
            self.show_webclip_manager()








    def show_webclip_manager(self, widget=None):
        """Display a manager for viewing saved webclips."""
        dialog = Gtk.Dialog(
            title="WebClip Manager",
            transient_for=self,
            modal=True,
            destroy_with_parent=True
        )
        dialog.set_default_size(1000, 600)
        dialog.add_buttons(Gtk.STOCK_CLOSE, Gtk.ResponseType.CLOSE)

        content_area = dialog.get_content_area()

        # Scrolled Window for WebClip List
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        content_area.pack_start(scrolled_window, True, True, 0)

        # ListBox to Display WebClips
        webclip_list = Gtk.ListBox()
        scrolled_window.add(webclip_list)

        # Load and display MHTML files from the webclip directory
        def load_webclips():
            # Clear existing items
            for child in webclip_list.get_children():
                webclip_list.remove(child)

            # List all .html files in the directory
            if os.path.exists(self.webclip_dir):
                for filename in os.listdir(self.webclip_dir):
                    if filename.endswith(".html"):
                        file_path = os.path.join(self.webclip_dir, filename)
                        row = create_webclip_row(filename, file_path)
                        webclip_list.add(row)

            webclip_list.show_all()

        # Create a row for each webclip with open and delete buttons
        def create_webclip_row(display_name, path):
            row = Gtk.ListBoxRow()
            hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)

            # Create a label for the webclip name
            label = Gtk.Label(label=display_name, xalign=0)
            label.set_hexpand(True)
            label.set_selectable(True)  # Allows the text to be selectable
            hbox.pack_start(label, True, True, 0)

            # Connect the label to open the webclip on left-click
            label.connect("button-press-event", lambda widget, event: self.open_webclip(path) if event.button == 1 else None)

            # Delete Button
            delete_button = Gtk.Button.new_from_icon_name("user-trash-symbolic", Gtk.IconSize.BUTTON)
            delete_button.set_tooltip_text("Delete WebClip")
            delete_button.connect("clicked", lambda btn: delete_webclip(row, path))
            hbox.pack_start(delete_button, False, False, 0)

            row.add(hbox)
            return row

        # Function to delete a webclip
        def delete_webclip(row, path):
            if os.path.exists(path):
                os.remove(path)
                webclip_list.remove(row)
                logger.info(f"Deleted WebClip: {path}")

        load_webclips()
        dialog.show_all()
        dialog.run()
        dialog.destroy()







    def load_declined_sites(self):
        """Load declined sites from a file."""
        if os.path.exists(self.DECLINED_SITES_FILE):
            with open(self.DECLINED_SITES_FILE, 'r') as f:
                return json.load(f)
        return []


    def save_declined_sites(self):
        """Save declined sites to a file."""
        with open(self.DECLINED_SITES_FILE, 'w') as f:
            json.dump(self.declined_sites, f)


    def remove_content_blockers(self):
        """Remove all user content filters (content blockers) from the WebContext."""
        try:
            # Check if the method 'remove_all_user_content_filters' exists in the current WebKitGTK version
            if hasattr(self.web_context, 'remove_all_user_content_filters'):
                self.web_context.remove_all_user_content_filters()
                logger.info("All user content filters removed successfully.")
            else:
                logger.warning("Method 'remove_all_user_content_filters' is not available in this version of WebKitGTK.")
        except Exception as e:
            logger.error(f"Failed to remove content blockers: {e}")


    def create_url_bar_with_autocomplete(self):
        self.address_bar = Gtk.Entry()
        self.address_bar.set_placeholder_text("Enter URL or search DuckDuckGo")
        self.address_bar.set_width_chars(80)
        self.address_bar.connect("activate", self.on_enter_address)

        # Set up entry completion for the address bar
        completion = Gtk.EntryCompletion()
        self.url_liststore = Gtk.ListStore(str)
        self.update_url_liststore()
        
        completion.set_model(self.url_liststore)
        completion.set_text_column(0)
        self.address_bar.set_completion(completion)

        # Add the address bar to the header bar
        self.header_bar = Gtk.HeaderBar()
        self.header_bar.set_show_close_button(True)
        self.header_bar.set_custom_title(self.address_bar)
        self.set_titlebar(self.header_bar)


    def load_url_history(self):
        """Load URL history from a file."""
        if os.path.exists(self.url_history_file):
            try:
                with open(self.url_history_file, 'r') as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"Failed to load URL history: {e}")
        return []

    def save_url_history(self):
        """Save URL history to a file."""
        logger.debug(f"Saving URL history to {self.url_history_file}")
        try:
            os.makedirs(os.path.dirname(self.url_history_file), exist_ok=True)
            with open(self.url_history_file, 'w') as f:
                json.dump(self.url_history, f, indent=4)
            logger.info(f"URL history saved successfully to {self.url_history_file}")
        except Exception as e:
            logger.error(f"Failed to save URL history: {e}")







    def load_page(self, url):
        """Load the given URL in the current tab."""
        current_page = self.get_current_page()
        if current_page:
            current_page.webview.load_uri(url)


    def update_url_liststore(self):
        """Update the ListStore with the current URL history."""
        self.url_liststore.clear()
        for url in self.url_history:
            self.url_liststore.append([url])








    def add_to_url_history(self, url):
        """Add a URL to the history if it's not already in the list."""
        if url and url not in self.url_history:
            self.url_history.append(url)
            self.save_url_history()
            logger.info(f"Added URL to history: {url}")

    def save_url_history(self):
        """Save URL history to a file."""
        try:
            os.makedirs(os.path.dirname(self.url_history_file), exist_ok=True)
            with open(self.url_history_file, 'w') as f:
                json.dump(self.url_history, f, indent=4)
            logger.info(f"URL history saved successfully to {self.url_history_file}")
        except Exception as e:
            logger.error(f"Failed to save URL history: {e}")















    def setup_cookie_manager(self):
        cookie_manager = self.web_context.get_cookie_manager()
        cookie_manager.set_accept_policy(WebKit2.CookieAcceptPolicy.ALWAYS)
        logger.info("Cookies are accepted to improve site compatibility.")
        

    def on_destroy(self, widget):
        """Handle application exit."""
        self.save_cookies_to_file()
        logger.info("Exiting application and saving cookies.")
        Gtk.main_quit()


    def on_mpv_idle(self, idle):
        if idle:
            logger.info("MPV playback finished.")



    def get_cookies_file_path(self):
        # Resolve path to user's Documents directory
        return os.path.join(os.path.expanduser("~/Documents"), "saved_cookies.json")

    def save_cookies_to_file(self):
        cookies_file_path = self.get_cookies_file_path()
        cookie_manager = self.web_context.get_cookie_manager()

        def save_cookies_callback(manager, result):
            try:
                cookies = manager.get_cookies_finish(result)
                cookies_list = [
                    {
                        "name": cookie.get_name(),
                        "value": cookie.get_value(),
                        "domain": cookie.get_domain(),
                        "path": cookie.get_path(),
                        "expires": cookie.get_expires(),
                        "http_only": cookie.is_http_only(),
                        "secure": cookie.is_secure(),
                    }
                    for cookie in cookies
                ]

                # Ensure the directory exists
                os.makedirs(os.path.dirname(cookies_file_path), exist_ok=True)

                with open(cookies_file_path, 'w') as f:
                    json.dump(cookies_list, f, indent=4)
                logger.info(f"Cookies saved successfully to {cookies_file_path}")

            except Exception as e:
                logger.error(f"Failed to save cookies: {e}")

        # Get cookies for all open tabs
        for i in range(self.notebook.get_n_pages()):
            page = self.notebook.get_nth_page(i)
            if isinstance(page, BrowserTab) and page.current_uri:
                cookie_manager.get_cookies_for_uri_async(page.current_uri, None, save_cookies_callback)




    def load_cookies_from_file(self):
        cookies_file_path = self.get_cookies_file_path()

        if os.path.exists(cookies_file_path):
            try:
                with open(cookies_file_path, 'r') as f:
                    cookies_list = json.load(f)

                cookie_manager = self.web_context.get_cookie_manager()
                for cookie_dict in cookies_list:
                    max_age = int(cookie_dict["expires"]) - int(time.time())

                    cookie = WebKit2.Cookie.new(
                        cookie_dict["name"],
                        cookie_dict["value"],
                        cookie_dict["domain"],
                        cookie_dict["path"],
                        max_age=max_age
                    )
                    if cookie_dict["http_only"]:
                        cookie.set_http_only(True)
                    if cookie_dict["secure"]:
                        cookie.set_secure(True)

                    cookie_manager.add_cookie(cookie, None)
                logger.info(f"Cookies loaded successfully from {cookies_file_path}")

            except Exception as e:
                logger.error(f"Failed to load cookies: {e}")




    # ------------------------------
    # Progress Bar Functions
    # ------------------------------
    def update_progress(self, progress):
        """Update the progress bar based on page load progress."""
        self.progress_bar.set_fraction(progress / 100.0)
        self.progress_bar.set_text(f"{progress:.0f}%")
        if progress >= 100:
            self.progress_bar.set_visible(False)
        else:
            self.progress_bar.set_visible(True)
        logger.debug(f"Progress bar updated to: {progress}%")

    # ------------------------------
    # Download Manager UI Functions
    # ------------------------------
    def create_download_manager_window(self):
        self.download_manager_window = Gtk.Window(title="Download Manager")
        self.download_manager_window.set_default_size(800, 300)

        self.downloads_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        self.downloads_box.set_margin_top(10)
        self.downloads_box.set_margin_bottom(10)
        self.downloads_box.set_margin_start(10)
        self.downloads_box.set_margin_end(10)

        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        scrolled_window.add(self.downloads_box)

        self.download_manager_window.add(scrolled_window)
        self.download_manager_window.hide()




    def style_download_progress_bar(self, progress_bar):
        """Apply custom CSS to the progress bar."""
        css = """
        progressbar trough {
            background-color: yellow;  /* Change background to yellow */
        }
        progressbar progress {
            background-color: yellow;  /* Keep progress indicator yellow */
        }
        """
        provider = Gtk.CssProvider()
        provider.load_from_data(css.encode('utf-8'))
        context = progress_bar.get_style_context()
        context.add_provider(provider, Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION)


    def update_download_progress_ui(self, download):
        """Update the UI with the latest download progress."""
        if 'progress_bar' in download:
            download['progress_bar'].set_fraction(download['progress'] / 100.0)
            download['progress_bar'].set_text(f"{download['progress']}%")

        if 'label_widget' in download:
            download['label_widget'].set_text(download['status'])

        # Update the time label if the download is still in progress or completed
        if 'time_label' in download:
            if download['status'] == 'Downloading':
                # Calculate elapsed time
                start_time = datetime.datetime.fromisoformat(download['start_time'])
                elapsed_time = datetime.datetime.now() - start_time
                download['time_label'].set_text(f"Elapsed: {str(elapsed_time).split('.')[0]}")
            elif download['status'] == 'Completed':
                # Show completion time
                end_time = datetime.datetime.fromisoformat(download['end_time'])
                download['time_label'].set_text(f"Completed at: {end_time.strftime('%Y-%m-%d %H:%M:%S')}")
            elif download['status'] == 'Failed':
                download['time_label'].set_text("Download Failed")

        return False

    def mark_download_complete(self, download):
        """Update the UI to reflect that a download is complete."""
        if 'progress_bar' in download and download['progress_bar']:
            download['progress_bar'].set_fraction(1.0)
            download['progress_bar'].set_text("Completed")
            if 'label_widget' in download and download['label_widget']:
                download['label_widget'].set_text("Completed")
        return False

    def mark_download_failed(self, download):
        """Update the UI to reflect that a download has failed."""
        if 'progress_bar' in download and download['progress_bar']:
            download['progress_bar'].set_text("Failed")
            if 'label_widget' in download and download['label_widget']:
                download['label_widget'].set_text("Failed")
        return False

    def complete_download(self, filepath, end_time, duration):
        """Handle download completion and update UI."""
        for download in self.download_manager.downloads:
            if download['filepath'] == filepath:
                download['progress'] = 100
                download['status'] = 'Completed'
                download['end_time'] = end_time
                download['duration'] = duration
                self.mark_download_complete(download)
                self.download_manager.save_download_history()

                # Send a notification when the download is complete
                notification = notify2.Notification(
                    "Download Complete",
                    f"File saved to: {filepath}",
                    "dialog-information"
                )
                notification.show()
                break
        return False


    def fail_download(self, filepath):
        """Handle download failure and update UI."""
        for download in self.download_manager.downloads:
            if download['filepath'] == filepath:
                download['status'] = 'Failed'
                self.mark_download_failed(download)
                break
        return False

    # ------------------------------
    # Bookmark Management
    # ------------------------------
    def add_bookmark_buttons(self, header_bar):
        """Add buttons related to bookmarks in the header bar."""
        bookmark_button = Gtk.Button.new_from_icon_name("bookmark-new", Gtk.IconSize.BUTTON)
        bookmark_button.set_tooltip_text("Bookmark this page")
        bookmark_button.connect("clicked", self.on_add_bookmark)
        header_bar.pack_end(bookmark_button)

        view_bookmarks_button = Gtk.Button.new_from_icon_name("emblem-favorite", Gtk.IconSize.BUTTON)
        view_bookmarks_button.set_tooltip_text("View Bookmarks")
        view_bookmarks_button.connect("clicked", self.on_view_bookmarks)
        header_bar.pack_end(view_bookmarks_button)

    def on_add_bookmark(self, widget):
        """Add the current page as a bookmark."""
        current_page = self.get_current_page()
        if not current_page:
            logger.warning("No page open to bookmark.")
            return

        uri = current_page.webview.get_uri()
        default_name = current_page.webview.get_title() or 'Untitled'

        dialog = Gtk.Dialog(
            title="Add Bookmark",
            transient_for=self,
            modal=True,
            destroy_with_parent=True
        )
        dialog.set_default_size(400, 150)
        dialog.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_ADD, Gtk.ResponseType.OK
        )

        content_area = dialog.get_content_area()

        name_label = Gtk.Label(label="Enter bookmark name:")
        name_label.set_xalign(0)
        content_area.pack_start(name_label, False, False, 5)

        name_entry = Gtk.Entry()
        name_entry.set_text(default_name)
        name_entry.set_activates_default(True)
        content_area.pack_start(name_entry, False, False, 5)

        url_label = Gtk.Label(label=f"URL: {uri}")
        url_label.set_xalign(0)
        url_label.set_selectable(True)
        url_label.set_line_wrap(True)
        content_area.pack_start(url_label, True, True, 5)

        dialog.set_default_response(Gtk.ResponseType.OK)
        dialog.show_all()

        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            name = name_entry.get_text().strip()
            if name and uri:
                self.bookmarks.append({'name': name, 'uri': uri})
                self.save_bookmarks()
                logger.info(f"Added bookmark: {name} -> {uri}")
            else:
                logger.warning("Bookmark not added due to missing name or URI.")

        dialog.destroy()





    def populate_bookmark_list(self, search_query=""):
        """Populate the bookmark list, filtering by search_query if provided."""
        # Clear existing bookmarks from the VBox
        for child in self.bookmark_vbox.get_children():
            self.bookmark_vbox.remove(child)

        # Sort bookmarks: matching bookmarks appear at the top
        for bookmark in self.bookmarks:
            name, uri = bookmark['name'], bookmark['uri']
            if search_query.lower() in name.lower() or search_query.lower() in uri.lower():
                hbox = Gtk.Box(spacing=6)

                # Checkbox for selecting bookmarks
                checkbox = Gtk.CheckButton()
                hbox.pack_start(checkbox, False, False, 0)

                # Label displaying the bookmark name and URL
                bookmark_label = Gtk.Label(label=f"{name} ({uri})")
                bookmark_label.set_xalign(0)
                bookmark_label.set_hexpand(True)
                bookmark_label.set_ellipsize(Pango.EllipsizeMode.END)
                bookmark_label.set_selectable(True)
                bookmark_label.add_events(Gdk.EventMask.BUTTON_PRESS_MASK)
                bookmark_label.connect("button-press-event", self.on_bookmark_open, uri)

                # Remove button for deleting the bookmark
                remove_button = Gtk.Button.new_from_icon_name("edit-delete", Gtk.IconSize.BUTTON)
                remove_button.set_tooltip_text("Remove Bookmark")
                remove_button.connect("clicked", self.on_remove_bookmark, bookmark)

                hbox.pack_start(bookmark_label, True, True, 0)
                hbox.pack_start(remove_button, False, False, 0)
                self.bookmark_vbox.pack_start(hbox, False, False, 0)

        self.bookmark_vbox.show_all()





    def on_search_entry_changed(self, search_entry):
        """Filter the bookmarks dynamically based on the search query."""
        search_query = search_entry.get_text()
        self.populate_bookmark_list(search_query)



    def on_view_bookmarks(self, widget):
        """Display the bookmarks in a dialog."""
        dialog = Gtk.Dialog(
            title="Bookmarks",
            transient_for=self,
            modal=True,
            destroy_with_parent=True
        )
        dialog.set_default_size(800, 400)
        dialog.add_buttons(Gtk.STOCK_CLOSE, Gtk.ResponseType.CLOSE)

        content_area = dialog.get_content_area()

        # Search Entry on Top
        search_entry = Gtk.Entry()
        search_entry.set_placeholder_text("Search bookmarks...")
        content_area.pack_start(search_entry, False, False, 0)

        # Scrolled Window for Bookmark List
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        content_area.pack_start(scrolled_window, True, True, 0)

        # VBox to Hold Bookmark Items
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        scrolled_window.add(vbox)

        bookmark_widgets = []

        # Function to Update Bookmark List Dynamically
        def update_bookmark_list():
            query = search_entry.get_text().lower().strip()
            
            # Clear existing children in vbox
            for child in vbox.get_children():
                vbox.remove(child)

            # Sort and filter bookmarks based on the search query
            for bookmark in self.bookmarks:
                name = bookmark['name'].lower()
                uri = bookmark['uri'].lower()
                if query in name or query in uri:
                    hbox = Gtk.Box(spacing=6)

                    checkbox = Gtk.CheckButton()
                    hbox.pack_start(checkbox, False, False, 0)

                    bookmark_label = Gtk.Label(label=f"{bookmark['name']} ({bookmark['uri']})")
                    bookmark_label.set_xalign(0)
                    bookmark_label.set_hexpand(True)
                    bookmark_label.set_ellipsize(Pango.EllipsizeMode.END)
                    bookmark_label.set_selectable(True)
                    bookmark_label.add_events(Gdk.EventMask.BUTTON_PRESS_MASK)

                    bookmark_label.connect("button-press-event", self.on_bookmark_open, bookmark['uri'], dialog)

                    remove_button = Gtk.Button.new_from_icon_name("edit-delete", Gtk.IconSize.BUTTON)
                    remove_button.set_tooltip_text("Remove Bookmark")
                    remove_button.connect("clicked", self.on_remove_bookmark, dialog, bookmark)

                    hbox.pack_start(bookmark_label, True, True, 0)
                    hbox.pack_start(remove_button, False, False, 0)
                    vbox.pack_start(hbox, False, False, 0)

                    bookmark_widgets.append((checkbox, bookmark_label, bookmark))

            vbox.show_all()

        # Initial Population of the Bookmark List
        update_bookmark_list()

        # Connect Search Entry to Update Function
        search_entry.connect("changed", lambda entry: update_bookmark_list())

        # Buttons for Actions at the Bottom
        vbox_buttons = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        content_area.pack_start(vbox_buttons, False, False, 0)

        open_selected_button = Gtk.Button(label="Open Selected")
        open_selected_button.connect("clicked", self.open_selected_bookmarks, bookmark_widgets)
        vbox_buttons.pack_start(open_selected_button, True, True, 0)

        dialog.show_all()
        response = dialog.run()
        if response == Gtk.ResponseType.CLOSE:
            dialog.destroy()
            logger.info("Bookmarks dialog closed.")









    def on_bookmark_open(self, widget, event, uri, dialog):
        """Handle opening a bookmark when clicked."""
        if event.button == 1:  # Left-click
            self.open_bookmark_in_current_tab(uri)
            logger.info(f"Opened bookmark in current tab: {uri}")
            dialog.response(Gtk.ResponseType.CLOSE)

    def open_selected_bookmarks(self, button, bookmark_widgets):
        """Open all selected bookmarks in new tabs."""
        for checkbox, label, bookmark in bookmark_widgets:
            if checkbox.get_active():
                uri = bookmark['uri']
                self.on_new_tab_with_url(uri)
                logger.info(f"Opened bookmark: {uri}")

    def on_remove_bookmark(self, widget, dialog, bookmark):
        """Remove a bookmark."""
        if bookmark in self.bookmarks:
            self.bookmarks.remove(bookmark)
            self.save_bookmarks()
            logger.info(f"Removed bookmark: {bookmark}")
            dialog.hide()
            self.on_view_bookmarks(None)

    def save_bookmarks(self):
        """Save bookmarks to a JSON file."""
        try:
            os.makedirs(os.path.dirname(self.bookmarks_file), exist_ok=True)
            with open(self.bookmarks_file, 'w') as f:
                json.dump(self.bookmarks, f, indent=4)
            logger.info("Bookmarks saved successfully.")
        except Exception as e:
            logger.error(f"Failed to save bookmarks: {e}")

    def load_bookmarks(self):
        """Load bookmarks from a JSON file."""
        if os.path.exists(self.bookmarks_file):
            try:
                with open(self.bookmarks_file, 'r') as f:
                    self.bookmarks = json.load(f)
                logger.info("Bookmarks loaded successfully.")
            except Exception as e:
                logger.error(f"Failed to load bookmarks: {e}")
        else:
            self.bookmarks = []
            logger.info("No bookmarks file found. Starting with empty bookmarks.")

    def on_bookmark_activated(self, button, bookmark_url):
        """Callback for when a bookmark is clicked."""
        self.open_bookmark_in_current_tab(bookmark_url)

    # ------------------------------
    # Ad-Blocking Functions
    # ------------------------------
    def add_adblock_toggle(self, header_bar):
        """Add a toggle button for ad-blocking."""
        self.adblock_toggle = Gtk.ToggleButton()
        self.adblock_toggle.set_relief(Gtk.ReliefStyle.NONE)
        self.adblock_toggle.set_focus_on_click(False)

        # Use checkbox icons for active (ON) and inactive (OFF) states
        self.adblock_icon_active = "checkbox-checked-symbolic"
        self.adblock_icon_inactive = "checkbox-symbolic"

        self.adblock_image = Gtk.Image.new_from_icon_name(
            self.adblock_icon_active if self.settings_manager.is_ad_blocking_enabled() else self.adblock_icon_inactive,
            Gtk.IconSize.BUTTON
        )
        self.adblock_toggle.set_image(self.adblock_image)

        # Set the initial state of the toggle button
        self.adblock_toggle.set_active(self.settings_manager.is_ad_blocking_enabled())
        self.adblock_toggle.connect("toggled", self.on_adblock_toggle)

        header_bar.pack_end(self.adblock_toggle)

    def on_adblock_toggle(self, button):
        """Handle the toggle action for ad-blocking."""
        is_enabled = button.get_active()
        self.settings_manager.set_ad_blocking_enabled(is_enabled)

        # Update the icon based on the new state
        new_icon = "checkbox-checked-symbolic" if is_enabled else "checkbox-symbolic"
        self.adblock_image.set_from_icon_name(new_icon, Gtk.IconSize.BUTTON)

        # Apply content blocking rules accordingly
        if is_enabled:
            self.apply_content_blocking_rules(self.settings_manager.get_adblock_rules())
        else:
            self.apply_content_blocking_rules([])


    def setup_content_blocking(self):
        """Setup content blocking rules."""
        if not self.settings_manager.is_ad_blocking_enabled():
            logger.info("Ad blocking is disabled in settings.")
            return

        easylist_path = os.path.join(os.path.expanduser('~'), '.simple_browser', 'easylist.txt')
        if not os.path.exists(easylist_path) or (datetime.datetime.now().timestamp() - os.path.getmtime(easylist_path)) > 86400:
            self.download_easylist(easylist_path)

        rules = self.parse_easylist(easylist_path)
        self.apply_content_blocking_rules(rules)

    def remove_content_blocking(self):
        """Remove all content blocking rules."""
        logger.info("Removing content blocking.")
        try:
            self.web_context.remove_all_user_content_filters()
            logger.info("All content blockers removed.")
        except Exception as e:
            logger.error(f"Failed to remove content blockers: {e}")

    def apply_content_blocking_rules(self, rules):
        """Apply content blocking rules to the WebKit2 context."""
        try:
            if hasattr(self.web_context, 'set_content_blockers'):
                content_blocker_rules = json.dumps(rules)
                self.web_context.set_content_blockers(content_blocker_rules)
                logger.info("Content blocking rules applied.")
            else:
                logger.warning("WebContext does not support direct content blockers in this environment.")
        except Exception as e:
            logger.error(f"Error applying content blockers: {e}")


    def reload_all_tabs_with_cache_bypass(self):
        """Reload all tabs to ensure content blocker status is fresh."""
        logger.info("Reloading all tabs with cache bypass to apply content blocking changes.")
        for i in range(self.notebook.get_n_pages()):
            page = self.notebook.get_nth_page(i)
            if isinstance(page, BrowserTab):
                page.webview.reload()

    def update_adblock_icon(self):
        """Update the adblock toggle button icon based on its state."""
        if self.settings_manager.is_ad_blocking_enabled():
            self.adblock_image.set_from_icon_name("face-surprise-symbolic", Gtk.IconSize.BUTTON)
        else:
            self.adblock_image.set_from_icon_name("face-angel-symbolic", Gtk.IconSize.BUTTON)



    def load_easylist(self):
        """Load and parse EasyList rules."""
        easylist_path = os.path.expanduser("~/.simple_browser/easylist.txt")
        if not os.path.exists(easylist_path):
            logger.warning("EasyList file not found.")
            return []

        try:
            with open(easylist_path, "r", encoding="utf-8") as f:
                rules = f.readlines()

            # Filter out comments and unsupported rules
            parsed_rules = []
            for rule in rules:
                rule = rule.strip()
                if rule and not rule.startswith(("!", "[", "@@", "#")):
                    # Convert wildcards to regular expressions
                    rule = re.escape(rule).replace("\\*", ".*").replace("\\^", "[^/]*")
                    parsed_rules.append(rule)

            logger.info(f"Loaded {len(parsed_rules)} EasyList rules.")
            return parsed_rules

        except Exception as e:
            logger.error(f"Error loading EasyList: {e}")
            return []

    def inject_easylist_rules(self, webview):
        """Inject JavaScript to apply EasyList ad-blocking rules."""
        easylist_script = """
        // Example script to block ads using basic EasyList rules
        var adSelectors = [
            'iframe[src*="ads"]',
            'div[id*="ad"]',
            'div[class*="ad"]',
            'a[href*="doubleclick.net"]'
        ];
        adSelectors.forEach(selector => {
            document.querySelectorAll(selector).forEach(el => el.remove());
        });
        """
        webview.run_javascript(easylist_script, None, None, None)





    def parse_easylist(self, easylist_path):
        """Parse EasyList and convert it to WebKit content blocking rules."""
        rules = []
        try:
            with open(easylist_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith('!') or not line or line.startswith('[Segment]'):
                        continue
                    match = re.match(r'^\|\|([^\^*]+)\^', line)
                    if match:
                        domain = match.group(1)
                        rule = {
                            "trigger": {
                                "url-filter": f".*://{re.escape(domain)}.*"
                            },
                            "action": {
                                "type": "block"
                            }
                        }
                        rules.append(rule)
        except Exception as e:
            logger.error(f"Error parsing EasyList: {e}")
        return rules

    # ------------------------------
    # Whitelist Management
    # ------------------------------
    def add_whitelist_manager_button(self, header_bar):
        """Add a button to manage the whitelist."""
        whitelist_button = Gtk.Button.new_from_icon_name("emblem-symbolic", Gtk.IconSize.BUTTON)
        whitelist_button.set_tooltip_text("Manage Whitelist")
        whitelist_button.set_relief(Gtk.ReliefStyle.NONE)
        whitelist_button.set_focus_on_click(False)
        whitelist_button.connect("clicked", self.on_manage_whitelist)
        header_bar.pack_end(whitelist_button)

    def on_manage_whitelist(self, widget):
        """Open the whitelist manager dialog."""
        dialog = Gtk.Dialog(
            title="Whitelist Manager",
            transient_for=self,
            modal=True,
            destroy_with_parent=True
        )
        dialog.set_default_size(400, 300)
        dialog.add_buttons(
            Gtk.STOCK_CLOSE, Gtk.ResponseType.CLOSE
        )

        content_area = dialog.get_content_area()

        self.whitelist_liststore = Gtk.ListStore(str)
        for domain in self.settings_manager.get_whitelist():
            self.whitelist_liststore.append([domain])

        treeview = Gtk.TreeView(model=self.whitelist_liststore)

        renderer_text = Gtk.CellRendererText()
        column_text = Gtk.TreeViewColumn("Whitelisted Domains", renderer_text, text=0)
        treeview.append_column(column_text)

        renderer_toggle = Gtk.CellRendererToggle()
        renderer_toggle.connect("toggled", self.on_whitelist_toggle, self.whitelist_liststore)
        column_toggle = Gtk.TreeViewColumn("Remove", renderer_toggle, active=0)
        treeview.append_column(column_toggle)

        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        scrolled_window.add(treeview)
        content_area.pack_start(scrolled_window, True, True, 10)

        add_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        add_entry = Gtk.Entry()
        add_entry.set_placeholder_text("Enter domain to whitelist (e.g., example.com)")
        add_box.pack_start(add_entry, True, True, 0)

        add_button = Gtk.Button(label="Add")
        add_button.connect("clicked", self.on_add_whitelist_domain, add_entry, dialog)
        add_box.pack_start(add_button, False, False, 0)

        content_area.pack_start(add_box, False, False, 10)

        dialog.show_all()
        dialog.run()
        dialog.destroy()

    def on_whitelist_toggle(self, widget, path, liststore):
        """Handle the removal of a domain from the whitelist."""
        domain = self.whitelist_liststore[path][0]
        self.settings_manager.remove_from_whitelist(domain)
        self.whitelist_liststore.remove(self.whitelist_liststore.get_iter(path))
        self.setup_content_blocking()

    def on_add_whitelist_domain(self, button, add_entry, dialog):
        """Add a new domain to the whitelist."""
        domain = add_entry.get_text().strip()
        if domain:
            parsed = urlparse(f"http://{domain}")
            clean_domain = parsed.netloc
            if clean_domain and clean_domain not in self.settings_manager.get_whitelist():
                self.settings_manager.add_to_whitelist(clean_domain)
                self.whitelist_liststore.append([clean_domain])
                add_entry.set_text("")
                logger.info(f"Added {clean_domain} to whitelist.")
                self.setup_content_blocking()
            else:
                self.show_error_dialog("Invalid or duplicate domain.")
        else:
            self.show_error_dialog("Please enter a domain.")

    def show_error_dialog(self, message):
        """Display an error dialog with the given message."""
        error_dialog = Gtk.MessageDialog(
            transient_for=self,
            modal=True,
            destroy_with_parent=True,
            message_type=Gtk.MessageType.ERROR,
            buttons=Gtk.ButtonsType.OK,
            text="Error",
        )
        error_dialog.format_secondary_text(message)
        error_dialog.run()
        error_dialog.destroy()

    # ------------------------------
    # Adblock Toggle and CSS
    # ------------------------------
    # (Already implemented in add_adblock_toggle and related functions)

    # ------------------------------
    # About Us Dialog
    # ------------------------------
    def on_about_us(self, widget):
        """Display the About Us dialog with updated keyboard shortcuts."""
        about_dialog = Gtk.MessageDialog(
            parent=self,
            modal=True,
            destroy_with_parent=True,
            flags=0,
            message_type=Gtk.MessageType.INFO,
            buttons=Gtk.ButtonsType.CLOSE,
            text="About Us"
        )
        about_dialog.set_markup("<b>Simple Browser - Revision 10.3</b>")

        description = (
            "\n<b>Keyboard Shortcuts:</b>\n"
            "- <b>Ctrl + T</b>: New Tab\n"
            #"- <b>Ctrl + N</b>: New Blank Tab\n"
            "- <b>Ctrl + W</b>: Close Tab\n"
            "- <b>Ctrl + R</b>: Reload Page\n"
            "- <b>Ctrl + O</b>: Open URL Launcher\n"
            "- <b>Ctrl + D</b>: Open Download Manager\n"
            "- <b>Ctrl + B</b>: Add Bookmark\n"
            "- <b>Alt + B</b>: View Bookmarks\n"
            #"- <b>Ctrl + Home</b>: Go to Home Page\n"
            "- <b>Alt + 1</b>: Save Session 1\n"
            "- <b>Alt + 2</b>: Save Session 2\n"
            "- <b>Shift + Alt + Right</b>: Load Session 1\n"
            "- <b>Shift + Alt + Left</b>: Load Session 2\n"
            "- <b>Ctrl + Down</b>: Move Tabs to Bottom\n"
            "- <b>Ctrl + Up</b>: Move Tabs to Top\n"
            "- <b>Shift + Tab</b>: Switch to Previous Tab\n"
            "- <b>Ctrl + Left</b>: Go Back\n"
            "- <b>Ctrl + Right</b>: Go Forward\n"
            "- <b>Ctrl + K</b>: About Us\n"
            "- <b>Ctrl + Q</b>: Quit Browser\n"
            "- <b>Ctrl + Alt + S</b>: Take Screenshot\n\n"
            "<b>Credits:</b>\n"
            "Created by Seeker\n"
            "Special thanks to Johnathan, Jacob, and especially Fish"
        )

        about_dialog.format_secondary_markup(description)
        about_dialog.run()
        about_dialog.destroy()



    # ------------------------------
    # Download Manager Functions
    # ------------------------------
    def open_download_manager(self, widget):
        """Open the download manager window."""
        self.download_manager.download_manager_window.show_all()

    def update_download_progress_ui(self, download):
        """Update the UI with the latest download progress."""
        if 'progress_bar' in download:
            download['progress_bar'].set_fraction(download['progress'] / 100.0)
            download['progress_bar'].set_text(f"{download['progress']}%")

        if 'label_widget' in download:
            download['label_widget'].set_text(download['status'])

        # Update the time label if the download is still in progress or completed
        if 'time_label' in download:
            if download['status'] == 'Downloading':
                # Calculate elapsed time
                start_time = datetime.datetime.fromisoformat(download['start_time'])
                elapsed_time = datetime.datetime.now() - start_time
                download['time_label'].set_text(f"Elapsed: {str(elapsed_time).split('.')[0]}")
            elif download['status'] == 'Completed':
                # Show completion time
                end_time = datetime.datetime.fromisoformat(download['end_time'])
                download['time_label'].set_text(f"Completed at: {end_time.strftime('%Y-%m-%d %H:%M:%S')}")
            elif download['status'] == 'Failed':
                download['time_label'].set_text("Download Failed")

        return False


    def mark_download_complete(self, download):
        """Update the UI to reflect that a download is complete."""
        if 'progress_bar' in download and download['progress_bar']:
            download['progress_bar'].set_fraction(1.0)
            download['progress_bar'].set_text("Completed")
            if 'label_widget' in download and download['label_widget']:
                download['label_widget'].set_text("Completed")
        return False

    def mark_download_failed(self, download):
        """Update the UI to reflect that a download has failed."""
        if 'progress_bar' in download and download['progress_bar']:
            download['progress_bar'].set_text("Failed")
            if 'label_widget' in download and download['label_widget']:
                download['label_widget'].set_text("Failed")
        return False

    def complete_download(self, filepath, end_time, duration):
        """Handle download completion and update UI."""
        for download in self.download_manager.downloads:
            if download['filepath'] == filepath:
                download['progress'] = 100
                download['status'] = 'Completed'
                download['end_time'] = end_time
                download['duration'] = duration
                self.mark_download_complete(download)
                self.download_manager.save_download_history()

                # Send a notification when the download is complete
                notification = notify2.Notification(
                    "Download Complete",
                    f"File saved to: {filepath}",
                    "dialog-information"
                )
                notification.show()
                break
        return False

    def fail_download(self, filepath):
        """Handle download failure and update UI."""
        for download in self.download_manager.downloads:
            if download['filepath'] == filepath:
                download['status'] = 'Failed'
                self.mark_download_failed(download)
                break
        return False

    # ------------------------------
    # Printing Functions
    # ------------------------------
    def on_print_page(self, widget):
        """Initiate print dialog for the current page."""
        current_page = self.get_current_page()
        if current_page:
            print_dialog = Gtk.PrintOperation.new()
            print_dialog.set_default_page_setup(Gtk.PrintSettings())
            print_dialog.set_n_pages(1)

            print_dialog.connect("begin-print", self.begin_print)
            print_dialog.connect("draw-page", self.draw_page)

            res = print_dialog.run(Gtk.PrintOperationAction.PRINT_DIALOG, self)
            if res == Gtk.PrintOperationResult.ERROR:
                logger.error("An error occurred while printing.")
        else:
            logger.warning("Print button clicked but no tab is open.")

    def begin_print(self, operation, context):
        """Prepare for printing."""
        pass  # Additional setup can be done here

    def draw_page(self, operation, context, page_nr):
        """Render the current page for printing."""
        # Note: Implement actual print rendering as needed
        pass

    # ------------------------------
    # Screenshot Functions
    # ------------------------------
    def on_take_screenshot(self, widget):
        """Capture a screenshot of the current page and copy it to clipboard."""
        current_page = self.get_current_page()
        if current_page is None:
            logger.warning("No active page to capture.")
            return

        webview = current_page.webview
        allocation = webview.get_allocation()
        width = allocation.width
        height = allocation.height

        webview.get_snapshot(WebKit2.SnapshotRegion.FULL_DOCUMENT, WebKit2.SnapshotOptions.NONE, None, self.on_snapshot_ready, (width, height))

    def on_snapshot_ready(self, webview, result, data):
        """Handle the snapshot after it's ready."""
        try:
            surface = webview.get_snapshot_finish(result)
            width, height = data
            pixbuf = Gdk.pixbuf_get_from_surface(surface, 0, 0, width, height)
            clipboard = Gtk.Clipboard.get(Gdk.SELECTION_CLIPBOARD)
            clipboard.set_image(pixbuf)
            logger.info("Screenshot taken of visible content and copied to clipboard.")
        except Exception as e:
            logger.error(f"Failed to capture screenshot: {e}")

    # ------------------------------
    # Bookmark Opening Functions
    # ------------------------------
    def open_bookmark_in_current_tab(self, bookmark_url):
        """Open a bookmark URL in the current tab."""
        current_page = self.get_current_page()
        if isinstance(current_page, BrowserTab):
            current_page.webview.load_uri(bookmark_url)
            self.update_address_bar(bookmark_url)
            logger.info(f"Bookmark loaded in current tab: {bookmark_url}")
        else:
            logger.warning("No active tab found to load the bookmark.")

    def on_bookmark_activated(self, button, bookmark_url):
        """Callback for when a bookmark is clicked."""
        self.open_bookmark_in_current_tab(bookmark_url)

    # ------------------------------
    # Tab Management Functions
    # ------------------------------
    def on_new_tab(self, widget=None):
        """Open a new tab."""
        new_tab = BrowserTab(self, ad_block_rules=self.settings_manager.get_whitelist())
        self.notebook.set_current_page(self.notebook.page_num(new_tab))
        logger.info("New tab opened.")

    def on_close_tab(self, widget=None, tab=None):
        """Close the specified tab."""
        if tab is None:
            current_page_num = self.notebook.get_current_page()
            tab = self.notebook.get_nth_page(current_page_num)

        total_pages = self.notebook.get_n_pages()

        if total_pages <= 1:
            self.destroy()
            logger.info("Last tab closed. Application window destroyed.")
        else:
            if isinstance(tab, BrowserTab):
                self.notebook.remove(tab)
                tab.webview.destroy()
                tab.destroy()
                logger.info("Tab closed.")
            else:
                logger.error("Attempted to close a non-BrowserTab instance.")

    def switch_to_previous_tab(self):
        current_page_num = self.notebook.get_current_page()
        total_pages = self.notebook.get_n_pages()
        if total_pages > 1:
            previous_page_num = (current_page_num - 1) % total_pages
            self.notebook.set_current_page(previous_page_num)
            logger.info(f"Switched to previous tab: {previous_page_num}")

    def on_switch_page(self, notebook, page, page_num):
        """Handle tab switching to update the address bar."""
        current_page = self.notebook.get_nth_page(page_num)
        if isinstance(current_page, BrowserTab):
            uri = current_page.webview.get_uri()
            if uri is not None:
                self.update_address_bar(uri)
                logger.info(f"Switched to tab with URI: {uri}")




    def on_key_press_global(self, widget, event):
        keyval = event.keyval
        state = event.state

        # New Tab (Ctrl + T)
        if keyval == Gdk.KEY_t and (state & Gdk.ModifierType.CONTROL_MASK):
            self.on_new_tab()
            return True

        # New Blank Tab (Ctrl + N)
        elif keyval == Gdk.KEY_n and (state & Gdk.ModifierType.CONTROL_MASK):
            self.on_new_blank_tab()
            return True

        # Close Tab (Ctrl + W)
        elif keyval == Gdk.KEY_w and (state & Gdk.ModifierType.CONTROL_MASK):
            self.on_close_tab()
            return True

        # Reload Page (Ctrl + R)
        elif keyval == Gdk.KEY_r and (state & Gdk.ModifierType.CONTROL_MASK):
            self.on_reload_clicked(None)
            return True

        # Open URL Launcher (Ctrl + O)
        elif keyval == Gdk.KEY_o and (state & Gdk.ModifierType.CONTROL_MASK):
            self.show_combined_launcher()
            return True

        # Open Download Manager (Ctrl + D)
        elif keyval == Gdk.KEY_d and (state & Gdk.ModifierType.CONTROL_MASK):
            self.download_manager.open_download_manager()
            return True

        # Add Bookmark (Ctrl + B)
        elif keyval == Gdk.KEY_b and (state & Gdk.ModifierType.CONTROL_MASK):
            self.on_add_bookmark(None)
            return True

        # Open Bookmarks Manager (Alt + B)
        elif keyval == Gdk.KEY_b and (state & Gdk.ModifierType.MOD1_MASK):
            self.on_view_bookmarks(None)
            return True



        # About Us (Ctrl + K)
        elif keyval == Gdk.KEY_k and (state & Gdk.ModifierType.CONTROL_MASK):
            self.on_about_us(None)
            return True

        # Quit Browser (Ctrl + Q)
        elif keyval == Gdk.KEY_q and (state & Gdk.ModifierType.CONTROL_MASK):
            self.quit_browser()
            return True

        # Take Screenshot (Ctrl + Alt + S)
        elif keyval == Gdk.KEY_s and (state & Gdk.ModifierType.CONTROL_MASK) and (state & Gdk.ModifierType.MOD1_MASK):
            self.on_take_screenshot(None)
            return True

        # Move Tabs to Bottom (Ctrl + Down Arrow)
        elif keyval == Gdk.KEY_Down and (state & Gdk.ModifierType.CONTROL_MASK):
            self.notebook.set_tab_pos(Gtk.PositionType.BOTTOM)
            self.switch_tabs_icon.set_from_icon_name("go-down-symbolic", Gtk.IconSize.BUTTON)
            logger.info("Tabs moved to bottom.")
            return True

        # Move Tabs to Top (Ctrl + Up Arrow)
        elif keyval == Gdk.KEY_Up and (state & Gdk.ModifierType.CONTROL_MASK):
            self.notebook.set_tab_pos(Gtk.PositionType.TOP)
            self.switch_tabs_icon.set_from_icon_name("go-up-symbolic", Gtk.IconSize.BUTTON)
            logger.info("Tabs moved to top.")
            return True

        # Go Back (Ctrl + Left Arrow)
        elif keyval == Gdk.KEY_Left and (state & Gdk.ModifierType.CONTROL_MASK):
            self.on_back_clicked(None)
            return True

        # Go Forward (Ctrl + Right Arrow)
        elif keyval == Gdk.KEY_Right and (state & Gdk.ModifierType.CONTROL_MASK):
            self.on_forward_clicked(None)
            return True

        # Save Session 1 (Alt + 1)
        elif keyval == Gdk.KEY_1 and (state & Gdk.ModifierType.MOD1_MASK):
            self.save_session("session1")
            logger.info("Session 1 saved.")
            return True

        # Save Session 2 (Alt + 2)
        elif keyval == Gdk.KEY_2 and (state & Gdk.ModifierType.MOD1_MASK):
            self.save_session("session2")
            logger.info("Session 2 saved.")
            return True

        # Load Session 1 (Shift + Alt + Right Arrow)
        elif keyval == Gdk.KEY_Right and (state & Gdk.ModifierType.SHIFT_MASK) and (state & Gdk.ModifierType.MOD1_MASK):
            self.load_session("session1")
            logger.info("Session 1 loaded.")
            return True

        # Load Session 2 (Shift + Alt + Left Arrow)
        elif keyval == Gdk.KEY_Left and (state & Gdk.ModifierType.SHIFT_MASK) and (state & Gdk.ModifierType.MOD1_MASK):
            self.load_session("session2")
            logger.info("Session 2 loaded.")
            return True

        # Switch to Previous Tab (Shift + Tab)
        elif (keyval == Gdk.KEY_ISO_Left_Tab or keyval == Gdk.KEY_Tab) and (state & Gdk.ModifierType.SHIFT_MASK):
            self.switch_to_previous_tab()
            return True

        return False










    def on_reload_clicked(self, widget):
        """Reload the current tab."""
        current_page = self.get_current_page()
        if current_page:
            current_page.webview.reload()
            logger.info("Reload button clicked.")
        else:
            logger.warning("Reload button clicked but no tab is open.")

    def on_back_clicked(self, widget):
        """Navigate back in the current tab."""
        current_page = self.get_current_page()
        if current_page and current_page.webview.can_go_back():
            current_page.webview.go_back()
            logger.info("Back button clicked.")
        else:
            logger.warning("Back button clicked but cannot navigate back.")

    def on_forward_clicked(self, widget):
        """Navigate forward in the current tab."""
        current_page = self.get_current_page()
        if current_page and current_page.webview.can_go_forward():
            current_page.webview.go_forward()
            logger.info("Forward button clicked.")
        else:
            logger.warning("Forward button clicked but cannot navigate forward.")

    def on_home_clicked(self, widget):
        """Navigate to the homepage in the current tab."""
        current_page = self.get_current_page()
        if current_page:
            current_page.webview.load_uri(self.homepage)
            logger.info(f"Navigated to home page: {self.homepage}")
        else:
            logger.warning("Home button clicked but no tab is open.")

    def on_key_press(self, widget, event):
        """Handle key press events in the address bar."""
        if event.state & Gdk.ModifierType.CONTROL_MASK and event.keyval == Gdk.KEY_Return:
            self.handle_ctrl_enter()
            return True
        return False

    def handle_ctrl_enter(self):
        """Handle Ctrl+Enter key combination to navigate."""
        domain = self.address_bar.get_text().strip()
        domain = self.ensure_tld(domain)
        url = self.format_url(domain)
        GLib.idle_add(self.navigate_to, url)
        logger.info(f"Control+Enter pressed. Navigating to: {url}")

    def navigate_to(self, url):
        """Navigate to the specified URL in the current tab."""
        logger.info(f"Navigating to URL: {url}")
        current_page = self.get_current_page()
        if current_page:
            current_page.webview.load_uri(url)



    def is_probable_url(self, text):
        """Check if the entered text is a probable URL."""
        return bool(self.PROBABLE_URL_REGEX.match(text))

    def format_url(self, url):
        """Ensure the URL has a scheme."""
        parsed = urlparse(url)
        if not parsed.scheme:
            return f"https://{url}"
        return url

    def ensure_tld(self, domain):
        """Ensure the domain has a top-level domain."""
        if not domain.startswith("www."):
            domain = "www." + domain
        if not any(domain.endswith(tld) for tld in self.TLD_SET):
            domain += ".com"
        return domain

    def toggle_tab_position(self, widget):
        """Toggle the position of the tabs between top and bottom."""
        current_pos = self.notebook.get_tab_pos()
        new_pos = Gtk.PositionType.TOP if current_pos == Gtk.PositionType.BOTTOM else Gtk.PositionType.BOTTOM
        self.notebook.set_tab_pos(new_pos)

        if new_pos == Gtk.PositionType.TOP:
            self.switch_tabs_icon.set_from_icon_name("go-down-symbolic", Gtk.IconSize.BUTTON)
        else:
            self.switch_tabs_icon.set_from_icon_name("go-up-symbolic", Gtk.IconSize.BUTTON)

        logger.info(f"Toggled tabs position to: {'TOP' if new_pos == Gtk.PositionType.TOP else 'BOTTOM'}")

    # ------------------------------
    # Save and Load Tabs
    # ------------------------------
    def on_save_tabs(self, widget):
        """Save all open tabs to a file."""
        try:
            self.save_open_tabs()
            dialog = Gtk.MessageDialog(
                parent=self,
                modal=True,
                destroy_with_parent=True,
                message_type=Gtk.MessageType.INFO,
                buttons=Gtk.ButtonsType.OK,
                text="Tabs Saved",
            )
            dialog.format_secondary_text("Your open tabs have been saved successfully.")
            dialog.run()
            dialog.destroy()
            logger.info("User manually saved open tabs.")
        except Exception as e:
            logger.error(f"Failed to save open tabs: {e}")
            error_dialog = Gtk.MessageDialog(
                parent=self,
                modal=True,
                destroy_with_parent=True,
                message_type=Gtk.MessageType.ERROR,
                buttons=Gtk.ButtonsType.OK,
                text="Error Saving Tabs",
            )
            error_dialog.format_secondary_text(f"An error occurred while saving your tabs: {e}")
            error_dialog.run()
            error_dialog.destroy()

    def save_open_tabs(self):
        """Save all open tab URLs to a JSON file."""
        tabs = []
        for i in range(self.notebook.get_n_pages()):
            page = self.notebook.get_nth_page(i)
            if isinstance(page, BrowserTab):
                uri = page.webview.get_uri()
                if uri:
                    tabs.append(uri)

        saved_tabs_dir = os.path.join(os.path.expanduser("~"), ".simple_browser")
        os.makedirs(saved_tabs_dir, exist_ok=True)
        file_path = os.path.join(saved_tabs_dir, "open_tabs.json")
        logger.debug(f"Saving open tabs to: {file_path}")
        try:
            with open(file_path, 'w') as f:
                json.dump(tabs, f, indent=4)
            logger.info(f"Open tabs saved successfully: {tabs}")
        except Exception as e:
            logger.error(f"Failed to save open tabs: {e}")

    def load_open_tabs(self):
        """Load saved tabs from a JSON file."""
        saved_tabs_dir = os.path.join(os.path.expanduser("~"), ".simple_browser")
        file_path = os.path.join(saved_tabs_dir, "open_tabs.json")
        tabs_loaded = 0
        if os.path.exists(file_path):
            try:
                with open(file_path, 'r') as f:
                    urls = json.load(f)
                    if urls:
                        for url in urls:
                            self.on_new_tab_with_url(url)
                            tabs_loaded += 1
                        logger.info(f"Loaded saved tabs: {urls}")
                    else:
                        logger.info("Saved tabs file is empty.")
            except json.JSONDecodeError:
                logger.error(f"Saved tabs file {file_path} contains invalid JSON.")
            except Exception as e:
                logger.error(f"Failed to load open tabs: {e}")
        else:
            logger.info(f"No saved tabs file found at: {file_path}")
        return tabs_loaded

    def delete_saved_tabs(self):
        """Delete the saved tabs file."""
        saved_tabs_dir = os.path.join(os.path.expanduser("~"), ".simple_browser")
        file_path = os.path.join(saved_tabs_dir, "open_tabs.json")
        logger.debug(f"Attempting to delete saved tabs file: {file_path}")
        try:
            if os.path.exists(file_path):
                os.remove(file_path)
                logger.info(f"Successfully deleted saved tabs file: {file_path}")
                return True
            else:
                logger.info(f"No saved tabs file found at: {file_path}")
                return False
        except Exception as e:
            logger.error(f"Error deleting saved tabs file at {file_path}: {e}")
            return False

    def on_clear_saved_tabs(self, widget):
        """Clear all saved tabs and reload the homepage."""
        success = self.delete_saved_tabs()
        if success:
            while self.notebook.get_n_pages() > 0:
                page = self.notebook.get_nth_page(0)
                if isinstance(page, BrowserTab):
                    self.notebook.remove(page)
                    page.webview.destroy()
                    page.destroy()
            self.on_new_tab_with_url(self.homepage)
            info_dialog = Gtk.MessageDialog(
                parent=self,
                modal=True,
                destroy_with_parent=True,
                message_type=Gtk.MessageType.INFO,
                buttons=Gtk.ButtonsType.OK,
                text="Saved Tabs Deleted",
            )
            info_dialog.format_secondary_text("Your saved tabs have been deleted. The default homepage has been loaded.")
            info_dialog.run()
            info_dialog.destroy()
            logger.info("User cleared saved tabs and default homepage loaded.")
        else:
            info_dialog = Gtk.MessageDialog(
                parent=self,
                modal=True,
                destroy_with_parent=True,
                message_type=Gtk.MessageType.WARNING,
                buttons=Gtk.ButtonsType.OK,
                text="No Saved Tabs",
            )
            info_dialog.format_secondary_text("There are no saved tabs to delete.")
            info_dialog.run()
            info_dialog.destroy()
            logger.info("User attempted to clear saved tabs, but none existed.")

    # ------------------------------
    # Quit Functionality
    # ------------------------------
    def quit_browser(self):
        """Quit the browser application."""
        logger.info("Application closed via shortcut.")
        self.autofill_manager.save_autofill_data()
        Gtk.main_quit()
        sys.exit(0)

    # ------------------------------
    # Address Bar Update
    # ------------------------------
    def update_address_bar(self, uri):
        """Update the address bar with the current URI."""
        if uri is not None and self.address_bar.get_text() != uri:
            self.address_bar.set_text(uri)
            logger.info(f"Address bar updated to: {uri}")

    # ------------------------------
    # URL Launcher
    # ------------------------------
    def show_url_launcher(self):
        dialog = Gtk.Dialog(
            title="Open URL",
            transient_for=self,
            modal=True,
            destroy_with_parent=True
        )
        dialog.set_default_size(400, 100)
        dialog.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_OK, Gtk.ResponseType.OK
        )

        content_area = dialog.get_content_area()

        label = Gtk.Label(label="Enter URL or search query:")
        content_area.pack_start(label, False, False, 10)

        entry = Gtk.Entry()
        entry.set_placeholder_text("Enter URL or search query")
        entry.connect("activate", self.on_launcher_enter, dialog)
        entry.connect("key-press-event", self.on_launcher_key_press, dialog)
        content_area.pack_start(entry, True, True, 0)

        entry.grab_focus()
        dialog.set_default_response(Gtk.ResponseType.OK)
        dialog.show_all()

        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            text = entry.get_text().strip()
            if text:
                if self.is_probable_url(text):
                    url = self.format_url(text)
                else:
                    query = quote_plus(text)
                    url = f"https://www.duckduckgo.com/?q={query}"
                self.on_new_tab()
                current_page = self.get_current_page()
                if current_page:
                    current_page.webview.load_uri(url)
                    logger.info(f"Navigated to DuckDuckGo search for: {text}")
        dialog.destroy()

    def on_launcher_key_press(self, widget, event, dialog):
        if event.state & Gdk.ModifierType.CONTROL_MASK and event.keyval == Gdk.KEY_Return:
            url = self.ensure_tld(widget.get_text().strip())
            self.launch_url(url)
            dialog.response(Gtk.ResponseType.CANCEL)
            return True
        return False

    def on_launcher_enter(self, entry, dialog):
        text = entry.get_text().strip()
        if text:
            if self.is_probable_url(text):
                url = self.format_url(text)
            else:
                query = quote_plus(text)
                url = f"https://www.duckduckgo.com/?q={query}"
            self.on_new_tab()
            current_page = self.get_current_page()
            if current_page:
                current_page.webview.load_uri(url)
                logger.info(f"Navigated to URL: {url}")
        dialog.response(Gtk.ResponseType.CANCEL)


    def ensure_tld(self, domain):
        if not domain.startswith("www."):
            domain = "www." + domain
        if not any(domain.endswith(tld) for tld in self.TLD_SET):
            domain += ".com"
        return domain

    def launch_url(self, url):
        url = self.format_url(url)
        self.on_new_tab()
        current_page = self.get_current_page()
        if current_page:
            current_page.webview.load_uri(url)
            logger.info(f"Navigated to URL: {url}")

    # ------------------------------
    # Bookmark Manager Setup
    # ------------------------------
    def setup_bookmark_manager(self):
        """Setup bookmark manager UI elements."""
        for bookmark in self.bookmarks:
            bookmark_button = Gtk.Button(label=bookmark['name'])
            bookmark_button.connect("clicked", self.on_bookmark_activated, bookmark['uri'])
            # Add to your UI as needed

    # ------------------------------
    # Handle Tab Switch
    # ------------------------------


    # ------------------------------
    # Add Navigation Buttons
    # ------------------------------
    def add_navigation_buttons(self, header_bar):
        """Add back, forward, reload, and home buttons to the header bar."""
        back_button = Gtk.Button.new_from_icon_name("go-previous", Gtk.IconSize.BUTTON)
        back_button.set_tooltip_text("Back")
        back_button.connect("clicked", self.on_back_clicked)
        header_bar.pack_start(back_button)

        forward_button = Gtk.Button.new_from_icon_name("go-next", Gtk.IconSize.BUTTON)
        forward_button.set_tooltip_text("Forward")
        forward_button.connect("clicked", self.on_forward_clicked)
        header_bar.pack_start(forward_button)

        reload_button = Gtk.Button.new_from_icon_name("view-refresh", Gtk.IconSize.BUTTON)
        reload_button.set_tooltip_text("Reload")
        reload_button.connect("clicked", self.on_reload_clicked)
        header_bar.pack_start(reload_button)

        home_button = Gtk.Button.new_from_icon_name("go-home", Gtk.IconSize.BUTTON)
        home_button.set_tooltip_text("Home")
        home_button.connect("clicked", self.on_home_clicked)
        header_bar.pack_start(home_button)

    # ------------------------------
    # Keyboard Shortcuts
    # ------------------------------
    # (Already implemented in on_key_press_global)

    # ------------------------------
    # Download Manager UI Setup
    # ------------------------------
    # (Already implemented in create_download_manager_window and related functions)

    # ------------------------------
    # Fullscreen Handling (Optional)
    # ------------------------------
    def on_window_state_event(self, widget, event):
        if event.changed_mask & Gdk.WindowState.FULLSCREEN:
            if event.new_window_state & Gdk.WindowState.FULLSCREEN:
                self.notebook.set_show_tabs(False)
                logger.info("Entered fullscreen. Tabs hidden.")
            else:
                self.notebook.set_show_tabs(True)
                logger.info("Exited fullscreen. Tabs shown.")

    # ------------------------------
    # Save and Load Open Tabs
    # ------------------------------
    def on_save_tabs(self, widget):
        """Save all open tabs to a file."""
        try:
            self.save_open_tabs()
            dialog = Gtk.MessageDialog(
                parent=self,
                modal=True,
                destroy_with_parent=True,
                message_type=Gtk.MessageType.INFO,
                buttons=Gtk.ButtonsType.OK,
                text="Tabs Saved",
            )
            dialog.format_secondary_text("Your open tabs have been saved successfully.")
            dialog.run()
            dialog.destroy()
            logger.info("User manually saved open tabs.")
        except Exception as e:
            logger.error(f"Failed to save open tabs: {e}")
            error_dialog = Gtk.MessageDialog(
                parent=self,
                modal=True,
                destroy_with_parent=True,
                message_type=Gtk.MessageType.ERROR,
                buttons=Gtk.ButtonsType.OK,
                text="Error Saving Tabs",
            )
            error_dialog.format_secondary_text(f"An error occurred while saving your tabs: {e}")
            error_dialog.run()
            error_dialog.destroy()

    def save_open_tabs(self):
        """Save all open tab URLs to a JSON file."""
        tabs = []
        for i in range(self.notebook.get_n_pages()):
            page = self.notebook.get_nth_page(i)
            if isinstance(page, BrowserTab):
                uri = page.webview.get_uri()
                if uri:
                    tabs.append(uri)

        saved_tabs_dir = os.path.join(os.path.expanduser("~"), ".simple_browser")
        os.makedirs(saved_tabs_dir, exist_ok=True)
        file_path = os.path.join(saved_tabs_dir, "open_tabs.json")
        logger.debug(f"Saving open tabs to: {file_path}")
        try:
            with open(file_path, 'w') as f:
                json.dump(tabs, f, indent=4)
            logger.info(f"Open tabs saved successfully: {tabs}")
        except Exception as e:
            logger.error(f"Failed to save open tabs: {e}")

    def load_open_tabs(self):
        """Load saved tabs from a JSON file."""
        saved_tabs_dir = os.path.join(os.path.expanduser("~"), ".simple_browser")
        file_path = os.path.join(saved_tabs_dir, "open_tabs.json")
        tabs_loaded = 0
        if os.path.exists(file_path):
            try:
                with open(file_path, 'r') as f:
                    urls = json.load(f)
                    if urls:
                        for url in urls:
                            self.on_new_tab_with_url(url)
                            tabs_loaded += 1
                        logger.info(f"Loaded saved tabs: {urls}")
                    else:
                        logger.info("Saved tabs file is empty.")
            except json.JSONDecodeError:
                logger.error(f"Saved tabs file {file_path} contains invalid JSON.")
            except Exception as e:
                logger.error(f"Failed to load open tabs: {e}")
        else:
            logger.info(f"No saved tabs file found at: {file_path}")
        return tabs_loaded

    def delete_saved_tabs(self):
        """Delete the saved tabs file."""
        saved_tabs_dir = os.path.join(os.path.expanduser("~"), ".simple_browser")
        file_path = os.path.join(saved_tabs_dir, "open_tabs.json")
        logger.debug(f"Attempting to delete saved tabs file: {file_path}")
        try:
            if os.path.exists(file_path):
                os.remove(file_path)
                logger.info(f"Successfully deleted saved tabs file: {file_path}")
                return True
            else:
                logger.info(f"No saved tabs file found at: {file_path}")
                return False
        except Exception as e:
            logger.error(f"Error deleting saved tabs file at {file_path}: {e}")
            return False

    def on_clear_saved_tabs(self, widget):
        """Clear all saved tabs and reload the homepage."""
        success = self.delete_saved_tabs()
        if success:
            while self.notebook.get_n_pages() > 0:
                page = self.notebook.get_nth_page(0)
                if isinstance(page, BrowserTab):
                    self.notebook.remove(page)
                    page.webview.destroy()
                    page.destroy()
            self.on_new_tab_with_url(self.homepage)
            info_dialog = Gtk.MessageDialog(
                parent=self,
                modal=True,
                destroy_with_parent=True,
                message_type=Gtk.MessageType.INFO,
                buttons=Gtk.ButtonsType.OK,
                text="Saved Tabs Deleted",
            )
            info_dialog.format_secondary_text("Your saved tabs have been deleted. The default homepage has been loaded.")
            info_dialog.run()
            info_dialog.destroy()
            logger.info("User cleared saved tabs and default homepage loaded.")
        else:
            info_dialog = Gtk.MessageDialog(
                parent=self,
                modal=True,
                destroy_with_parent=True,
                message_type=Gtk.MessageType.WARNING,
                buttons=Gtk.ButtonsType.OK,
                text="No Saved Tabs",
            )
            info_dialog.format_secondary_text("There are no saved tabs to delete.")
            info_dialog.run()
            info_dialog.destroy()
            logger.info("User attempted to clear saved tabs, but none existed.")

    # ------------------------------
    # Quit Application
    # ------------------------------
    def on_destroy(self, widget):
        """Handle application exit."""
        logger.info("Exiting application.")
        self.autofill_manager.save_autofill_data()
        Gtk.main_quit()
        sys.exit(0)

    # ------------------------------
    # Keyboard Shortcuts
    # ------------------------------
    # (Already implemented in on_key_press_global)

    # ------------------------------
    # Download Manager UI Setup
    # ------------------------------
    # (Already implemented in create_download_manager_window and related functions)



    def show_combined_launcher(self):
        """Launch the CombinedLauncher dialog."""
        launcher = CombinedLauncher(self, self.bookmarks, self.save_bookmarks)
        if launcher.selected_url:
            self.on_new_tab_with_url(launcher.selected_url)



    # ------------------------------
    # Save and Load Open Tabs
    # ------------------------------
    # (Already implemented in on_save_tabs, save_open_tabs, load_open_tabs)

    # ------------------------------
    # Quit Functionality
    # ------------------------------
    # (Already implemented in quit_browser)

    # ------------------------------
    # Address Bar Update
    # ------------------------------
    # (Already implemented in update_address_bar)

    # ------------------------------
    # URL Launcher
    # ------------------------------
    # (Already implemented in show_url_launcher and related functions)

    # ------------------------------
    # Bookmark Manager Setup
    # ------------------------------
    # (Already implemented in add_bookmark_buttons and related functions)

    # ------------------------------
    # Handle Tab Switch
    # ------------------------------
    # (Already implemented in on_switch_page)

    # ------------------------------
    # Add Navigation Buttons
    # ------------------------------
    # (Already implemented in add_navigation_buttons)

    # ------------------------------
    # Toggle Tabs Position
    # ------------------------------
    # (Already implemented in toggle_tab_position)

    # ------------------------------
    # Download Manager UI Setup
    # ------------------------------
    # (Already implemented in create_download_manager_window and related functions)

    # ------------------------------
    # About Us Dialog
    # ------------------------------
    # (Already implemented in on_about_us)

    # ------------------------------
    # Print Page Functionality
    # ------------------------------
    # (Already implemented in on_print_page, begin_print, draw_page)
    def create_main_header(self):
        header_bar = Gtk.HeaderBar(title="Simple Browser")
        header_bar.set_show_close_button(True)

        # Combined Reload/Stop button
        self.reload_stop_button = Gtk.Button.new_from_icon_name("view-refresh", Gtk.IconSize.BUTTON)
        self.reload_stop_button.set_tooltip_text("Reload")
        self.reload_stop_button.connect("clicked", self.on_reload_stop_clicked)

        header_bar.pack_start(self.reload_stop_button)

        self.set_titlebar(header_bar)

    # ------------------------------
    # Screenshot Functionality
    # ------------------------------
    # (Already implemented in on_take_screenshot and on_snapshot_ready)


    def load_disable_js_sites(self):
        """Load the list of sites to disable JavaScript from a configuration file."""
        config_file = os.path.join(self.settings_dir, 'disable_js_sites.json')
        try:
            if os.path.exists(config_file):
                with open(config_file, 'r') as file:
                    sites = json.load(file)
                    logger.info(f"Loaded {len(sites)} sites from {config_file}")
                    return sites
        except Exception as e:
            logger.error(f"Error loading disable_js_sites.json: {e}")
        return []

    def disable_javascript_for_site(self, url):
        """Disable JavaScript for specific sites to improve stability."""
        # Default list of sites
        default_disable_js_sites = [
            ".com",
            "msnbc.com",
            "eporner.com",
            "cnn.com",
            "youtube.com",
        ]

        # Combine the default list with the sites loaded from the configuration file
        disable_js_sites = set(default_disable_js_sites + self.load_disable_js_sites())

        try:
            # Get the current page and settings
            current_page = self.get_current_page()
            if not current_page:
                logger.warning("No active page found to modify settings.")
                return

            settings = current_page.webview.get_settings()
            domain = urlparse(url).netloc

            # Check if the domain matches any in the disable_js_sites list
            if any(site in domain for site in disable_js_sites):
                settings.set_property("enable-javascript", False)
                logger.info(f"JavaScript disabled for: {url}")
            else:
                settings.set_property("enable-javascript", True)
                logger.info(f"JavaScript enabled for: {url}")

        except Exception as e:
            logger.error(f"Error modifying JavaScript settings for {url}: {e}")








    # ------------------------------
    # Bookmark Opening Functions
    # ------------------------------
    # (Already implemented in open_bookmark_in_current_tab and related functions)

    # ------------------------------
    # Add Tab with Specific URL
    # ------------------------------
    def on_new_tab_with_url(self, url):
        """Open a new tab with the specified URL and apply stabilization."""
        new_tab = BrowserTab(self, ad_block_rules=self.settings_manager.get_whitelist())
        new_tab.webview.load_uri(url)
        self.notebook.set_current_page(self.notebook.page_num(new_tab))

        # Stabilize the site if it's `msnbc.com`
        self.site_stabilizer.stabilize_site(url)
        logger.info(f"New tab opened with URL: {url}")



    # ------------------------------
    # Main Entry Point
    # ------------------------------
    def get_current_page(self):
        """Return the currently selected tab."""
        page_num = self.notebook.get_current_page()
        return self.notebook.get_nth_page(page_num)


if __name__ == '__main__':
    browser = SimpleBrowser()
    browser.show_all()
    Gtk.main()
