#!/usr/bin/env python3

import gi
import subprocess
import time
import re
import os
import threading
import signal
import math
import atexit
import logging
import sys

gi.require_version('Gtk', '3.0')
gi.require_version('AppIndicator3', '0.1')
gi.require_version('Gst', '1.0')
from gi.repository import Gtk, Gdk, GLib, AppIndicator3, Gst, GdkX11

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class ScreenPreview(Gtk.Window):
    def __init__(self):
        super().__init__(title="Screen Preview")
        self.set_default_size(800, 600)
        # Initialize GStreamer
        Gst.init(None)
        # Create GStreamer pipeline for preview
        self.pipeline = Gst.Pipeline()
        # Create elements
        self.src = self.create_element("ximagesrc", "src")
        self.video_convert = self.create_element("videoconvert", "video_convert")
        self.sink = self.create_element("gtksink", "sink")
        if not all([self.src, self.video_convert, self.sink]):
            print("Not all elements could be created. Exiting.")
            return
        # Add elements to pipeline
        self.pipeline.add(self.src)
        self.pipeline.add(self.video_convert)
        self.pipeline.add(self.sink)
        # Link elements
        self.src.link(self.video_convert)
        self.video_convert.link(self.sink)
        # Get the widget from gtksink and add it to the window
        self.video_widget = self.sink.get_property("widget")
        self.add(self.video_widget)
        self.connect("realize", self.on_realize)
        self.connect("configure-event", self.on_configure)
        self.x = self.y = self.width = self.height = 0  # Initialize geometry variables

    def on_realize(self, widget):
        self.start_preview()

    def on_configure(self, widget, event):
        # Get the geometry of the preview window
        window = self.get_window()
        if window:
            self.x, self.y, self.width, self.height = window.get_geometry()
            # Set the capture region to exclude the preview window
            screen_width = Gdk.Screen.width()
            screen_height = Gdk.Screen.height()
            self.src.set_property("startx", 0)
            self.src.set_property("starty", 0)
            self.src.set_property("endx", screen_width)
            self.src.set_property("endy", screen_height)
            self.src.set_property("show-pointer", False)  # Hide the pointer to avoid mirroring

    def start_preview(self):
        self.pipeline.set_state(Gst.State.PLAYING)

    def stop_preview(self):
        self.pipeline.set_state(Gst.State.NULL)

    def create_element(self, factory_name, name):
        element = Gst.ElementFactory.make(factory_name, name)
        if not element:
            print(f"Failed to create element {name} of type {factory_name}")
        return element


class ScreenRecorder(Gtk.Window):
    def __init__(self):
        super().__init__(title="StormOS Screen Recorder")
        self.set_default_size(400, 200)

        # Initialize directories
        self.output_directory = os.path.join(os.path.expanduser('~'), 'Videos')
        self.temp_directory = os.path.join(self.output_directory, 'temp')
        os.makedirs(self.output_directory, exist_ok=True)
        os.makedirs(self.temp_directory, exist_ok=True)

        self.connect("destroy", self.cleanup_on_exit)

        self.is_recording = False
        self.start_time = 0
        self.output_filename = None
        self.ffmpeg_process = None
        self.file_size = 0
        self.custom_region_start_x = None
        self.custom_region_start_y = None
        self.custom_region_end_x = None
        self.custom_region_end_y = None
        self.recording_region = None
        self.completed_recordings = []
        self.recent_recording_menu_item = None  # Initialize recent recording menu item
        self.preview_window = None  # Initialize screen preview window

        # Register cleanup function to run when the program exits
        atexit.register(self.cleanup_on_exit)

        # Set up signal handling for termination
        signal.signal(signal.SIGINT, self.cleanup_on_exit)
        signal.signal(signal.SIGTERM, self.cleanup_on_exit)

        # Create a grid to organize widgets
        grid = Gtk.Grid()
        grid.set_column_spacing(10)
        grid.set_row_spacing(10)
        self.add(grid)

        # Dropdown menu for selecting audio input configuration
        self.audio_input_configs = ["Primary Only", "Secondary Only", "Both"]
        self.audio_input_config_label = Gtk.Label(label="Select Audio Input Configuration:")
        grid.attach(self.audio_input_config_label, 0, 0, 1, 1)
        self.audio_input_config_combo = Gtk.ComboBoxText()
        for config in self.audio_input_configs:
            self.audio_input_config_combo.append_text(config)
        self.audio_input_config_combo.set_active(0)
        grid.attach(self.audio_input_config_combo, 1, 0, 1, 1)

        # Dropdown menu for selecting recording size
        self.recording_sizes = self.get_available_resolutions()
        if not self.recording_sizes:
            self.recording_sizes = [
                ("1920x1080", "1920x1080"),
                ("1280x720", "1280x720"),
                ("640x480", "640x480"),
                ("2560x1440", "2560x1440"),
                ("3840x2160", "3840x2160")
            ]
        self.recording_size_label = Gtk.Label(label="Select Recording Size:")
        grid.attach(self.recording_size_label, 0, 1, 1, 1)
        self.recording_size_combo = Gtk.ComboBoxText()
        for size in self.recording_sizes:
            self.recording_size_combo.append_text(size[0])
        self.recording_size_combo.set_active(0)
        grid.attach(self.recording_size_combo, 1, 1, 1, 1)

        # Dropdown menu for selecting video codec
        self.video_codec_label = Gtk.Label(label="Select Video Codec:")
        grid.attach(self.video_codec_label, 0, 2, 1, 1)
        self.video_codec_combo = Gtk.ComboBoxText()
        self.video_codecs = ["libx264", "libvpx-vp9", "libx265", "libvpx"]
        for codec in self.video_codecs:
            self.video_codec_combo.append_text(codec)
        self.video_codec_combo.set_active(0)
        grid.attach(self.video_codec_combo, 1, 2, 1, 1)

        # Dropdown menu for selecting audio codec
        self.audio_codec_label = Gtk.Label(label="Select Audio Codec:")
        grid.attach(self.audio_codec_label, 0, 3, 1, 1)
        self.audio_codec_combo = Gtk.ComboBoxText()
        self.audio_codecs = ["aac", "mp3", "opus"]
        for codec in self.audio_codecs:
            self.audio_codec_combo.append_text(codec)
        self.audio_codec_combo.set_active(0)
        grid.attach(self.audio_codec_combo, 1, 3, 1, 1)

        # Dropdown menu for selecting primary audio input
        self.audio_input_label = Gtk.Label(label="Select Primary Audio Input:")
        grid.attach(self.audio_input_label, 0, 4, 1, 1)
        self.audio_input_combo = Gtk.ComboBoxText()
        self.audio_inputs = self.get_available_audio_inputs()
        for input_device in self.audio_inputs:
            self.audio_input_combo.append_text(input_device)
        self.audio_input_combo.set_active(0)
        grid.attach(self.audio_input_combo, 1, 4, 1, 1)

        # Dropdown menu for selecting secondary audio input
        self.secondary_audio_input_label = Gtk.Label(label="Select Secondary Audio Input:")
        grid.attach(self.secondary_audio_input_label, 0, 5, 1, 1)
        self.secondary_audio_input_combo = Gtk.ComboBoxText()
        self.secondary_audio_inputs = self.get_available_audio_inputs()
        for input_device in self.secondary_audio_inputs:
            self.secondary_audio_input_combo.append_text(input_device)
        self.secondary_audio_input_combo.set_active(0)
        grid.attach(self.secondary_audio_input_combo, 1, 5, 1, 1)

        # Dropdown menu for selecting recording area
        self.recording_area_label = Gtk.Label(label="Select Recording Area:")
        grid.attach(self.recording_area_label, 0, 6, 1, 1)
        self.recording_area_combo = Gtk.ComboBoxText()
        self.recording_areas = ["Full Screen", "Camera Only", "Active Window", "Custom Region"]
        for area in self.recording_areas:
            self.recording_area_combo.append_text(area)
        self.recording_area_combo.set_active(0)
        grid.attach(self.recording_area_combo, 1, 6, 1, 1)

        # Dropdown menu for selecting output format
        self.output_format_label = Gtk.Label(label="Select Output Format:")
        grid.attach(self.output_format_label, 0, 7, 1, 1)
        self.output_format_combo = Gtk.ComboBoxText()
        output_formats = ["mp4", "mkv", "webm"]
        for format in output_formats:
            self.output_format_combo.append_text(format)
        self.output_format_combo.set_active(0)
        grid.attach(self.output_format_combo, 1, 7, 1, 1)

        # Dropdown menu for selecting active window
        self.active_window_label = Gtk.Label(label="Select Active Window:")
        grid.attach(self.active_window_label, 0, 8, 1, 1)
        self.active_window_combo = Gtk.ComboBoxText()
        self.update_active_windows()
        grid.attach(self.active_window_combo, 1, 8, 1, 1)

        # Record button with icon
        self.record_button = Gtk.Button(label="Record")
        record_icon = Gtk.Image.new_from_icon_name("media-record", Gtk.IconSize.BUTTON)
        self.record_button.set_image(record_icon)
        self.record_button.set_always_show_image(True)
        self.record_button.connect("clicked", self.start_recording)
        grid.attach(self.record_button, 0, 10, 1, 1)

        # Stop button with icon
        self.stop_button = Gtk.Button(label="Stop")
        stop_icon = Gtk.Image.new_from_icon_name("media-playback-stop", Gtk.IconSize.BUTTON)
        self.stop_button.set_image(stop_icon)
        self.stop_button.set_always_show_image(True)
        self.stop_button.connect("clicked", self.stop_recording)
        self.stop_button.set_sensitive(False)
        grid.attach(self.stop_button, 1, 10, 1, 1)

        # Capture Active Window button
        self.capture_active_window_button = Gtk.Button(label="Capture Active Window")
        self.capture_active_window_button.connect("clicked", self.capture_active_window)
        grid.attach(self.capture_active_window_button, 0, 9, 1, 1)

        # Refresh Windows button
        self.refresh_windows_button = Gtk.Button(label="Refresh Windows")
        self.refresh_windows_button.connect("clicked", self.refresh_windows)
        grid.attach(self.refresh_windows_button, 1, 9, 1, 1)

        # Status label
        self.status_label = Gtk.Label(label="Press Record to start recording.")
        self.status_label.set_justify(Gtk.Justification.CENTER)  # Center justify the text
        self.status_label.set_halign(Gtk.Align.CENTER)  # Center horizontally within the grid cell
        grid.attach(self.status_label, 0, 11, 2, 1)

        # File size label
        self.file_size_label = Gtk.Label(label="")
        self.file_size_label.set_justify(Gtk.Justification.CENTER)  # Center justify the text
        self.file_size_label.set_halign(Gtk.Align.CENTER)  # Center horizontally within the grid cell
        grid.attach(self.file_size_label, 0, 12, 2, 1)

        # Camera detection and selection
        self.available_cameras = self.get_available_cameras_v4l2()
        self.camera_label = Gtk.Label(label="Select Camera:")
        grid.attach(self.camera_label, 0, 15, 1, 1)
        self.camera_combo = Gtk.ComboBoxText()
        for camera in self.available_cameras:
            self.camera_combo.append_text(camera)
        self.camera_combo.set_active(0)
        grid.attach(self.camera_combo, 1, 15, 1, 1)

        # Camera resolution
        self.camera_resolution_label = Gtk.Label(label="Select Camera Resolution:")
        grid.attach(self.camera_resolution_label, 0, 14, 1, 1)
        self.camera_resolution_combo = Gtk.ComboBoxText()
        camera_resolutions = ["480x320", "640x480", "1280x720", "1920x1080"]
        for resolution in camera_resolutions:
            self.camera_resolution_combo.append_text(resolution)
        self.camera_resolution_combo.set_active(0)
        grid.attach(self.camera_resolution_combo, 1, 14, 1, 1)

        # Camera window button
        self.camera_button = Gtk.Button(label="Show Camera")
        self.camera_button.connect("clicked", self.show_camera_window)
        grid.attach(self.camera_button, 0, 16, 1, 1)

        # Close camera window button
        self.close_camera_button = Gtk.Button(label="Close Camera")
        self.close_camera_button.connect("clicked", self.close_camera_window)
        grid.attach(self.close_camera_button, 1, 16, 1, 1)

        # Create a checkbox for "Enable Journaling Mode"
        self.checkbox = Gtk.CheckButton(label="Enable Journaling Mode")
        grid.attach(self.checkbox, 0, 17, 1, 1)  # Attach to column 0, row 17, span 1 column, 1 row
        self.checkbox.connect("toggled", self.on_checkbox_toggled)
        self.is_journal_mode = False

        # Create a checkbox for "Enable Keep Mode"
        self.keep_checkbox = Gtk.CheckButton(label="Enable Keep Mode")
        grid.attach(self.keep_checkbox, 1, 17, 1, 1)  # Attach to column 1, row 17, span 1 column, 1 row
        self.keep_checkbox.connect("toggled", self.on_keep_checkbox_toggled)
        self.is_keep_mode = False

        # Create a checkbox for showing screen preview
        self.show_screen_preview_checkbox = Gtk.CheckButton(label="Show Screen Preview")
        grid.attach(self.show_screen_preview_checkbox, 0, 18, 1, 1)
        self.show_screen_preview_checkbox.connect("toggled", self.on_show_screen_preview_toggled)

        # Add "Play Recent Recording" button
        self.play_recent_button = Gtk.Button(label="Play Recent Recording")
        self.play_recent_button.connect("clicked", self.open_recent_recording)  # Corrected here
        grid.attach(self.play_recent_button, 0, 13, 1, 1)  # Attach to column 0, row 13, span 1 column, 1 row

        # Add a label to display recent recording information
        self.recent_recording_info_label = Gtk.Label(label="No recent recording")
        grid.attach(self.recent_recording_info_label, 1, 13, 1, 1)  # Attach to column 1, row 13, span 1 column, 1 row

        self.show_all()

        # System tray integration
        self.tray_icon = None
        self.create_tray_icon()

    def get_available_resolutions(self):
        try:
            output = subprocess.check_output(['xrandr']).decode('utf-8')
            resolutions = re.findall(r'(\d+x\d+)\s+\d+\.\d+\*', output)
            return [(res, res) for res in resolutions]
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting available resolutions: {e}")
            return []

    def get_available_audio_inputs(self):
        try:
            output = subprocess.check_output(['pactl', 'list', 'sources']).decode('utf-8')
            inputs = re.findall(r'Name: (.+)', output)
            return inputs
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting available audio inputs: {e}")
            return []

    def get_active_windows(self):
        try:
            output = subprocess.check_output(['wmctrl', '-l']).decode('utf-8')
            windows = re.findall(r'0x[0-9a-fA-F]+\s+\d+\s+\S+\s+(.+)', output)
            return windows
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting active windows: {e}")
            return []

    def update_active_windows(self):
        self.active_window_combo.remove_all()
        active_windows = self.get_active_windows()
        for window in active_windows:
            self.active_window_combo.append_text(window)
        self.active_window_combo.set_active(0)

    def refresh_windows(self, widget):
        self.update_active_windows()
        self.status_label.set_text("Window list refreshed.")

    def monitor_ffmpeg_output(self):
        if self.ffmpeg_process:
            while self.ffmpeg_process.poll() is None:
                output = self.ffmpeg_process.stdout.readline()
                if output:
                    print(output.strip())
                error = self.ffmpeg_process.stderr.readline()
                if error:
                    print(error.strip(), file=sys.stderr)

    def start_ffmpeg_process(self, command):
        try:
            self.ffmpeg_process = subprocess.Popen(command)
        except Exception as e:
            logging.error(f"Error starting FFmpeg process: {e}")

    def cleanup_on_exit(self, signum=None, frame=None):
        if self.ffmpeg_process:
            try:
                self.ffmpeg_process.terminate()
                self.ffmpeg_process.wait(timeout=20)  # Increase timeout to 20 seconds
            except subprocess.TimeoutExpired:
                logging.warning("FFmpeg process termination timed out. Attempting to kill with pkill...")
                try:
                    subprocess.run(['pkill', '-f', 'ffmpeg'])
                except Exception as e:
                    logging.error(f"Error killing FFmpeg process with pkill: {e}")
            except Exception as e:
                logging.error(f"Error terminating FFmpeg process: {e}")
            finally:
                self.ffmpeg_process = None

        try:
            subprocess.run(['pkill', '-f', 'ffplay'])
        except Exception as e:
            logging.error(f"Error closing ffplay windows: {e}")

        if hasattr(self, 'indicator') and self.indicator:
            self.indicator.set_status(AppIndicator3.IndicatorStatus.PASSIVE)  # Hide the tray icon
            del self.indicator  # Delete the tray icon object to remove it completely

        if Gtk.main_level() > 0:
            Gtk.main_quit()

        # Ensure preview window is also closed
        if self.preview_window:
            self.preview_window.stop_preview()
            self.preview_window.destroy()

    def on_keep_checkbox_toggled(self, button):
        self.is_keep_mode = button.get_active()

    def start_recording(self, widget):
        if not self.is_recording:
            self.is_recording = True
            self.start_time = time.time()
            self.status_label.set_text("Recording...")
            self.stop_button.set_sensitive(True)
            self.file_size = 0

            selected_size = self.recording_size_combo.get_active_text()
            selected_output_format = ["mp4", "mkv", "webm"][self.output_format_combo.get_active()]
            selected_recording_area = self.recording_areas[self.recording_area_combo.get_active()]
            selected_video_codec = self.video_codecs[self.video_codec_combo.get_active()]
            selected_audio_codec = self.audio_codecs[self.audio_codec_combo.get_active()]
            selected_audio_config = self.audio_input_configs[self.audio_input_config_combo.get_active()]

            if selected_size is None:
                self.status_label.set_text("Error: No recording size selected.")
                return

            if "x" in selected_size:
                width, height = map(int, selected_size.split('x'))
            else:
                self.status_label.set_text("Error: Invalid recording size.")
                return

            timestamp = time.strftime("%d-%m-%Y_%I-%M-%S%p")
            filename_prefix = "Journal" if self.is_journal_mode else "recording"
            if self.is_keep_mode:
                filename_prefix += "_keep"
            self.output_filename = os.path.join(self.output_directory, f"{filename_prefix}_{timestamp}.{selected_output_format}")

            input_args = [
                "-probesize", "500M", "-analyzeduration", "100M",  # Increased probesize and added analyzeduration
                "-thread_queue_size", "750",  # Added thread_queue_size for video input
            ]
            primary_audio_input = self.audio_inputs[self.audio_input_combo.get_active()]
            secondary_audio_input = self.secondary_audio_inputs[self.secondary_audio_input_combo.get_active()]

            logging.info(f"Primary audio input: {primary_audio_input}")
            logging.info(f"Secondary audio input: {secondary_audio_input}")

            if selected_recording_area == "Full Screen":
                input_args += ["-video_size", f"{width}x{height}", "-framerate", "30", "-f", "x11grab", "-i", ":0.0"]
            elif selected_recording_area == "Camera Only":
                selected_camera = self.camera_combo.get_active_text()
                if selected_camera:
                    camera_index = int(selected_camera.split(" ")[1])
                    device = f"/dev/video{camera_index}"
                    resolution = self.camera_resolution_combo.get_active_text()
                    if resolution == "1280x720":
                        # Set the frame rate using v4l2-ctl for 1280x720 resolution
                        subprocess.run(["v4l2-ctl", "--device", device, "--set-fmt-video=width=1280,height=720", "--set-parm=30"])
                        input_args += ["-f", "v4l2", "-framerate", "30", "-video_size", resolution, "-i", device]
                    else:
                        input_args += ["-f", "v4l2", "-video_size", resolution, "-i", device]
            elif selected_recording_area == "Active Window":
                selected_window = self.active_window_combo.get_active_text()
                if selected_window:
                    window_info = self.get_window_info_by_name(selected_window)
                    if window_info:
                        x_pos, y_pos, width, height = window_info
                        input_args += ["-video_size", f"{width}x{height}", "-framerate", "30", "-f", "x11grab", "-i", f":0.0+{x_pos},{y_pos}"]
            elif selected_recording_area == "Custom Region":
                region = self.select_custom_region()
                if region:
                    x, y, w, h = region
                    input_args += ["-video_size", f"{w}x{h}", "-framerate", "30", "-f", "x11grab", "-i", f":0.0+{x},{y}"]
            else:
                input_args += ["-video_size", f"{self.custom_region_end_x - self.custom_region_start_x}x{self.custom_region_end_y - self.custom_region_start_y}", "-framerate", "30", "-f", "x11grab", "-i", f":0.0+{self.custom_region_start_x},{self.custom_region_start_y}"]

            if selected_audio_config == "Primary Only":
                audio_args = [
                    "-thread_queue_size", "1024",  # Added thread_queue_size for audio input
                    "-f", "pulse", "-i", primary_audio_input, "-b:a", "320k", "-async", "1", "-af", "aresample=async=1"
                ]
            elif selected_audio_config == "Secondary Only":
                audio_args = [
                    "-thread_queue_size", "1024",  # Added thread_queue_size for audio input
                    "-f", "pulse", "-i", secondary_audio_input, "-b:a", "320k", "-async", "1", "-af", "aresample=async=1"
                ]
            else:  # Both
                audio_args = [
                    "-thread_queue_size", "1024",  # Added thread_queue_size for primary audio input
                    "-f", "pulse", "-i", primary_audio_input,
                    "-thread_queue_size", "1024",  # Added thread_queue_size for secondary audio input
                    "-f", "pulse", "-i", secondary_audio_input, "-b:a", "320k", "-async", "1", "-af", "aresample=async=1"
                ]

            buffer_args = ["-bufsize", "500M", "-rtbufsize", "500M"]  # Increase buffer sizes

            # Replace -vsync with -fps_mode
            sync_args = ["-fps_mode", "vfr"]

            # Adjust audio offset if needed
            offset_args = ["-itsoffset", "1.10"]  # Adjust the offset value as needed

            if selected_output_format == "webm":
                command = [
                    "ffmpeg", "-y",
                    *input_args,
                    *offset_args,  # Place offset_args before the input file
                    *audio_args,
                    *buffer_args,
                    *sync_args,
                    "-c:v", "libvpx", "-c:a", "libvorbis",  # Use libvpx for video and libvorbis for audio
                    "-crf", "23", "-b:v", "100M",  # Set CRF and bitrate for video
                    "-b:a", "320k",  # Set bitrate for audio
                    "-f", "webm", self.output_filename
                ]
            else:
                command = [
                    "ffmpeg", "-y",
                    *input_args,
                    *offset_args,  # Place offset_args before the input file
                    *audio_args,
                    *buffer_args,
                    *sync_args,
                    "-c:v", selected_video_codec, "-c:a", selected_audio_codec,
                    "-preset", "medium", "-crf", "23", "-b:v", "100M", "-b:a", "320k",
                    self.output_filename
                ]

            logging.info(f"FFmpeg command: {' '.join(command)}")

            self.start_ffmpeg_process(command)
            threading.Thread(target=self.monitor_file_size).start()

    def stop_recording(self, widget):
        if self.is_recording:
            self.is_recording = False
            self.status_label.set_text("Recording stopped.")
            self.stop_button.set_sensitive(False)
            if self.ffmpeg_process:
                try:
                    # Attempt graceful termination
                    self.ffmpeg_process.terminate()
                    self.ffmpeg_process.wait(timeout=20)  # Increase timeout to 20 seconds
                except subprocess.TimeoutExpired:
                    logging.warning("FFmpeg process termination timed out. Attempting to kill with terminate()...")
                    try:
                        # Forcefully terminate the process
                        self.ffmpeg_process.kill()
                        self.ffmpeg_process.wait(timeout=5)
                    except subprocess.TimeoutExpired:
                        logging.error("FFmpeg process could not be killed.")
                    except Exception as e:
                        logging.error(f"Error killing FFmpeg process: {e}")
                except Exception as e:
                    logging.error(f"Error terminating FFmpeg process: {e}")
                finally:
                    self.ffmpeg_process = None
            # Add the completed recording to the list
            self.completed_recordings.append((self.output_filename, time.time()))
            # Update the recent recording menu item
            self.update_recent_recording_menu_item()

    def capture_active_window(self, widget):
        window_info = self.get_active_window_info()
        if window_info:
            x_pos, y_pos, width, height = window_info
            self.custom_region_start_x = x_pos
            self.custom_region_start_y = y_pos
            self.custom_region_end_x = x_pos + width
            self.custom_region_end_y = y_pos + height
            self.recording_region = (x_pos, y_pos, width, height)
            self.status_label.set_text("Active window captured for recording.")

    def select_custom_region(self):
        try:
            output = subprocess.check_output(['xrectsel']).decode('utf-8').strip()
            if output:
                # The expected format is "WIDTHxHEIGHT+X+Y"
                match = re.match(r'(\d+)x(\d+)\+(\d+)\+(\d+)', output)
                if match:
                    width, height, x, y = map(int, match.groups())
                    return (x, y, width, height)
                else:
                    logging.error(f"Unexpected output format: {output}")
                    self.status_label.set_text(f"Unexpected output format: {output}")
                    return None
        except subprocess.CalledProcessError as e:
            logging.error(f"Error selecting custom region: {e}")
            self.status_label.set_text(f"Error selecting custom region: {e}")
            return None

    def get_active_window_info(self):
        try:
            output = subprocess.check_output(['xwininfo', '-id', self.get_active_window_id()]).decode('utf-8')
            x_pos = int(re.search(r'Absolute upper-left X:\s+(\d+)', output).group(1))
            y_pos = int(re.search(r'Absolute upper-left Y:\s+(\d+)', output).group(1))
            width = int(re.search(r'Width:\s+(\d+)', output).group(1))
            height = int(re.search(r'Height:\s+(\d+)', output).group(1))
            return (x_pos, y_pos, width, height)
        except Exception as e:
            self.status_label.set_text(f"Error getting active window info: {e}")
            return None

    def get_active_window_id(self):
        try:
            output = subprocess.check_output(['xdotool', 'getactivewindow']).decode('utf-8').strip()
            return output
        except Exception as e:
            self.status_label.set_text(f"Error getting active window ID: {e}")
            return None

    def get_window_id_by_name(self, window_name):
        try:
            output = subprocess.check_output(['wmctrl', '-l']).decode('utf-8')
            for line in output.splitlines():
                if window_name in line:
                    return line.split()[0]
            return None
        except Exception as e:
            self.status_label.set_text(f"Error getting window ID by name: {e}")
            return None

    def get_window_info_by_name(self, window_name):
        window_id = self.get_window_id_by_name(window_name)
        if window_id:
            try:
                output = subprocess.check_output(['xwininfo', '-id', window_id]).decode('utf-8')
                x_pos = int(re.search(r'Absolute upper-left X:\s+(\d+)', output).group(1))
                y_pos = int(re.search(r'Absolute upper-left Y:\s+(\d+)', output).group(1))
                width = int(re.search(r'Width:\s+(\d+)', output).group(1))
                height = int(re.search(r'Height:\s+(\d+)', output).group(1))
                return (x_pos, y_pos, width, height)
            except Exception as e:
                self.status_label.set_text(f"Error getting window info by name: {e}")
                return None
        else:
            self.status_label.set_text("Error: Window not found.")
            return None

    def monitor_file_size(self):
        start_time = time.time()
        while self.is_recording:
            time.sleep(1)  # Check every second
            elapsed_time = time.time() - start_time
            if self.output_filename and os.path.exists(self.output_filename):
                size = os.path.getsize(self.output_filename)
                self.file_size = size
                self.file_size_label.set_text(f"File size: {self.convert_size(size)}")
            else:
                self.file_size_label.set_text("File size: N/A")
            # Update the elapsed time
            self.status_label.set_text(f"Recording... Elapsed time: {self.format_time(elapsed_time)}")

    def format_time(self, elapsed_time):
        minutes, seconds = divmod(elapsed_time, 60)
        hours, minutes = divmod(minutes, 60)
        return "{:02}:{:02}:{:02}".format(int(hours), int(minutes), int(seconds))

    def convert_size(self, size_bytes):
        if size_bytes == 0:
            return "0B"
        size_name = ("B", "KB", "MB", "GB", "TB")
        i = int(math.floor(math.log(size_bytes, 1024)))
        p = math.pow(1024, i)
        s = round(size_bytes / p, 2)
        return f"{s} {size_name[i]}"

    def on_checkbox_toggled(self, button):
        self.is_journal_mode = button.get_active()

    def show_camera_window(self, widget):
        selected_camera = self.camera_combo.get_active_text()
        selected_resolution = self.camera_resolution_combo.get_active_text()
        if selected_camera:
            camera_index = int(selected_camera.split(" ")[1])
            device = f"/dev/video{camera_index}"
            resolution = selected_resolution if selected_resolution else "640x480"  # Set default resolution if not selected
            command = ['ffplay', '-f', 'v4l2', '-video_size', resolution, '-vf', 'hflip', device]
            
            try:
                subprocess.Popen(command)
            except Exception as e:
                logging.error(f"Failed to open {device} using V4L2: {e}")

    def close_camera_window(self, widget):
        command = ['pkill', '-f', 'ffplay -f v4l2']
        try:
            subprocess.run(command)
        except Exception as e:
            logging.error(f"Failed to close camera windows: {e}")

    def get_available_cameras_v4l2(self):
        try:
            output = subprocess.check_output(['v4l2-ctl', '--list-devices']).decode('utf-8')
            cameras = re.findall(r'/dev/video(\d+)', output)
            return [f"Camera {index}" for index in cameras]
        except Exception as e:
            logging.error(f"Error getting available cameras: {e}")
            return []

    def create_tray_icon(self):
        # Create the AppIndicator
        self.indicator = AppIndicator3.Indicator.new(
            "screen-recorder-indicator",
            "media-record",
            AppIndicator3.IndicatorCategory.APPLICATION_STATUS
        )
        self.indicator.set_status(AppIndicator3.IndicatorStatus.ACTIVE)
        # Deprecated method warning
        # self.indicator.set_secondary_activate_target("media-record")  # Remove this line

        # Create a menu for the AppIndicator
        menu = Gtk.Menu()

        # Add "Show" item
        show_item = Gtk.MenuItem(label="Main/Settings Window")
        show_item.connect("activate", self.show_window)
        menu.append(show_item)

        # Add "Record" item
        record_item = Gtk.MenuItem(label="Record")
        record_item.connect("activate", self.start_recording)
        menu.append(record_item)

        # Add "Stop Recording" item
        stop_record_item = Gtk.MenuItem(label="Stop Recording")
        stop_record_item.connect("activate", self.stop_recording)
        menu.append(stop_record_item)

        # Add "Open Recent Recording" item
        self.recent_recording_menu_item = Gtk.MenuItem(label="No recent recording")
        self.recent_recording_menu_item.connect("activate", self.open_recent_recording)
        menu.append(self.recent_recording_menu_item)

        # Add "Quit" item
        quit_item = Gtk.MenuItem(label="Quit")
        quit_item.connect("activate", self.quit_app)
        menu.append(quit_item)

        # Add a separator
        separator = Gtk.SeparatorMenuItem()
        menu.append(separator)

        # Add a label item for recording status
        self.recording_status_menu_item = Gtk.MenuItem(label="Not Recording")
        menu.append(self.recording_status_menu_item)

        # Add a label item for file size
        self.file_size_menu_item = Gtk.MenuItem(label="File Size: N/A")
        menu.append(self.file_size_menu_item)

        # Add a label item for elapsed time
        self.elapsed_time_menu_item = Gtk.MenuItem(label="Elapsed Time: 00:00:00")
        menu.append(self.elapsed_time_menu_item)

        menu.show_all()
        self.indicator.set_menu(menu)

        # Start a thread to update file size and elapsed time periodically
        threading.Thread(target=self.update_tray_info).start()


    def update_tray_info(self):
        while True:
            if self.is_recording:
                # Update file size and elapsed time information
                file_size_text = f"File Size: {self.convert_size(self.file_size)}"
                elapsed_time_text = f"Elapsed Time: {self.format_time(time.time() - self.start_time)}"
                recording_status_text = "Status: Recording..."
            else:
                # If not recording, set default text
                file_size_text = "File Size: N/A"
                elapsed_time_text = "Elapsed Time: 00:00:00"
                recording_status_text = "Status: Not Recording"

            # Update the recent recording menu item
            if self.completed_recordings:
                sorted_recordings = sorted(self.completed_recordings, key=lambda x: x[1], reverse=True)
                most_recent_path = sorted_recordings[0][0]
                most_recent_filename = os.path.basename(most_recent_path)
                most_recent_file_size = self.convert_size(os.path.getsize(most_recent_path))
                recent_recording_text = f"Recent Recording: {most_recent_filename} ({most_recent_file_size})"
            else:
                recent_recording_text = "No recent recording"

            # Use glib.idle_add to update the labels in the system tray menu
            GLib.idle_add(self.file_size_menu_item.set_label, file_size_text)
            GLib.idle_add(self.elapsed_time_menu_item.set_label, elapsed_time_text)
            GLib.idle_add(self.recent_recording_menu_item.set_label, recent_recording_text)
            GLib.idle_add(self.recording_status_menu_item.set_label, recording_status_text)

            # Sleep for a short duration before updating again
            time.sleep(1)  # Update every second

    def open_recent_recording(self, widget):
        if self.completed_recordings:
            # Sort recordings by timestamp in descending order
            sorted_recordings = sorted(self.completed_recordings, key=lambda x: x[1], reverse=True)
            most_recent_path = sorted_recordings[0][0]
            try:
                subprocess.Popen(["xdg-open", most_recent_path])
            except Exception as e:
                logging.error(f"Failed to open the recent recording: {e}")
                self.status_label.set_text("Failed to open the recent recording.")
        else:
            self.status_label.set_text("No completed recordings found.")

    def update_recent_recording_menu_item(self):
        if self.completed_recordings:
            # Sort recordings by timestamp in descending order
            sorted_recordings = sorted(self.completed_recordings, key=lambda x: x[1], reverse=True)
            most_recent_path = sorted_recordings[0][0]
            most_recent_filename = os.path.basename(most_recent_path)
            most_recent_file_size = self.convert_size(os.path.getsize(most_recent_path))
            label_text = f"Recent Recording: {most_recent_filename} ({most_recent_file_size})"
        else:
            label_text = "No recent recording"

        # Update the label in the system tray menu
        if self.recent_recording_menu_item:
            self.recent_recording_menu_item.set_label(label_text)
        else:
            self.recent_recording_menu_item = Gtk.MenuItem(label=label_text)
            self.indicator.get_menu().append(self.recent_recording_menu_item)
            self.recent_recording_menu_item.show()

        # Update the label in the main window
        GLib.idle_add(self.recent_recording_info_label.set_text, label_text)

    def show_window(self, widget):
        # Check if the window is minimized
        if self.get_window().get_state() & Gdk.WindowState.ICONIFIED:
            # If minimized, restore it
            self.deiconify()
            self.present()
            self.set_keep_above(True)
        else:
            # If not minimized, check if it is already visible
            if self.is_active():
                # If visible, minimize it
                self.iconify()
            else:
                # If not visible, show it
                self.show_all()
                self.present()
                self.set_keep_above(True)

    def quit_app(self, widget):
        self.cleanup_on_exit()
        os._exit(0)  # Forcefully terminate the process

    def on_show_screen_preview_toggled(self, button):
        if button.get_active():
            self.preview_window = ScreenPreview()
            self.preview_window.connect("destroy", self.on_preview_window_destroyed)
            self.preview_window.show_all()
        else:
            if self.preview_window:
                self.preview_window.stop_preview()
                self.preview_window.destroy()
                self.preview_window = None

    def on_preview_window_destroyed(self, widget):
        self.preview_window = None
        self.show_screen_preview_checkbox.set_active(False)

    def on_delete_event(self, widget, event):
        # Perform any necessary cleanup here
        if self.preview_window:
            self.preview_window.stop_preview()
            self.preview_window.destroy()
        return False  # Returning False allows the event to propagate and the window to be destroyed

    def on_destroy(self, widget):
        # Ensure all resources are released and the application is terminated
        Gtk.main_quit()

    def signal_handler(sig, frame):
        logging.info("Received SIGINT signal. Exiting...")
        recorder.cleanup_on_exit()
        Gtk.main_quit()


def main():
    recorder = ScreenRecorder()
    recorder.connect("delete-event", recorder.on_delete_event)
    recorder.connect("destroy", recorder.on_destroy)
    try:
        recorder.create_tray_icon()
        # Set up signal handler for SIGINT
        signal.signal(signal.SIGINT, recorder.signal_handler)
        Gtk.main()
    except KeyboardInterrupt:
        # Handle keyboard interrupt (Ctrl+C)
        recorder.stop_recording(None)
        Gtk.main_quit()
    except Exception as e:
        # Handle other exceptions
        logging.error(f"An error occurred: {e}")
        Gtk.main_quit()

if __name__ == "__main__":
    main()
