#!/usr/bin/env python3

import os
import sys
import json
import logging
import re
from urllib.parse import urlparse, quote_plus
import gi

gi.require_version('Gtk', '3.0')
gi.require_version('WebKit2', '4.0')
from gi.repository import Gtk, WebKit2, GLib, Gdk, Pango

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Disable hardware acceleration and compositing to prevent OpenGL context issues
os.environ['LIBGL_ALWAYS_SOFTWARE'] = '0'
os.environ['WEBKIT_DISABLE_COMPOSITING_MODE'] = '1'
os.environ['WEBKIT_ACCELERATED'] = '0'

class SettingsManager:
    """Handles storing and retrieving site-specific settings."""
    def __init__(self):
        self.settings_file = os.path.join(os.path.expanduser('~'), 'Documents', 'site_settings.json')
        logger.debug(f"Settings file path: {self.settings_file}")
        self.settings = self.load_settings()

        if not os.path.exists(self.settings_file):
            self.save_settings()

    def load_settings(self):
        try:
            if os.path.exists(self.settings_file):
                with open(self.settings_file, 'r') as file:
                    settings = json.load(file)
                    logger.info("Settings loaded successfully.")
                    return settings
            logger.info("Settings file not found. Will create upon saving.")
            return {}
        except Exception as e:
            logger.error(f"Error accessing settings file at {self.settings_file}: {e}")
            return {}

    def save_settings(self):
        try:
            os.makedirs(os.path.dirname(self.settings_file), exist_ok=True)
            with open(self.settings_file, 'w') as file:
                json.dump(self.settings, file, indent=4)
            logger.info("Settings saved successfully.")
        except Exception as e:
            logger.error(f"Error saving settings at {self.settings_file}: {e}")

    def get_site_settings(self, url):
        parsed_url = urlparse(url)
        domain = parsed_url.netloc
        return self.settings.get(domain, {})

    def set_site_settings(self, url, setting_key, setting_value):
        parsed_url = urlparse(url)
        domain = parsed_url.netloc
        if domain not in self.settings:
            self.settings[domain] = {}
        self.settings[domain][setting_key] = setting_value
        self.save_settings()

class DownloadManager(Gtk.Window):
    """Download Manager window to track and manage downloads."""
    def __init__(self):
        super().__init__(title="Download Manager")
        self.set_default_size(600, 400)
        self.set_border_width(10)

        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.add(vbox)

        header_label = Gtk.Label(label="<b>Downloads</b>", use_markup=True)
        vbox.pack_start(header_label, False, False, 0)

        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        vbox.pack_start(scrolled_window, True, True, 0)

        self.listbox = Gtk.ListBox()
        self.listbox.set_selection_mode(Gtk.SelectionMode.NONE)
        scrolled_window.add(self.listbox)

        self.downloads = {}

    def add_download(self, download, filepath, filename):
        row = Gtk.ListBoxRow()
        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        row.add(hbox)

        filename_label = Gtk.Label(label=filename, xalign=0)
        filename_label.set_hexpand(True)
        hbox.pack_start(filename_label, True, True, 0)

        progress_bar = Gtk.ProgressBar()
        progress_bar.set_hexpand(True)
        hbox.pack_start(progress_bar, True, True, 0)

        status_label = Gtk.Label(label="Downloading", xalign=0.5)
        hbox.pack_start(status_label, False, False, 0)

        cancel_button = Gtk.Button.new_from_icon_name("process-stop", Gtk.IconSize.BUTTON)
        cancel_button.set_tooltip_text("Cancel Download")
        cancel_button.connect("clicked", self.on_cancel_clicked, download)
        hbox.pack_start(cancel_button, False, False, 0)

        self.listbox.add(row)
        row.show_all()

        self.downloads[download] = {
            'row': row,
            'filename_label': filename_label,
            'progress_bar': progress_bar,
            'status_label': status_label,
            'cancel_button': cancel_button
        }

    def update_progress(self, download, progress):
        if download in self.downloads:
            ui = self.downloads[download]
            ui['progress_bar'].set_fraction(progress / 100.0)
            ui['progress_bar'].set_text(f"{int(progress)}%")

    def update_status(self, download, status):
        if download in self.downloads:
            ui = self.downloads[download]
            ui['status_label'].set_text(status)
            if status in ["Completed", "Failed", "Canceled"]:
                ui['cancel_button'].set_sensitive(False)

    def on_cancel_clicked(self, button, download):
        download.cancel()
        logger.info(f"Download canceled: {download.get_suggested_filename()}")
        self.update_status(download, "Canceled")

    def remove_download(self, download):
        if download in self.downloads:
            ui = self.downloads.pop(download)
            self.listbox.remove(ui['row'])

class AutofillManager:
    """Manages form autofill data."""
    def __init__(self):
        self.autofill_data_file = os.path.join(os.path.expanduser('~'), 'Documents', 'autofill_data.json')
        self.autofill_data = self.load_autofill_data()

    def load_autofill_data(self):
        if os.path.exists(self.autofill_data_file):
            try:
                with open(self.autofill_data_file, 'r') as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"Failed to load autofill data: {e}")
        return {}

    def save_autofill_data(self):
        try:
            os.makedirs(os.path.dirname(self.autofill_data_file), exist_ok=True)
            with open(self.autofill_data_file, 'w') as f:
                json.dump(self.autofill_data, f, indent=4)
            logger.info("Autofill data saved successfully.")
        except Exception as e:
            logger.error(f"Failed to save autofill data: {e}")

    def get_suggestions(self, field_name):
        return list(self.autofill_data.get(field_name, []))

    def save_field_data(self, field_name, value):
        if field_name not in self.autofill_data:
            self.autofill_data[field_name] = []
        if value not in self.autofill_data[field_name]:
            self.autofill_data[field_name].append(value)
            self.save_autofill_data()

class BrowserTab(Gtk.Box):
    """A class representing a single browser tab."""
    def __init__(self, browser):
        super().__init__(orientation=Gtk.Orientation.VERTICAL)
        self.browser = browser
        self.settings_manager = self.browser.settings_manager

        self.user_content_manager = WebKit2.UserContentManager()
        self.user_content_manager.register_script_message_handler("media")
        self.user_content_manager.register_script_message_handler("autofill")
        self.user_content_manager.connect("script-message-received::media", self.on_script_message_received)
        self.user_content_manager.connect("script-message-received::autofill", self.on_script_message_received_autofill)

        self.webview = WebKit2.WebView.new_with_user_content_manager(self.user_content_manager)

        self.current_uri = None
        self.is_muted = False

        settings = self.webview.get_settings()
        settings.set_property("enable-accelerated-2d-canvas", True)
        settings.set_property("enable-webgl", True)
        settings.set_property("enable-media-stream", False)
        settings.set_property("enable-javascript", True)  # Ensure JavaScript is enabled
        logger.info("WebKit settings optimized for performance.")

        self.webview.connect("notify::title", self.on_title_changed)
        self.webview.connect("load-changed", self.on_load_changed)
        self.webview.connect("notify::estimated-load-progress", self.on_load_progress)
        self.webview.connect("notify::uri", self.on_uri_changed)

        self.inject_media_monitoring_script()
        self.inject_autofill_script()

        self.pack_start(self.webview, True, True, 0)
        self.webview.load_uri(self.browser.homepage)
        self.show_all()

        self.tab_label_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        self.tab_label = Gtk.Label(label="New Tab")
        self.tab_label.set_xalign(0)
        self.tab_label_box.pack_start(self.tab_label, True, True, 0)

        # Add `+` button to the tab for opening new tabs directly
        self.new_tab_button = Gtk.Button.new_from_icon_name("list-add", Gtk.IconSize.BUTTON)
        self.new_tab_button.set_tooltip_text("New Tab")
        self.new_tab_button.set_relief(Gtk.ReliefStyle.NONE)
        self.new_tab_button.set_focus_on_click(False)
        self.new_tab_button.connect("clicked", self.browser.on_new_tab)
        self.tab_label_box.pack_start(self.new_tab_button, False, False, 0)

        self.close_button = Gtk.Button.new_from_icon_name("window-close", Gtk.IconSize.BUTTON)
        self.close_button.set_tooltip_text("Close Tab")
        self.close_button.set_relief(Gtk.ReliefStyle.NONE)
        self.close_button.set_focus_on_click(False)
        self.close_button.connect("clicked", self.browser.close_tab, self)
        self.tab_label_box.pack_start(self.close_button, False, False, 0)

        self.tab_label_box.set_events(Gdk.EventMask.BUTTON_PRESS_MASK)
        self.tab_label_box.connect("button-press-event", self.on_tab_right_click)

        self.tab_label_box.show_all()
        self.browser.notebook.append_page(self, self.tab_label_box)
        self.browser.notebook.set_tab_reorderable(self, True)
        self.browser.notebook.set_current_page(-1)

        self.apply_site_settings(self.browser.homepage)

    def inject_media_monitoring_script(self):
        media_monitoring_js = """
            (function() {
                function notifyPython(message) {
                    window.webkit.messageHandlers.media.postMessage(message);
                }

                function attachMediaEvents(media) {
                    media.addEventListener('play', function() {
                        notifyPython('play');
                    });
                    media.addEventListener('pause', function() {
                        notifyPython('pause');
                    });
                }

                const mediaElements = document.querySelectorAll('video, audio');
                mediaElements.forEach(attachMediaEvents);

                new MutationObserver(function(mutationsList) {
                    mutationsList.forEach(mutation => {
                        if (mutation.type === 'childList') {
                            mutation.addedNodes.forEach(node => {
                                if (node.tagName === 'VIDEO' || node.tagName === 'AUDIO') {
                                    attachMediaEvents(node);
                                }
                            });
                        }
                    });
                }).observe(document.body, { childList: true, subtree: true });
            })();
        """
        user_script = WebKit2.UserScript.new(
            media_monitoring_js,
            WebKit2.UserContentInjectedFrames.ALL_FRAMES,
            WebKit2.UserScriptInjectionTime.START
        )
        self.user_content_manager.add_script(user_script)

    def inject_autofill_script(self):
        autofill_script = """
        (function() {
            function notifyPython(message) {
                window.webkit.messageHandlers.autofill.postMessage(message);
            }

            const fieldsToMonitor = ['input[type="text"]', 'input[type="email"]'];
            const fields = [...document.querySelectorAll(fieldsToMonitor.join(','))];

            fields.forEach(field => {
                field.addEventListener('blur', function() {
                    if (this.value !== '') {
                        notifyPython(JSON.stringify({name: this.name || this.id, value: this.value}));
                    }
                });
            });
        })();
        """
        user_script = WebKit2.UserScript.new(
            autofill_script,
            WebKit2.UserContentInjectedFrames.ALL_FRAMES,
            WebKit2.UserScriptInjectionTime.START
        )
        self.user_content_manager.add_script(user_script)

    def on_script_message_received(self, user_content_manager, message):
        body = message.get_js_value().to_string()
        logger.info(f"Script message received: {body}")

        if body == 'play':
            self.handle_media_play()
        elif body == 'pause':
            self.handle_media_pause()

    def on_script_message_received_autofill(self, user_content_manager, message):
        data = message.get_js_value().to_string()
        try:
            field_data = json.loads(data)
            field_name = field_data.get('name')
            value = field_data.get('value')
            if field_name and value:
                self.browser.autofill_manager.save_field_data(field_name, value)
                logger.info(f"Autofill data saved for {field_name}: {value}")
        except Exception as e:
            logger.error(f"Failed to process autofill message: {e}")

    def handle_media_play(self):
        if self.is_muted:
            logger.info("Tab is manually muted. Muting media using JavaScript.")
            self.mute_audio()
        else:
            logger.info("Play event detected. Unmuting media using JavaScript.")
            self.unmute_audio()

    def mute_audio(self):
        mute_script = """
        var audios = document.querySelectorAll('audio, video');
        audios.forEach(function(audio) {
            audio.muted = true;
        });
        """
        self.webview.run_javascript(mute_script, None, None, self.on_script_run)

    def unmute_audio(self):
        unmute_script = """
        var audios = document.querySelectorAll('audio, video');
        audios.forEach(function(audio) {
            audio.muted = false;
        });
        """
        self.webview.run_javascript(unmute_script, None, None, self.on_script_run)

    def on_script_run(self, web_view, result, *args):
        try:
            logger.info("JavaScript executed successfully.")
        except Exception as e:
            logger.error(f"JavaScript execution failed: {e}")

    def apply_site_settings(self, url):
        site_settings = self.settings_manager.get_site_settings(url)
        logger.info(f"Retrieved settings for {url}: {site_settings}")
        if 'mute' in site_settings:
            self.is_muted = site_settings['mute']
            self.mute_audio() if self.is_muted else self.unmute_audio()
            logger.info(f"Applied mute setting for {url}: {self.is_muted}")

    def save_site_settings(self):
        if self.current_uri:
            self.settings_manager.set_site_settings(self.current_uri, 'mute', self.is_muted)
            logger.info(f"Mute setting saved for {self.current_uri}: {self.is_muted}")

    def on_uri_changed(self, webview, param):
        self.current_uri = webview.get_uri()
        self.browser.update_address_bar(self.current_uri)
        logger.info(f"Address bar updated to: {self.current_uri}")
        self.apply_site_settings(self.current_uri)

    def on_mute_toggle(self, widget):
        self.is_muted = not self.is_muted
        self.mute_audio() if self.is_muted else self.unmute_audio()
        logger.info(f"Tab {'muted' if self.is_muted else 'unmuted'}.")
        self.save_site_settings()

    def on_tab_right_click(self, widget, event):
        if event.type == Gdk.EventType.BUTTON_PRESS and event.button == 3:
            self.show_context_menu(event)

    def show_context_menu(self, event):
        menu = Gtk.Menu()
        
        mute_label = "Unmute" if self.is_muted else "Mute"
        mute_item = Gtk.MenuItem(label=mute_label)
        mute_item.connect("activate", self.on_mute_toggle)
        menu.append(mute_item)
        
        reload_item = Gtk.MenuItem(label="Reload Tab")
        reload_item.connect("activate", self.on_reload_tab)
        menu.append(reload_item)
        
        close_item = Gtk.MenuItem(label="Close Tab")
        close_item.connect("activate", self.browser.close_tab, self)
        menu.append(close_item)
        
        menu.show_all()
        menu.popup_at_pointer(event)

    def on_reload_tab(self, widget):
        self.webview.reload()
        logger.info("Tab reloaded.")

    def on_title_changed(self, webview, param):
        title = webview.get_title() or "New Tab"
        shortened_title = self.shorten_title(title, max_length=30)
        GLib.idle_add(self.tab_label.set_text, shortened_title)
        logger.info(f"Tab title updated to: {shortened_title}")

    def shorten_title(self, title, max_length=30):
        if len(title) > max_length:
            return title[:max_length] + '...'
        return title

    def on_load_changed(self, webview, load_event):
        if load_event == WebKit2.LoadEvent.COMMITTED:
            logger.info("Page load committed; checking mute state.")
        elif load_event == WebKit2.LoadEvent.FINISHED:
            logger.info("Page load finished.")
            GLib.idle_add(self.browser.progress_bar.hide)

    def on_load_progress(self, webview, param):
        progress = webview.get_estimated_load_progress() * 100
        GLib.idle_add(self.browser.update_progress, progress)

    def print_page(self):
        print_operation = WebKit2.PrintOperation.new(self.webview)
        print_operation.connect("finished", self.on_print_finished)
        print_operation.print_()

    def on_print_finished(self, print_operation, result):
        logger.info("Print operation finished.")

    def destroy_tab(self):
        self.webview.destroy()
        self.browser.notebook.remove(self)
        self.destroy()
        logger.info("Tab destroyed.")

    def highlight_tab(self):
        self.tab_label.set_markup(f'<span background="yellow">{self.tab_label.get_text()}</span>')
        GLib.timeout_add(1000, self.remove_highlight)

    def remove_highlight(self):
        self.tab_label.set_markup(self.tab_label.get_text())
        return False

class SimpleBrowser(Gtk.Window):
    """Main browser window."""

    TLD_SET = {".com", ".org", ".net", ".io", ".co"}
    PROBABLE_URL_REGEX = re.compile(r'^\S+?\.\S+')

    def __init__(self):
        super(SimpleBrowser, self).__init__()
        self.set_default_size(1200, 800)
        self.set_title("Simple Browser")
        self.connect('destroy', self.on_destroy)

        self.settings_manager = SettingsManager()
        self.autofill_manager = AutofillManager()

        self.web_context = WebKit2.WebContext.get_default()
        self.web_context.connect("download-started", self.on_download_started)

        self.connect("window-state-event", self.on_window_state_event)

        settings = Gtk.Settings.get_default()
        settings.set_property("gtk-application-prefer-dark-theme", True)

        header_bar = Gtk.HeaderBar()
        header_bar.set_show_close_button(True)
        self.set_titlebar(header_bar)
        self.connect("key-press-event", self.on_key_press_global)

        self.address_bar = Gtk.Entry()
        self.address_bar.set_placeholder_text("Enter URL or search DuckDuckGo")
        self.address_bar.set_width_chars(80)
        self.address_bar.connect("activate", self.on_enter_address)
        self.address_bar.connect("key-press-event", self.on_key_press)
        header_bar.set_custom_title(self.address_bar)

        self.add_navigation_buttons(header_bar)

        self.download_manager = DownloadManager()

        downloads_button = Gtk.Button.new_from_icon_name("folder-download", Gtk.IconSize.BUTTON)
        downloads_button.set_tooltip_text("Open Downloads Folder")
        downloads_button.connect("clicked", self.open_downloads_folder)
        header_bar.pack_end(downloads_button)

        print_button = Gtk.Button.new_from_icon_name("document-print", Gtk.IconSize.BUTTON)
        print_button.set_tooltip_text("Print")
        print_button.connect("clicked", self.on_print_page)
        header_bar.pack_end(print_button)

        self.add_bookmark_buttons(header_bar)

        # Create the toggle button and its icon
        self.switch_tabs_icon = Gtk.Image.new_from_icon_name("go-down-symbolic", Gtk.IconSize.BUTTON)
        self.switch_tabs_button = Gtk.Button()
        self.switch_tabs_button.set_image(self.switch_tabs_icon)
        self.switch_tabs_button.set_tooltip_text("Toggle Tabs Position")
        self.switch_tabs_button.connect("clicked", self.toggle_tab_position)
        header_bar.pack_end(self.switch_tabs_button)

        # Create main container
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.add(vbox)

        # Progress bar at the top of the window
        self.progress_bar = Gtk.ProgressBar()
        self.progress_bar.set_show_text(True)
        self.progress_bar.hide()
        vbox.pack_start(self.progress_bar, False, False, 0)

        # Notebook for tabs
        self.notebook = Gtk.Notebook()
        self.notebook.set_scrollable(True)
        self.notebook.set_tab_pos(Gtk.PositionType.TOP)  # Default to top
        vbox.pack_end(self.notebook, True, True, 0)  # Add the notebook last to ensure it fills the remaining space
        self.notebook.connect("switch-page", self.on_switch_page)

        self.bookmarks = []
        self.bookmarks_file = os.path.join(os.path.expanduser('~'), 'Documents', 'bookmarks.json')
        self.load_bookmarks()

        self.homepage = "https://www.duckduckgo.com"

        self.on_new_tab()

    def toggle_tab_position(self, widget):
        current_pos = self.notebook.get_tab_pos()
        new_pos = Gtk.PositionType.TOP if current_pos == Gtk.PositionType.BOTTOM else Gtk.PositionType.BOTTOM
        self.notebook.set_tab_pos(new_pos)

        # Change the image's icon based on the new tab position
        if new_pos == Gtk.PositionType.TOP:
            self.switch_tabs_icon.set_from_icon_name("go-down-symbolic", Gtk.IconSize.BUTTON)
        else:
            self.switch_tabs_icon.set_from_icon_name("go-up-symbolic", Gtk.IconSize.BUTTON)

        logger.info(f"Toggled tabs position to: {'TOP' if new_pos == Gtk.PositionType.TOP else 'BOTTOM'}")

    def open_downloads_folder(self, widget):
        downloads_dir = os.path.join(os.path.expanduser('~'), 'Downloads')
        try:
            if not os.path.exists(downloads_dir):
                os.makedirs(downloads_dir)
                logger.info(f"Created Downloads directory at: {downloads_dir}")
            uri = GLib.filename_to_uri(downloads_dir, None)
            Gtk.show_uri(None, uri, Gdk.CURRENT_TIME)
            logger.info(f"Opened Downloads folder: {downloads_dir}")
        except Exception as e:
            logger.error(f"Failed to open Downloads folder: {e}")
            dialog = Gtk.MessageDialog(
                transient_for=self,
                modal=True,
                message_type=Gtk.MessageType.ERROR,
                buttons=Gtk.ButtonsType.OK,
                text="Error Opening Downloads Folder",
            )
            dialog.format_secondary_text(f"An error occurred while trying to open the Downloads folder:\n{e}")
            dialog.run()
            dialog.destroy()

    def on_key_press_global(self, widget, event):
        keyval = event.keyval
        state = event.state

        if keyval == Gdk.KEY_t and (state & Gdk.ModifierType.CONTROL_MASK):
            self.on_new_tab()
            return True

        elif keyval == Gdk.KEY_w and (state & Gdk.ModifierType.CONTROL_MASK):
            self.on_close_tab()
            return True

        elif keyval == Gdk.KEY_r and (state & Gdk.ModifierType.CONTROL_MASK):
            self.on_reload_clicked(None)
            return True

        elif keyval == Gdk.KEY_o and (state & Gdk.ModifierType.CONTROL_MASK):
            self.show_url_launcher()
            return True

        return False

    def show_url_launcher(self):
        dialog = Gtk.Dialog(
            title="Open URL",
            transient_for=self,
            modal=True,
            destroy_with_parent=True
        )
        dialog.set_default_size(400, 100)

        content_area = dialog.get_content_area()

        entry = Gtk.Entry()
        entry.set_placeholder_text("Enter URL or search query")
        entry.connect("activate", self.on_launcher_enter, dialog)
        entry.connect("key-press-event", self.on_launcher_key_press, dialog)
        content_area.pack_start(entry, True, True, 0)

        dialog.add_buttons(Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL)

        entry.show()
        dialog.run()
        dialog.destroy()

    def on_launcher_key_press(self, widget, event, dialog):
        # Handle Ctrl + Enter for URL navigation
        if event.state & Gdk.ModifierType.CONTROL_MASK and event.keyval == Gdk.KEY_Return:
            url = self.ensure_tld(widget.get_text().strip())
            self.launch_url(url)
            dialog.response(Gtk.ResponseType.CANCEL)  # Close the dialog
            return True  # Ensure the main event doesn't act on this keypress
        return False

    def on_launcher_enter(self, entry, dialog):
        # Trigger search on Enter
        text = entry.get_text().strip()
        if text:
            self.search_duckduckgo(text)
        dialog.response(Gtk.ResponseType.CANCEL)  # Close the dialog

    def search_duckduckgo(self, query):
        # Quotes the query string to be used in a URL for DuckDuckGo search
        search_url = f"https://www.duckduckgo.com/?q={quote_plus(query)}"
        logger.info(f"Searching DuckDuckGo for: {query}")
        self.on_new_tab()
        current_page = self.get_current_page()
        if current_page:
            current_page.webview.load_uri(search_url)
            logger.info(f"Navigated to DuckDuckGo search for: {query}")

    def ensure_tld(self, domain):
        if not domain.startswith("www."):
            domain = "www." + domain
        if not any(domain.endswith(tld) for tld in self.TLD_SET):
            domain += ".com"
        return domain

    def launch_url(self, url):
        url = self.format_url(url)
        self.on_new_tab()
        current_page = self.get_current_page()
        if current_page:
            current_page.webview.load_uri(url)
            logger.info(f"Navigated to URL: {url}")

    def close_tab(self, widget, tab):
        total_pages = self.notebook.get_n_pages()

        if total_pages <= 1:
            self.destroy()
            logger.info("Last tab closed. Application window destroyed.")
        else:
            if isinstance(tab, BrowserTab):
                self.notebook.remove(tab)
                tab.webview.destroy()
                tab.destroy()
                logger.info("Tab closed.")
            else:
                logger.error("Attempted to close a non-BrowserTab instance.")

    def on_window_state_event(self, widget, event):
        if event.changed_mask & Gdk.WindowState.FULLSCREEN:
            if event.new_window_state & Gdk.WindowState.FULLSCREEN:
                self.notebook.set_show_tabs(False)
                logger.info("Entered fullscreen. Tabs hidden.")
            else:
                self.notebook.set_show_tabs(True)
                logger.info("Exited fullscreen. Tabs shown.")

    def on_download_started(self, web_context, download):
        logger.info("Download started signal received.")

        suggested_filename = download.get_suggested_filename()
        downloads_dir = os.path.join(os.path.expanduser('~'), 'Downloads')
        os.makedirs(downloads_dir, exist_ok=True)
        filepath = os.path.join(downloads_dir, suggested_filename)

        try:
            destination_uri = GLib.filename_to_uri(filepath, None)
            download.set_destination(destination_uri)
            logger.info(f"Download destination set to: {destination_uri}")
        except GLib.Error as e:
            logger.error(f"Failed to convert file path to URI: {e.message}")
            return

        download.connect("notify::estimated-progress", lambda d, p: self.on_download_progress(d, filepath))
        download.connect("finished", lambda d: self.on_download_finished(d, filepath))
        download.connect("failed", lambda d, e: self.on_download_failed(d, e, filepath))

        self.download_manager.add_download(download, filepath, suggested_filename)
        logger.info(f"Download started: {filepath}")

    def on_download_progress(self, download, filepath):
        progress = download.get_estimated_progress() * 100
        GLib.idle_add(self.download_manager.update_progress, download, progress)
        logger.info(f"Downloading {os.path.basename(filepath)}: {int(progress)}%")

    def on_download_finished(self, download, filepath):
        GLib.idle_add(self.download_manager.update_status, download, "Completed")
        logger.info(f"Download finished: {filepath}")
        GLib.idle_add(self.show_download_complete_notification, filepath)

    def on_download_failed(self, download, error, filepath):
        GLib.idle_add(self.download_manager.update_status, download, "Failed")
        logger.error(f"Download failed for {filepath}: {error.message}")
        GLib.idle_add(self.show_download_failed_notification, filepath, error.message)

    def show_download_complete_notification(self, filepath):
        dialog = Gtk.MessageDialog(
            transient_for=self,
            modal=True,
            message_type=Gtk.MessageType.INFO,
            buttons=Gtk.ButtonsType.OK,
            text="Download Complete",
        )
        dialog.format_secondary_text(f"The file '{os.path.basename(filepath)}' has been downloaded successfully.")
        dialog.run()
        dialog.destroy()

    def show_download_failed_notification(self, filepath, error_message):
        dialog = Gtk.MessageDialog(
            transient_for=self,
            modal=True,
            message_type=Gtk.MessageType.ERROR,
            buttons=Gtk.ButtonsType.OK,
            text="Download Failed",
        )
        dialog.format_secondary_text(f"Failed to download '{os.path.basename(filepath)}'. Error: {error_message}")
        dialog.run()
        dialog.destroy()

    def on_destroy(self, widget):
        logger.info("Application closed.")
        Gtk.main_quit()
        sys.exit(0)  # Ensure the process is terminated

    def update_progress(self, progress):
        fraction = progress / 100.0
        self.progress_bar.set_fraction(fraction)
        self.progress_bar.set_text(f"{int(progress)}%")

    def add_navigation_buttons(self, header_bar):
        back_button = Gtk.Button.new_from_icon_name("go-previous", Gtk.IconSize.BUTTON)
        back_button.set_tooltip_text("Back")
        back_button.connect("clicked", self.on_back_clicked)
        header_bar.pack_start(back_button)

        forward_button = Gtk.Button.new_from_icon_name("go-next", Gtk.IconSize.BUTTON)
        forward_button.set_tooltip_text("Forward")
        forward_button.connect("clicked", self.on_forward_clicked)
        header_bar.pack_start(forward_button)

        reload_button = Gtk.Button.new_from_icon_name("view-refresh", Gtk.IconSize.BUTTON)
        reload_button.set_tooltip_text("Reload")
        reload_button.connect("clicked", self.on_reload_clicked)
        header_bar.pack_start(reload_button)

        home_button = Gtk.Button.new_from_icon_name("go-home", Gtk.IconSize.BUTTON)
        home_button.set_tooltip_text("Home")
        home_button.connect("clicked", self.on_home_clicked)
        header_bar.pack_start(home_button)

    def on_back_clicked(self, widget):
        current_page = self.get_current_page()
        if current_page and current_page.webview.can_go_back():
            current_page.webview.go_back()
            logger.info("Back button clicked.")
        else:
            logger.warning("Back button clicked but cannot navigate back.")

    def on_forward_clicked(self, widget):
        current_page = self.get_current_page()
        if current_page and current_page.webview.can_go_forward():
            current_page.webview.go_forward()
            logger.info("Forward button clicked.")
        else:
            logger.warning("Forward button clicked but cannot navigate forward.")

    def on_reload_clicked(self, widget):
        current_page = self.get_current_page()
        if current_page:
            current_page.webview.reload()
            logger.info("Reload button clicked.")
        else:
            logger.warning("Reload button clicked but no tab is open.")

    def on_home_clicked(self, widget):
        current_page = self.get_current_page()
        if current_page:
            current_page.webview.load_uri(self.homepage)
            logger.info(f"Navigated to home page: {self.homepage}")
        else:
            logger.warning("Home button clicked but no tab is open.")

    def add_bookmark_buttons(self, header_bar):
        bookmark_button = Gtk.Button.new_from_icon_name("bookmark-new", Gtk.IconSize.BUTTON)
        bookmark_button.set_tooltip_text("Bookmark this page")
        bookmark_button.connect("clicked", self.on_add_bookmark)
        header_bar.pack_end(bookmark_button)

        view_bookmarks_button = Gtk.Button.new_from_icon_name("emblem-favorite", Gtk.IconSize.BUTTON)
        view_bookmarks_button.set_tooltip_text("View Bookmarks")
        view_bookmarks_button.connect("clicked", self.on_view_bookmarks)
        header_bar.pack_end(view_bookmarks_button)

    def on_new_tab(self, widget=None):
        new_tab = BrowserTab(self)
        self.notebook.set_current_page(self.notebook.page_num(new_tab))
        logger.info("New tab opened.")

    def on_close_tab(self, widget=None):
        current_page_num = self.notebook.get_current_page()
        total_pages = self.notebook.get_n_pages()

        if total_pages <= 1:
            self.destroy()
            logger.info("Last tab closed. Application window destroyed.")
        else:
            page = self.notebook.get_nth_page(current_page_num)
            if isinstance(page, BrowserTab):
                self.close_tab(widget, page)
                logger.info("Tab closed.")
            else:
                logger.error("Current page is not a BrowserTab instance.")

    def on_enter_address(self, entry):
        raw_input = entry.get_text().strip()
        current_page = self.get_current_page()
        if current_page:
            if self.is_probable_url(raw_input):
                url = self.format_url(raw_input)
            else:
                query = quote_plus(raw_input)
                url = f"https://www.duckduckgo.com/?q={query}"
            current_page.webview.load_uri(url)
            logger.info(f"Navigating to: {url}")

    def is_probable_url(self, text):
        return bool(self.PROBABLE_URL_REGEX.match(text))

    def format_url(self, url):
        parsed = urlparse(url)
        if not parsed.scheme:
            return f"https://{url}"
        return url

    def on_key_press(self, widget, event):
        if event.state & Gdk.ModifierType.CONTROL_MASK and event.keyval == Gdk.KEY_Return:
            self.handle_ctrl_enter()
            return True
        return False

    def handle_ctrl_enter(self):
        domain = self.address_bar.get_text().strip()
        domain = self.ensure_tld(domain)
        url = self.format_url(domain)
        GLib.idle_add(self.navigate_to, url)
        logger.info(f"Control+Enter pressed. Navigating to: {url}")

    def navigate_to(self, url):
        logger.info(f"Navigating to URL: {url}")
        current_page = self.get_current_page()
        if current_page:
            current_page.webview.load_uri(url)

    def on_print_page(self, widget):
        current_page = self.get_current_page()
        if current_page:
            current_page.print_page()
            logger.info("Print page initiated.")
        else:
            logger.warning("Print button clicked but no tab is open.")

    def get_current_page(self):
        page_num = self.notebook.get_current_page()
        page = self.notebook.get_nth_page(page_num)
        if isinstance(page, BrowserTab):
            return page
        return None

    def on_add_bookmark(self, widget):
        current_page = self.get_current_page()
        if current_page:
            uri = current_page.webview.get_uri()
            if uri and uri not in self.bookmarks:
                self.bookmarks.append(uri)
                self.save_bookmarks()
                logger.info(f"Added bookmark: {uri}")
            else:
                logger.info(f"Bookmark already exists or URI is invalid: {uri}")

    def on_view_bookmarks(self, widget):
        dialog = Gtk.Dialog(
            title="Bookmarks",
            transient_for=self,
            modal=True,
            destroy_with_parent=True
        )
        dialog.set_default_size(400, 300)
        dialog.add_buttons(Gtk.STOCK_CLOSE, Gtk.ResponseType.CLOSE)

        content_area = dialog.get_content_area()

        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        content_area.pack_start(scrolled_window, True, True, 0)

        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        scrolled_window.add(vbox)

        for bookmark in self.bookmarks:
            hbox = Gtk.Box(spacing=6)

            bookmark_label = Gtk.Label(label=bookmark)
            bookmark_label.set_xalign(0)
            bookmark_label.set_hexpand(True)
            bookmark_label.set_ellipsize(Pango.EllipsizeMode.END)
            bookmark_label.set_selectable(True)
            bookmark_label.add_events(Gdk.EventMask.BUTTON_PRESS_MASK)

            bookmark_label.connect("button-press-event", self.on_bookmark_open, bookmark, dialog)

            bookmark_label.connect("enter-notify-event", self.on_label_hover_enter)
            bookmark_label.connect("leave-notify-event", self.on_label_hover_leave)

            remove_button = Gtk.Button.new_from_icon_name("edit-delete", Gtk.IconSize.BUTTON)
            remove_button.set_tooltip_text("Remove Bookmark")
            remove_button.connect("clicked", self.on_remove_bookmark, dialog, bookmark)
            hbox.pack_start(bookmark_label, True, True, 0)
            hbox.pack_start(remove_button, False, False, 0)
            vbox.pack_start(hbox, False, False, 0)

        vbox.show_all()
        dialog.show_all()
        response = dialog.run()
        if response == Gtk.ResponseType.CLOSE:
            dialog.destroy()
            logger.info("Bookmarks dialog closed.")

    def on_bookmark_open(self, widget, event, uri, dialog):
        if event.button == 1:
            new_tab = BrowserTab(self)
            new_tab.webview.load_uri(uri)
            new_tab.highlight_tab()
            self.notebook.set_current_page(self.notebook.page_num(new_tab))
            dialog.destroy()
            logger.info(f"Opened bookmark in new tab and closed bookmarks dialog: {uri}")

    def on_remove_bookmark(self, widget, dialog, bookmark):
        if bookmark in self.bookmarks:
            self.bookmarks.remove(bookmark)
            self.save_bookmarks()
            logger.info(f"Removed bookmark: {bookmark}")
            dialog.hide()
            self.on_view_bookmarks(None)

    def save_bookmarks(self):
        try:
            os.makedirs(os.path.dirname(self.bookmarks_file), exist_ok=True)
            with open(self.bookmarks_file, 'w') as f:
                json.dump(self.bookmarks, f, indent=4)
            logger.info("Bookmarks saved successfully.")
        except Exception as e:
            logger.error(f"Failed to save bookmarks: {e}")

    def load_bookmarks(self):
        if os.path.exists(self.bookmarks_file):
            try:
                with open(self.bookmarks_file, 'r') as f:
                    self.bookmarks = json.load(f)
                logger.info("Bookmarks loaded successfully.")
            except Exception as e:
                logger.error(f"Failed to load bookmarks: {e}")

    def on_switch_page(self, notebook, page, page_num):
        current_page = self.notebook.get_nth_page(page_num)
        if isinstance(current_page, BrowserTab):
            uri = current_page.webview.get_uri()
            if uri is not None:  # Check if URI is not None before updating address bar
                self.update_address_bar(uri)
                logger.info(f"Switched to tab with URI: {uri}")

    def update_address_bar(self, uri):
        if uri is not None and self.address_bar.get_text() != uri:
            self.address_bar.set_text(uri)
            logger.info(f"Address bar updated to: {uri}")

    def on_label_hover_enter(self, widget, event):
        window = widget.get_window()
        if window:
            cursor = Gdk.Cursor.new(Gdk.CursorType.HAND2)
            window.set_cursor(cursor)

    def on_label_hover_leave(self, widget, event):
        window = widget.get_window()
        if window:
            window.set_cursor(None)

    def on_view_downloads(self, widget):
        self.download_manager.show_all()
        logger.info("Opened Download Manager.")

if __name__ == '__main__':
    browser = SimpleBrowser()
    browser.show_all()
    Gtk.main()