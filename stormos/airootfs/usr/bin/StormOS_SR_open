#!/usr/bin/env python3

import gi
import subprocess
import time
import re
import os
import threading
import signal
import math
import atexit
import logging
import sys
import select
import fcntl
from pynput import keyboard

gi.require_version('Gtk', '3.0')
gi.require_version('AppIndicator3', '0.1')
gi.require_version('Gst', '1.0')
from gi.repository import Gtk, Gdk, GLib, AppIndicator3, Gst, GdkX11

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Create a unique lock file
lock_file_path = '/tmp/screen_recorder_indicator.lock'
lock_file = open(lock_file_path, 'w')

try:
    # Try to acquire the lock
    fcntl.flock(lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
except IOError:
    # If the lock is already held by another process, exit
    print("Another instance of the application is already running.")
    sys.exit(1)

# Ensure the lock is released on exit
def release_lock():
    fcntl.flock(lock_file, fcntl.LOCK_UN)
    lock_file.close()
    os.remove(lock_file_path)

atexit.register(release_lock)

def ensure_even_dimensions(width, height):
    if width % 2 != 0:
        width += 1
    if height % 2 != 0:
        height += 1
    return width, height

class HotkeyManager:
    def __init__(self, recorder):
        self.recorder = recorder
        self.hotkeys = {
            '<ctrl>+<alt>+r': self.start_recording,
            '<ctrl>+<alt>+s': self.stop_recording,
            '<ctrl>+<alt>+p': self.pause_recording,
            '<ctrl>+<alt>+e': self.resume_recording,
        }
        self.listener = None
        self.setup_hotkeys()

    def start_recording(self):
        GLib.idle_add(self.recorder.start_recording, None)

    def stop_recording(self):
        GLib.idle_add(self.recorder.stop_recording, None)

    def pause_recording(self):
        GLib.idle_add(self.recorder.pause_recording, None)

    def resume_recording(self):
        GLib.idle_add(self.recorder.resume_recording, None)

    def on_press(self, key):
        try:
            if key.char:
                return
        except AttributeError:
            pass

        if key in self.hotkeys:
            self.hotkeys[key]()

    def setup_hotkeys(self):
        self.listener = keyboard.Listener(on_press=self.on_press)
        self.listener.start()
    
    def stop_listener(self):
        if self.listener:
            self.listener.stop()

class ScreenPreview(Gtk.Window):
    def __init__(self):
        super().__init__(title="Screen Preview")
        self.set_default_size(800, 600)
        Gst.init(None)
        self.pipeline = Gst.Pipeline()
        self.src = self.create_element("ximagesrc", "src")
        self.video_convert = self.create_element("videoconvert", "video_convert")
        self.sink = self.create_element("gtksink", "sink")
        if not all([self.src, self.video_convert, self.sink]):
            print("Not all elements could be created. Exiting.")
            return
        self.pipeline.add(self.src)
        self.pipeline.add(self.video_convert)
        self.pipeline.add(self.sink)
        self.src.link(self.video_convert)
        self.video_convert.link(self.sink)
        self.video_widget = self.sink.get_property("widget")
        self.add(self.video_widget)
        self.connect("realize", self.on_realize)
        self.connect("configure-event", self.on_configure)
        self.x = self.y = self.width = self.height = 0

    def on_realize(self, widget):
        self.start_preview()

    def on_configure(self, widget, event):
        window = self.get_window()
        if window:
            self.x, self.y, self.width, self.height = window.get_geometry()
            screen_width = Gdk.Screen.width()
            screen_height = Gdk.Screen.height()
            self.src.set_property("startx", 0)
            self.src.set_property("starty", 0)
            self.src.set_property("endx", screen_width)
            self.src.set_property("endy", screen_height)
            self.src.set_property("show-pointer", False)

    def start_preview(self):
        self.pipeline.set_state(Gst.State.PLAYING)

    def stop_preview(self):
        self.pipeline.set_state(Gst.State.NULL)

    def create_element(self, factory_name, name):
        element = Gst.ElementFactory.make(factory_name, name)
        if not element:
            print(f"Failed to create element {name} of type {factory_name}")
        return element

class ScreenRecorder(Gtk.Window):
    def __init__(self):
        super().__init__(title="StormOS Screen Recorder")
        self.set_default_size(600, 450)
        self.connect("destroy", Gtk.main_quit)

        # Save a reference to the main window
        self.main_window = self

        self.output_directory = os.path.join(os.path.expanduser('~'), 'Videos')
        self.temp_directory = os.path.join(self.output_directory, 'temp')
        os.makedirs(self.output_directory, exist_ok=True)
        os.makedirs(self.temp_directory, exist_ok=True)

        self.is_recording = False
        self.is_paused = False
        self.start_time = 0
        self.output_filename = None
        self.ffmpeg_process = None
        self.file_size = 0
        self.custom_region_start_x = None
        self.custom_region_start_y = None
        self.custom_region_end_x = None
        self.custom_region_end_y = None
        self.recording_region = None
        self.completed_recordings = []
        self.recent_recording_menu_item = None
        self.preview_window = None
        self.camera_window = None
        self.camera_window_id = None

        self.is_camera_on_top = False
        self.is_webcam_overlay = False  # New variable for webcam overlay
        self.webcam_position = "top-right"  # Default position

        self.is_journal_mode = False  # Initialize journaling mode
        self.is_keep_mode = False  # Add missing initialization

        atexit.register(self.cleanup_on_exit)

        signal.signal(signal.SIGINT, self.cleanup_on_exit)
        signal.signal(signal.SIGTERM, self.cleanup_on_exit)

        notebook = Gtk.Notebook()
        notebook.set_tab_pos(Gtk.PositionType.LEFT)  # Set the tabs to be on the left
        self.add(notebook)

        # Create settings page
        settings_grid = Gtk.Grid()
        settings_grid.set_column_spacing(10)
        settings_grid.set_row_spacing(10)

        self.audio_input_configs = ["Primary Only", "Secondary Only", "Both"]
        self.audio_input_config_label = Gtk.Label(label="Select Audio Input Configuration:")
        settings_grid.attach(self.audio_input_config_label, 0, 0, 1, 1)
        self.audio_input_config_combo = Gtk.ComboBoxText()
        for config in self.audio_input_configs:
            self.audio_input_config_combo.append_text(config)
        self.audio_input_config_combo.set_active(0)
        self.audio_input_config_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.audio_input_config_combo, 1, 0, 1, 1)

        self.recording_sizes = self.get_available_resolutions()
        if not self.recording_sizes:
            self.recording_sizes = [
                ("1920x1080", "1920x1080"),
                ("1280x720", "1280x720"),
                ("640x480", "640x480"),
                ("2560x1440", "2560x1440"),
                ("3840x2160", "3840x2160")
            ]
        self.recording_size_label = Gtk.Label(label="Select Recording Size:")
        settings_grid.attach(self.recording_size_label, 0, 1, 1, 1)
        self.recording_size_combo = Gtk.ComboBoxText()
        for size in self.recording_sizes:
            self.recording_size_combo.append_text(size[0])
        self.recording_size_combo.set_active(0)
        self.recording_size_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.recording_size_combo, 1, 1, 1, 1)

        self.video_codec_label = Gtk.Label(label="Select Video Codec:")
        settings_grid.attach(self.video_codec_label, 0, 2, 1, 1)
        self.video_codec_combo = Gtk.ComboBoxText()
        self.video_codecs = ["libx264", "libvpx-vp9", "libx265", "libvpx"]
        for codec in self.video_codecs:
            self.video_codec_combo.append_text(codec)
        self.video_codec_combo.set_active(0)
        self.video_codec_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.video_codec_combo, 1, 2, 1, 1)

        self.audio_codec_label = Gtk.Label(label="Select Audio Codec:")
        settings_grid.attach(self.audio_codec_label, 0, 3, 1, 1)
        self.audio_codec_combo = Gtk.ComboBoxText()
        self.audio_codecs = ["aac", "mp3", "opus"]
        for codec in self.audio_codecs:
            self.audio_codec_combo.append_text(codec)
        self.audio_codec_combo.set_active(0)
        self.audio_codec_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.audio_codec_combo, 1, 3, 1, 1)

        self.audio_input_label = Gtk.Label(label="Select Primary Audio Input:")
        settings_grid.attach(self.audio_input_label, 0, 4, 1, 1)
        self.audio_input_combo = Gtk.ComboBoxText()
        self.audio_inputs = self.get_available_audio_inputs()
        for input_device in self.audio_inputs:
            self.audio_input_combo.append_text(input_device)
        self.audio_input_combo.set_active(0)
        self.audio_input_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.audio_input_combo, 1, 4, 1, 1)

        self.secondary_audio_input_label = Gtk.Label(label="Select Secondary Audio Input:")
        settings_grid.attach(self.secondary_audio_input_label, 0, 5, 1, 1)
        self.secondary_audio_input_combo = Gtk.ComboBoxText()
        self.secondary_audio_inputs = self.get_available_audio_inputs()
        for input_device in self.secondary_audio_inputs:
            self.secondary_audio_input_combo.append_text(input_device)
        self.secondary_audio_input_combo.set_active(0)
        self.secondary_audio_input_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.secondary_audio_input_combo, 1, 5, 1, 1)

        self.recording_area_label = Gtk.Label(label="Select Recording Area:")
        settings_grid.attach(self.recording_area_label, 0, 6, 1, 1)
        self.recording_area_combo = Gtk.ComboBoxText()
        self.recording_areas = ["Full Screen", "Camera Only", "Active Window", "Custom Region"]
        for area in self.recording_areas:
            self.recording_area_combo.append_text(area)
        self.recording_area_combo.set_active(0)
        self.recording_area_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.recording_area_combo, 1, 6, 1, 1)

        self.output_format_label = Gtk.Label(label="Select Output Format:")
        settings_grid.attach(self.output_format_label, 0, 7, 1, 1)
        self.output_format_combo = Gtk.ComboBoxText()
        output_formats = ["mkv", "mp4", "webm"]
        for format in output_formats:
            self.output_format_combo.append_text(format)
        self.output_format_combo.set_active(0)
        self.output_format_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.output_format_combo, 1, 7, 1, 1)

        self.active_window_label = Gtk.Label(label="Select Active Window:")
        settings_grid.attach(self.active_window_label, 0, 8, 1, 1)
        self.active_window_combo = Gtk.ComboBoxText()
        self.update_active_windows()
        self.active_window_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.active_window_combo, 1, 8, 1, 1)

        self.capture_active_window_button = Gtk.Button(label="Capture Active Window")
        capture_icon = Gtk.Image.new_from_icon_name("document-edit", Gtk.IconSize.BUTTON)
        self.capture_active_window_button.set_image(capture_icon)
        self.capture_active_window_button.set_always_show_image(True)
        self.capture_active_window_button.connect("clicked", self.capture_active_window)
        settings_grid.attach(self.capture_active_window_button, 0, 9, 1, 1)

        self.refresh_windows_button = Gtk.Button(label="Refresh Windows")
        refresh_icon = Gtk.Image.new_from_icon_name("view-refresh", Gtk.IconSize.BUTTON)
        self.refresh_windows_button.set_image(refresh_icon)
        self.refresh_windows_button.set_always_show_image(True)
        self.refresh_windows_button.connect("clicked", self.refresh_windows)
        settings_grid.attach(self.refresh_windows_button, 1, 9, 1, 1)

        self.select_custom_region_button = Gtk.Button(label="Select Custom Region")
        custom_region_icon = Gtk.Image.new_from_icon_name("image-x-generic", Gtk.IconSize.BUTTON)
        self.select_custom_region_button.set_image(custom_region_icon)
        self.select_custom_region_button.set_always_show_image(True)
        self.select_custom_region_button.connect("clicked", self.select_custom_region)
        settings_grid.attach(self.select_custom_region_button, 0, 10, 1, 1)

        # Add journaling mode toggle
        self.journaling_mode_checkbox = Gtk.CheckButton(label="Journaling Mode")
        settings_grid.attach(self.journaling_mode_checkbox, 1, 10, 1, 1)
        self.journaling_mode_checkbox.connect("toggled", self.on_journaling_mode_toggled)

        notebook.append_page(settings_grid, Gtk.Label(label="Settings"))

        # Create controls, camera, and streaming page
        controls_camera_streaming_grid = Gtk.Grid()
        controls_camera_streaming_grid.set_column_spacing(10)
        controls_camera_streaming_grid.set_row_spacing(10)

        # Controls section
        self.record_button = Gtk.Button(label="Record")
        record_icon = Gtk.Image.new_from_icon_name("media-record", Gtk.IconSize.BUTTON)
        self.record_button.set_image(record_icon)
        self.record_button.set_always_show_image(True)
        self.record_button.connect("clicked", self.start_recording)
        controls_camera_streaming_grid.attach(self.record_button, 0, 0, 1, 1)

        self.stop_button = Gtk.Button(label="Stop")
        stop_icon = Gtk.Image.new_from_icon_name("media-playback-stop", Gtk.IconSize.BUTTON)
        self.stop_button.set_image(stop_icon)
        self.stop_button.set_always_show_image(True)
        self.stop_button.connect("clicked", self.stop_recording)
        self.stop_button.set_sensitive(False)
        controls_camera_streaming_grid.attach(self.stop_button, 1, 0, 1, 1)

        self.pause_button = Gtk.Button(label="Pause")
        pause_icon = Gtk.Image.new_from_icon_name("media-playback-pause", Gtk.IconSize.BUTTON)
        self.pause_button.set_image(pause_icon)
        self.pause_button.set_always_show_image(True)
        self.pause_button.connect("clicked", self.pause_recording)
        self.pause_button.set_sensitive(False)
        controls_camera_streaming_grid.attach(self.pause_button, 0, 1, 1, 1)

        self.resume_button = Gtk.Button(label="Resume")
        resume_icon = Gtk.Image.new_from_icon_name("media-playback-start", Gtk.IconSize.BUTTON)
        self.resume_button.set_image(resume_icon)
        self.resume_button.set_always_show_image(True)
        self.resume_button.connect("clicked", self.resume_recording)
        self.resume_button.set_sensitive(False)
        controls_camera_streaming_grid.attach(self.resume_button, 1, 1, 1, 1)

        self.status_label = Gtk.Label(label="Press Record to start recording.")
        self.status_label.set_justify(Gtk.Justification.CENTER)
        self.status_label.set_halign(Gtk.Align.CENTER)
        controls_camera_streaming_grid.attach(self.status_label, 0, 2, 2, 1)

        self.play_recent_button = Gtk.Button(label="Play Recent Recording")
        recent_recording_icon = Gtk.Image.new_from_icon_name("media-playback-start", Gtk.IconSize.BUTTON)
        self.play_recent_button.set_image(recent_recording_icon)
        self.play_recent_button.set_always_show_image(True)
        self.play_recent_button.connect("clicked", self.open_recent_recording)
        controls_camera_streaming_grid.attach(self.play_recent_button, 0, 3, 1, 1)

        self.recent_recording_info_label = Gtk.Label(label="No recent recording")
        self.recent_recording_info_label.set_justify(Gtk.Justification.CENTER)
        self.recent_recording_info_label.set_halign(Gtk.Align.CENTER)
        controls_camera_streaming_grid.attach(self.recent_recording_info_label, 1, 3, 1, 1)

        self.file_size_label = Gtk.Label(label="")
        self.file_size_label.set_justify(Gtk.Justification.CENTER)
        self.file_size_label.set_halign(Gtk.Align.CENTER)
        controls_camera_streaming_grid.attach(self.file_size_label, 0, 4, 2, 1)

        # Camera section
        self.available_cameras = self.get_available_cameras_v4l2()
        self.camera_label = Gtk.Label(label="Select Camera:")
        controls_camera_streaming_grid.attach(self.camera_label, 0, 5, 1, 1)
        self.camera_combo = Gtk.ComboBoxText()
        for camera in self.available_cameras:
            self.camera_combo.append_text(camera)
        self.camera_combo.set_active(0)
        controls_camera_streaming_grid.attach(self.camera_combo, 1, 5, 1, 1)

        self.camera_resolution_label = Gtk.Label(label="Select Camera Resolution:")
        controls_camera_streaming_grid.attach(self.camera_resolution_label, 0, 6, 1, 1)
        self.camera_resolution_combo = Gtk.ComboBoxText()
        camera_resolutions = ["480x320", "640x480", "1280x720", "1920x1080"]
        for resolution in camera_resolutions:
            self.camera_resolution_combo.append_text(resolution)
        self.camera_resolution_combo.set_active(0)
        self.camera_resolution_combo.connect("changed", self.on_combobox_changed)
        controls_camera_streaming_grid.attach(self.camera_resolution_combo, 1, 6, 1, 1)

        self.camera_button = Gtk.Button(label="Show Camera")
        camera_icon = Gtk.Image.new_from_icon_name("camera-photo", Gtk.IconSize.BUTTON)
        self.camera_button.set_image(camera_icon)
        self.camera_button.set_always_show_image(True)
        self.camera_button.connect("clicked", self.show_camera_window)
        controls_camera_streaming_grid.attach(self.camera_button, 0, 7, 1, 1)

        self.close_camera_button = Gtk.Button(label="Close Camera")
        close_camera_icon = Gtk.Image.new_from_icon_name("window-close", Gtk.IconSize.BUTTON)
        self.close_camera_button.set_image(close_camera_icon)
        self.close_camera_button.set_always_show_image(True)
        self.close_camera_button.connect("clicked", self.close_camera_window)
        controls_camera_streaming_grid.attach(self.close_camera_button, 1, 7, 1, 1)

        self.keep_camera_on_top_checkbox = Gtk.CheckButton(label="Keep Camera on Top")
        controls_camera_streaming_grid.attach(self.keep_camera_on_top_checkbox, 0, 8, 1, 1)
        self.keep_camera_on_top_checkbox.connect("toggled", self.on_keep_camera_on_top_toggled)

        self.show_screen_preview_checkbox = Gtk.CheckButton(label="Show Screen Preview")
        controls_camera_streaming_grid.attach(self.show_screen_preview_checkbox, 0, 9, 1, 1)
        self.show_screen_preview_checkbox.connect("toggled", self.on_show_screen_preview_toggled)

        # Add webcam overlay checkbox
        self.webcam_overlay_checkbox = Gtk.CheckButton(label="Enable Webcam Overlay")
        controls_camera_streaming_grid.attach(self.webcam_overlay_checkbox, 0, 10, 1, 1)
        self.webcam_overlay_checkbox.connect("toggled", self.on_webcam_overlay_toggled)

        # Add webcam position selection
        self.webcam_position_label = Gtk.Label(label="Select Webcam Position:")
        controls_camera_streaming_grid.attach(self.webcam_position_label, 0, 11, 1, 1)
        self.webcam_position_combo = Gtk.ComboBoxText()
        webcam_positions = ["top-left", "top-right", "bottom-left", "bottom-right"]
        for position in webcam_positions:
            self.webcam_position_combo.append_text(position)
        self.webcam_position_combo.set_active(1)  # Default to top-right
        self.webcam_position_combo.connect("changed", self.on_combobox_changed)
        controls_camera_streaming_grid.attach(self.webcam_position_combo, 1, 11, 1, 1)

        # Streaming section
        self.streaming_label = Gtk.Label(label="Streaming Options:")
        controls_camera_streaming_grid.attach(self.streaming_label, 0, 12, 1, 1)
        self.streaming_combo = Gtk.ComboBoxText()
        streaming_options = ["None", "Twitch", "YouTube"]
        for option in streaming_options:
            self.streaming_combo.append_text(option)
        self.streaming_combo.set_active(0)
        self.streaming_combo.connect("changed", self.on_combobox_changed)
        controls_camera_streaming_grid.attach(self.streaming_combo, 1, 12, 1, 1)

        self.streaming_key_label = Gtk.Label(label="Streaming Key:")
        controls_camera_streaming_grid.attach(self.streaming_key_label, 0, 13, 1, 1)
        self.streaming_key_entry = Gtk.Entry()
        controls_camera_streaming_grid.attach(self.streaming_key_entry, 1, 13, 1, 1)

        notebook.append_page(controls_camera_streaming_grid, Gtk.Label(label="Controls & Streaming"))

        # Add about page
        about_page = Gtk.Grid()
        about_page.set_column_spacing(10)
        about_page.set_row_spacing(10)

        about_label = Gtk.Label(label="StormOS Screen Recorder\nVersion 1.0\n\nA powerful and easy-to-use screen recording application.")
        about_label.set_justify(Gtk.Justification.CENTER)
        about_page.attach(about_label, 0, 0, 1, 1)

        author_label = Gtk.Label(label="Authors:\nThe Seeker\nBen StormOS Dev (Tester/Contributor)\nRicki aka YughioMaster88 (Tester/Contributor)\nFishman aka Pescado (Tester/Contributor)")
        author_label.set_justify(Gtk.Justification.LEFT)
        about_page.attach(author_label, 0, 1, 1, 1)

        notes_text = (
            "Notes:\n"
            "1. Ensure you have sufficient disk space before recording.\n"
            "2. For best performance, close unnecessary applications.\n"
            "3. If you encounter any issues, please report them to the StormOS Project Team.\n"
            "4. Also please remember this program is a Work In Progress.\n"
            "5. Hotkeys: Ctrl+Alt+R to start recording, Ctrl+Alt+S to stop recording, Ctrl+Alt+P to pause recording, Ctrl+Alt+E to resume recording"
        )
        notes_label = Gtk.Label(label=notes_text)
        notes_label.set_justify(Gtk.Justification.LEFT)
        about_page.attach(notes_label, 0, 2, 1, 1)

        notebook.append_page(about_page, Gtk.Label(label="About Us"))

        self.show_all()
        self.create_tray_icon()
        self.update_tray_tooltip()  # Add this line to initialize the tooltip with the current settings

        # Set up hotkeys
        self.setup_hotkeys()

    def on_journaling_mode_toggled(self, button):
        self.is_journal_mode = button.get_active()


    def get_available_resolutions(self):
        try:
            output = subprocess.check_output(['xrandr']).decode('utf-8')
            resolutions = re.findall(r'(\d+x\d+)\s+\d+\.\d+\*', output)
            return [(res, res) for res in resolutions]
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting available resolutions: {e}")
            return []

    def get_available_audio_inputs(self):
        try:
            output = subprocess.check_output(['pactl', 'list', 'sources']).decode('utf-8')
            inputs = re.findall(r'Name: (.+)', output)
            return inputs
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting available audio inputs: {e}")
            return []

    def get_active_windows(self):
        try:
            output = subprocess.check_output(['wmctrl', '-l']).decode('utf-8')
            windows = re.findall(r'0x[0-9a-fA-F]+\s+\d+\s+\S+\s+(.+)', output)
            return windows
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting active windows: {e}")
            return []

    def update_active_windows(self):
        self.active_window_combo.remove_all()
        active_windows = self.get_active_windows()
        for window in active_windows:
            self.active_window_combo.append_text(window)
        self.active_window_combo.set_active(0)

    def refresh_windows(self, widget):
        self.update_active_windows()
        self.status_label.set_text("Window list refreshed.")

    def cleanup_on_exit(self, signum=None, frame=None):
        if self.ffmpeg_process:
            try:
                self.ffmpeg_process.terminate()
                self.ffmpeg_process.wait(timeout=20)
            except subprocess.TimeoutExpired:
                logging.warning("FFmpeg process termination timed out. Attempting to kill with pkill...")
                try:
                    subprocess.run(['pkill', '-f', 'ffmpeg'])
                except Exception as e:
                    logging.error(f"Error killing FFmpeg process with pkill: {e}")
            except Exception as e:
                logging.error(f"Error terminating FFmpeg process: {e}")
            finally:
                self.ffmpeg_process = None

        try:
            subprocess.run(['pkill', '-f', 'ffplay'])
        except Exception as e:
            logging.error(f"Error closing ffplay windows: {e}")

        if hasattr(self, 'indicator') and self.indicator:
            self.indicator.set_status(AppIndicator3.IndicatorStatus.PASSIVE)
            del self.indicator

        if Gtk.main_level() > 0:
            Gtk.main_quit()

        if self.preview_window:
            self.preview_window.stop_preview()
            self.preview_window.destroy()

    def ensure_even_dimensions(width, height):
        if width % 2 != 0:
            width += 1
        if height % 2 != 0:
            height += 1
        return width, height

    def get_screen_resolution(self):
        try:
            output = subprocess.check_output(['xrandr']).decode('utf-8')
            match = re.search(r'current (\d+) x (\d+)', output)
            if match:
                return int(match.group(1)), int(match.group(2))
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting screen resolution: {e}")
        return 1920, 1080  # Default to 1920x1080 if resolution cannot be determined

    def calculate_webcam_size(self, screen_width, screen_height):
        # Calculate webcam overlay size as a proportion of screen resolution (e.g., 20%)
        webcam_width = int(screen_width * 0.2)
        webcam_height = int(screen_height * 0.2)
        return ensure_even_dimensions(webcam_width, webcam_height)

    def start_recording(self, widget):
        if not self.is_recording:
            self.is_recording = True
            self.start_time = time.time()
            self.status_label.set_text("Recording...")
            self.record_button.set_sensitive(False)
            self.stop_button.set_sensitive(True)
            self.pause_button.set_sensitive(True)
            self.resume_button.set_sensitive(False)
            self.file_size = 0

            selected_size = self.recording_size_combo.get_active_text()
            selected_output_format = ["mkv", "mp4", "webm"][self.output_format_combo.get_active()]
            selected_recording_area = self.recording_areas[self.recording_area_combo.get_active()]
            selected_video_codec = self.video_codecs[self.video_codec_combo.get_active()]
            selected_audio_codec = self.audio_codecs[self.audio_codec_combo.get_active()]
            selected_audio_config = self.audio_input_configs[self.audio_input_config_combo.get_active()]
            selected_streaming_service = self.streaming_combo.get_active_text()
            streaming_key = self.streaming_key_entry.get_text()

            if selected_size is None:
                self.status_label.set_text("Error: No recording size selected.")
                return

            if "x" in selected_size:
                width, height = map(int, selected_size.split('x'))
                width, height = ensure_even_dimensions(width, height)  # Ensure even dimensions
            else:
                self.status_label.set_text("Error: Invalid recording size.")
                return

            timestamp = time.strftime("%m-%d-%Y_%I-%M-%S%p")
            filename_prefix = "Journal" if self.is_journal_mode else "recording"
            if self.is_keep_mode:
                filename_prefix += "_keep"
            self.output_filename = os.path.join(self.output_directory, f"{filename_prefix}_{timestamp}.{selected_output_format}")

            primary_audio_input = self.audio_inputs[self.audio_input_combo.get_active()]
            secondary_audio_input = self.secondary_audio_inputs[self.secondary_audio_input_combo.get_active()]

            logging.info(f"Primary audio input: {primary_audio_input}")
            logging.info(f"Secondary audio input: {secondary_audio_input}")

            input_args = [
                "-probesize", "500M", "-analyzeduration", "100M",
                "-thread_queue_size", "1024",
            ]

            if selected_recording_area == "Full Screen":
                input_args += ["-video_size", f"{width}x{height}", "-framerate", "30", "-f", "x11grab", "-i", ":0.0"]
            elif selected_recording_area == "Camera Only":
                selected_camera = self.camera_combo.get_active_text()
                if selected_camera:
                    camera_index = int(selected_camera.split(" ")[1])
                    device = f"/dev/video{camera_index}"
                    resolution = self.camera_resolution_combo.get_active_text()
                    input_args += ["-f", "v4l2", "-video_size", resolution, "-i", device]
                    input_args += ["-f", "alsa", "-itsoffset", "0.9", "-i", "hw:1"]
            elif selected_recording_area == "Active Window":
                selected_window = self.active_window_combo.get_active_text()
                if selected_window:
                    window_info = self.get_window_info_by_name(selected_window)
                    if window_info:
                        x_pos, y_pos, width, height = window_info
                        width, height = ensure_even_dimensions(width, height)
                        input_args += ["-video_size", f"{width}x{height}", "-framerate", "30", "-f", "x11grab", "-i", f":0.0+{x_pos},{y_pos}"]
            elif selected_recording_area == "Custom Region":
                if self.recording_region:
                    x, y, w, h = self.recording_region
                    w, h = ensure_even_dimensions(w, h)
                    input_args += ["-video_size", f"{w}x{h}", "-framerate", "30", "-f", "x11grab", "-i", f":0.0+{x},{y}"]
                else:
                    self.status_label.set_text("Error: No custom region selected.")
                    return
            else:
                w, h = ensure_even_dimensions(self.custom_region_end_x - self.custom_region_start_x, self.custom_region_end_y - self.custom_region_start_y)
                input_args += ["-video_size", f"{w}x{h}", "-framerate", "30", "-f", "x11grab", "-i", f":0.0+{self.custom_region_start_x},{self.custom_region_start_y}"]

            # Conditional filters based on audio codec
            if selected_audio_codec == "aac":
                audio_filters = "aresample=async=1:min_hard_comp=0.100000:first_pts=0, volume=1.5, equalizer=f=1000:t=q:w=1:g=-5"
            else:
                audio_filters = "aresample=async=1:min_hard_comp=0.100000:first_pts=0"

            audio_args = []

            if selected_audio_config == "Primary Only":
                audio_args += ["-f", "pulse", "-itsoffset", "0.9", "-i", primary_audio_input, "-af", audio_filters]
            elif selected_audio_config == "Secondary Only":
                audio_args += ["-f", "pulse", "-itsoffset", "0.9", "-i", secondary_audio_input, "-af", audio_filters]
            else:  # Both
                audio_args += [
                    "-f", "pulse", "-itsoffset", "0.9", "-i", primary_audio_input,
                    "-f", "pulse", "-itsoffset", "0.9", "-i", secondary_audio_input,
                    "-filter_complex", f"[0:a][1:a]amerge=inputs=2,{audio_filters}[aout]"
                ]
                audio_args += ["-map", "[aout]"]

            buffer_args = ["-bufsize", "750M", "-rtbufsize", "750M"]

            sync_args = ["-vsync", "1", "-async", "1"]

            if self.is_webcam_overlay:
                selected_camera = self.camera_combo.get_active_text()
                if selected_camera:
                    camera_index = int(selected_camera.split(" ")[1])
                    webcam_device = f"/dev/video{camera_index}"
                    webcam_resolution = self.camera_resolution_combo.get_active_text()

                    screen_width, screen_height = self.get_screen_resolution()
                    webcam_width, webcam_height = self.calculate_webcam_size(screen_width, screen_height)

                    input_args += ["-f", "v4l2", "-video_size", f"{webcam_width}x{webcam_height}", "-itsoffset", "0.7", "-i", webcam_device]

                    filter_args = [
                        "-filter_complex", f"[0:v][1:v]overlay={self.get_webcam_position(width, height)}"
                    ]
                else:
                    self.status_label.set_text("Error: No webcam selected.")
                    return
            else:
                filter_args = []

            if selected_streaming_service == "None":
                output_args = ["-c:v", selected_video_codec, "-c:a", selected_audio_codec, "-preset", "ultrafast", "-crf", "23", "-b:v", "5M", "-maxrate", "5M", "-bufsize", "10M", "-b:a", "320k", self.output_filename]
            elif selected_streaming_service == "Twitch":
                output_args = ["-f", "flv", f"rtmp://live.twitch.tv/app/{streaming_key}"]
            elif selected_streaming_service == "YouTube":
                output_args = ["-f", "flv", f"rtmp://a.rtmp.youtube.com/live2/{streaming_key}"]
            else:
                self.status_label.set_text("Error: Invalid streaming service selected.")
                return

            command = [
                "ffmpeg", "-y",
                *input_args,
                *audio_args,
                *buffer_args,
                *sync_args,
                *filter_args,
                *output_args
            ]

            logging.info(f"FFmpeg command: {' '.join(command)}")

            threading.Thread(target=self.start_ffmpeg_process, args=(command,)).start()
            threading.Thread(target=self.monitor_file_size).start()
            threading.Thread(target=self.update_tray_info).start()
            threading.Thread(target=self.update_tray_tooltip_continuously).start()
            self.update_tray_status(True)

    def get_webcam_position(self, width, height):
        position = self.webcam_position_combo.get_active_text()
        if position == "top-left":
            return "10:10"
        elif position == "top-right":
            return f"{width - width // 4 - 10}:10"
        elif position == "bottom-left":
            return f"10:{height - height // 4 - 10}"
        elif position == "bottom-right":
            return f"{width - width // 4 - 10}:{height - height // 4 - 10}"
        else:
            return "10:10"  # Default to top-left if position is not recognized

    def start_ffmpeg_process(self, command):
        try:
            self.ffmpeg_process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            self.monitor_ffmpeg_output()
            self.ffmpeg_process.wait()
        except Exception as e:
            logging.error(f"Error starting FFmpeg process: {e}")
        finally:
            self.is_recording = False
            GLib.idle_add(self.update_status, "Recording stopped.")

    def monitor_ffmpeg_output(self):
        if self.ffmpeg_process:
            while self.ffmpeg_process.poll() is None:
                rlist, _, _ = select.select([self.ffmpeg_process.stdout, self.ffmpeg_process.stderr], [], [])
                for stream in rlist:
                    output = stream.readline()
                    if output:
                        print(output.strip().decode('utf-8'))

    def pause_recording(self, widget):
        if self.is_recording and not self.is_paused:
            if self.ffmpeg_process:
                self.ffmpeg_process.send_signal(signal.SIGSTOP)
                self.is_paused = True
                self.status_label.set_text("Recording paused.")
                self.update_tray_status(paused=True)
                self.pause_button.set_sensitive(False)
                self.resume_button.set_sensitive(True)

    def resume_recording(self, widget):
        if self.is_recording and self.is_paused:
            if self.ffmpeg_process:
                self.ffmpeg_process.send_signal(signal.SIGCONT)
                self.is_paused = False
                self.status_label.set_text("Recording resumed.")
                self.update_tray_status(resumed=True)
                self.pause_button.set_sensitive(True)
                self.resume_button.set_sensitive(False)

    def update_status(self, status_text):
        self.status_label.set_text(status_text)
        self.record_button.set_sensitive(True)
        self.stop_button.set_sensitive(False)
        self.pause_button.set_sensitive(False)
        self.resume_button.set_sensitive(False)
        self.update_recent_recording_menu_item()
        return False

    def update_tray_info(self):
        while self.is_recording:
            file_size_text = f"File Size: {self.convert_size(self.file_size)}"
            elapsed_time = time.time() - self.start_time
            elapsed_time_text = f"Elapsed Time: {self.format_time(elapsed_time)}"
            recording_status_text = "Status: Recording..."

            if self.completed_recordings:
                sorted_recordings = sorted(self.completed_recordings, key=lambda x: x[1], reverse=True)
                most_recent_path = sorted_recordings[0][0]
                most_recent_filename = os.path.basename(most_recent_path)
                most_recent_file_size = self.convert_size(os.path.getsize(most_recent_path))
                recent_recording_text = f"Recent Recording: {most_recent_filename} ({most_recent_file_size})"
            else:
                recent_recording_text = "No recent recording"

            GLib.idle_add(self.file_size_menu_item.set_label, file_size_text)
            GLib.idle_add(self.elapsed_time_menu_item.set_label, elapsed_time_text)
            GLib.idle_add(self.recording_status_menu_item.set_label, recording_status_text)
            GLib.idle_add(self.recent_recording_menu_item.set_label, recent_recording_text)

            time.sleep(1)

    def update_tray_status(self, recording=False, paused=False, resumed=False, duration=None, file_size=None):
        if recording:
            status = "Recording..."
            icon_name = "media-record"
            if duration is not None:
                status += f" Duration: {self.format_time(duration)}"
            if file_size is not None:
                status += f" File Size: {self.convert_size(file_size)}"
        elif paused:
            status = "Recording paused"
            icon_name = "media-playback-pause"
        elif resumed:
            status = "Recording resumed"
            icon_name = "media-record"
        else:
            status = "Not Recording"
            icon_name = "media-playback-stop"

        GLib.idle_add(self.recording_status_menu_item.set_label, status)
        GLib.idle_add(self.indicator.set_icon_full, icon_name, status)

    def update_tray_tooltip(self):
        settings = [
            f"Audio Input Config: {self.audio_input_config_combo.get_active_text()}",
            f"Recording Size: {self.recording_size_combo.get_active_text()}",
            f"Video Codec: {self.video_codec_combo.get_active_text()}",
            f"Audio Codec: {self.audio_codec_combo.get_active_text()}",
            f"Primary Audio Input: {self.audio_input_combo.get_active_text()}",
            f"Secondary Audio Input: {self.secondary_audio_input_combo.get_active_text()}",
            f"Recording Area: {self.recording_area_combo.get_active_text()}",
            f"Output Format: {self.output_format_combo.get_active_text()}",
            f"Active Window: {self.active_window_combo.get_active_text()}",
            f"Camera: {self.camera_combo.get_active_text()}",
            f"Camera Resolution: {self.camera_resolution_combo.get_active_text()}",
            f"Webcam Overlay: {'Enabled' if self.is_webcam_overlay else 'Disabled'}",
            f"Webcam Position: {self.webcam_position_combo.get_active_text()}",
            f"Streaming Service: {self.streaming_combo.get_active_text()}",
            f"Streaming Key: {'******' if self.streaming_key_entry.get_text() else 'N/A'}"
        ]

        self.static_tooltip_text = "\n".join(settings)
        self.indicator.set_title(self.static_tooltip_text)

    def update_tray_tooltip_continuously(self):
        while self.is_recording or self.is_paused:
            file_size_text = f"File Size: {self.convert_size(self.file_size)}"
            elapsed_time = time.time() - self.start_time
            elapsed_time_text = f"Elapsed Time: {self.format_time(elapsed_time)}"
            file_name_text = f"File Name: {os.path.basename(self.output_filename) if self.output_filename else 'N/A'}"
            recording_status_text = "Recording Info" if self.is_recording else "Recording Paused"
            
            tooltip_text = (
                f"{self.static_tooltip_text}\n"
                f"\n{recording_status_text}\n{file_name_text}\n{file_size_text}\n{elapsed_time_text}"
            )
            GLib.idle_add(self.indicator.set_title, tooltip_text)
            time.sleep(5)  # Update every 5 seconds

        # After the recording has stopped
        file_size_text = f"File Size: {self.convert_size(self.file_size)}"
        elapsed_time = time.time() - self.start_time
        elapsed_time_text = f"Elapsed Time: {self.format_time(elapsed_time)}"
        file_name_text = f"File Name: {os.path.basename(self.output_filename) if self.output_filename else 'N/A'}"

        tooltip_text = (
            f"{self.static_tooltip_text}\n"
            f"\nRecording Stopped\n{file_name_text}\n{file_size_text}\n{elapsed_time_text}"
        )
        GLib.idle_add(self.indicator.set_title, tooltip_text)

    def stop_recording(self, widget):
        if self.is_recording:
            self.is_recording = False
            self.status_label.set_text("Recording stopped.")
            self.record_button.set_sensitive(True)
            self.stop_button.set_sensitive(False)
            self.pause_button.set_sensitive(False)
            self.resume_button.set_sensitive(False)
            if self.ffmpeg_process:
                try:
                    self.ffmpeg_process.terminate()
                    self.ffmpeg_process.wait(timeout=20)
                except subprocess.TimeoutExpired:
                    logging.warning("FFmpeg process termination timed out. Attempting to kill with terminate()...")
                    try:
                        self.ffmpeg_process.kill()
                        self.ffmpeg_process.wait(timeout=5)
                    except subprocess.TimeoutExpired:
                        logging.error("FFmpeg process could not be killed.")
                    except Exception as e:
                        logging.error("Error killing FFmpeg process: {e}")
                except Exception as e:
                    logging.error(f"Error terminating FFmpeg process: {e}")
                finally:
                    self.ffmpeg_process = None

            self.completed_recordings.append((self.output_filename, time.time()))
            self.update_recent_recording_menu_item()
            GLib.idle_add(self.update_status, "Recording stopped.")
            self.update_tray_status(False)

    def capture_active_window(self, widget):
        window_info = self.get_active_window_info()
        if window_info:
            x_pos, y_pos, width, height = window_info
            self.custom_region_start_x = x_pos
            self.custom_region_start_y = y_pos
            self.custom_region_end_x = x_pos + width
            self.custom_region_end_y = y_pos + height
            self.recording_region = (x_pos, y_pos, width, height)
            self.status_label.set_text("Active window captured for recording.")

    def select_custom_region(self, widget=None):
        # Minimize the main window
        self.main_window.iconify()

        def run_xrectsel():
            try:
                output = subprocess.check_output(['xrectsel']).decode('utf-8').strip()
                if output:
                    match = re.match(r'(\d+)x(\d+)\+(\d+)\+(\d+)', output)
                    if match:
                        width, height, x, y = map(int, match.groups())
                        self.custom_region_start_x = x
                        self.custom_region_start_y = y
                        self.custom_region_end_x = x + width
                        self.custom_region_end_y = y + height
                        self.recording_region = (x, y, width, height)
                        GLib.idle_add(self.status_label.set_text, "Custom region selected. Recording will start now.")

                        # Add a delay of 0.9 seconds
                        time.sleep(0.9)
                        
                        # Start recording
                        GLib.idle_add(self.start_recording, None)
                    else:
                        logging.error(f"Unexpected output format: {output}")
                        GLib.idle_add(self.status_label.set_text, f"Unexpected output format: {output}")
                        return None
            except subprocess.CalledProcessError as e:
                logging.error(f"Error selecting custom region: {e}")
                GLib.idle_add(self.status_label.set_text, f"Error selecting custom region: {e}")
                return None

        # Start xrectsel in a separate thread
        threading.Thread(target=run_xrectsel).start()

    def get_active_window_info(self):
        try:
            output = subprocess.check_output(['xwininfo', '-id', self.get_active_window_id()]).decode('utf-8')
            x_pos = int(re.search(r'Absolute upper-left X:\s+(\d+)', output).group(1))
            y_pos = int(re.search(r'Absolute upper-left Y:\s+(\d+)', output).group(1))
            width = int(re.search(r'Width:\s+(\d+)', output).group(1))
            height = int(re.search(r'Height:\s+(\d+)', output).group(1))
            return (x_pos, y_pos, width, height)
        except Exception as e:
            self.status_label.set_text(f"Error getting active window info: {e}")
            return None

    def get_active_window_id(self):
        try:
            output = subprocess.check_output(['xdotool', 'getactivewindow']).decode('utf-8').strip()
            return output
        except Exception as e:
            self.status_label.set_text(f"Error getting active window ID: {e}")
            return None

    def get_window_id_by_name(self, window_name):
        try:
            output = subprocess.check_output(['wmctrl', '-l']).decode('utf-8')
            for line in output.splitlines():
                if window_name in line:
                    return line.split()[0]
            return None
        except Exception as e:
            self.status_label.set_text(f"Error getting window ID by name: {e}")
            return None

    def get_window_info_by_name(self, window_name):
        window_id = self.get_window_id_by_name(window_name)
        if window_id:
            try:
                output = subprocess.check_output(['xwininfo', '-id', window_id]).decode('utf-8')
                x_pos = int(re.search(r'Absolute upper-left X:\s+(\d+)', output).group(1))
                y_pos = int(re.search(r'Absolute upper-left Y:\s+(\d+)', output).group(1))
                width = int(re.search(r'Width:\s+(\d+)', output).group(1))
                height = int(re.search(r'Height:\s+(\d+)', output).group(1))
                return (x_pos, y_pos, width, height)
            except Exception as e:
                self.status_label.set_text(f"Error getting window info by name: {e}")
                return None
        else:
            self.status_label.set_text("Error: Window not found.")
            return None

    def monitor_file_size(self):
        start_time = time.time()
        while self.is_recording:
            time.sleep(1)
            elapsed_time = time.time() - start_time
            if self.output_filename and os.path.exists(self.output_filename):
                size = os.path.getsize(self.output_filename)
                self.file_size = size
                GLib.idle_add(self.file_size_label.set_text, f"File size: {self.convert_size(size)}")
            else:
                GLib.idle_add(self.file_size_label.set_text, "File size: N/A")
            GLib.idle_add(self.status_label.set_text, f"Recording... Elapsed time: {self.format_time(elapsed_time)}")

    def format_time(self, elapsed_time):
        minutes, seconds = divmod(elapsed_time, 60)
        hours, minutes = divmod(minutes, 60)
        return "{:02}:{:02}:{:02}".format(int(hours), int(minutes), int(seconds))

    def convert_size(self, size_bytes):
        if size_bytes == 0:
            return "0B"
        size_name = ("B", "KB", "MB", "GB", "TB")
        i = int(math.floor(math.log(size_bytes, 1024)))
        p = math.pow(1024, i)
        s = round(size_bytes / p, 2)
        return f"{s} {size_name[i]}"

    def on_webcam_overlay_toggled(self, button):
        self.is_webcam_overlay = button.get_active()

    def show_camera_window(self, widget):
        selected_camera = self.camera_combo.get_active_text()
        selected_resolution = self.camera_resolution_combo.get_active_text()
        if selected_camera:
            camera_index = int(selected_camera.split(" ")[1])
            device = f"/dev/video{camera_index}"
            resolution = selected_resolution if selected_resolution else "640x480"
            command = ['ffplay', '-f', 'v4l2', '-video_size', resolution, '-vf', 'hflip', device]

            try:
                self.camera_window = subprocess.Popen(command)
                time.sleep(0.5)
                self.bring_camera_window_to_front()
            except Exception as e:
                logging.error(f"Failed to open {device} using V4L2: {e}")

    def bring_camera_window_to_front(self):
        if self.camera_window:
            try:
                output = subprocess.check_output(['xdotool', 'search', '--pid', str(self.camera_window.pid)]).decode('utf-8').strip()
                self.camera_window_id = output.split('\n')[-1]
                subprocess.run(['xdotool', 'windowactivate', '--sync', self.camera_window_id])
                subprocess.run(['xdotool', 'windowraise', self.camera_window_id])
                if self.is_camera_on_top:
                    subprocess.run(['xdotool', 'windowfocus', '--sync', self.camera_window_id])
                    subprocess.run(['xdotool', 'windowraise', self.camera_window_id])
                    subprocess.run(['wmctrl', '-i', '-r', self.camera_window_id, '-b', 'add,above'])
                else:
                    subprocess.run(['wmctrl', '-i', '-r', self.camera_window_id, '-b', 'remove,above'])
            except Exception as e:
                logging.error(f"Failed to bring camera window to front: {e}")

    def close_camera_window(self, widget):
        command = ['pkill', '-f', 'ffplay -f v4l2']
        try:
            subprocess.run(command)
        except Exception as e:
            logging.error(f"Failed to close camera windows: {e}")

    def on_keep_camera_on_top_toggled(self, button):
        self.is_camera_on_top = button.get_active()
        self.bring_camera_window_to_front()

    def get_available_cameras_v4l2(self):
        try:
            output = subprocess.check_output(['v4l2-ctl', '--list-devices']).decode('utf-8')
            cameras = re.findall(r'/dev/video(\d+)', output)
            return [f"Camera {index}" for index in cameras]
        except Exception as e:
            logging.error(f"Error getting available cameras: {e}")
            return []

    def create_tray_icon(self):
        self.indicator = AppIndicator3.Indicator.new(
            "screen-recorder-indicator",
            "media-record",
            AppIndicator3.IndicatorCategory.APPLICATION_STATUS
        )
        self.indicator.set_status(AppIndicator3.IndicatorStatus.ACTIVE)

        menu = Gtk.Menu()

        show_item = Gtk.ImageMenuItem(label="Main/Settings Window")
        show_icon = Gtk.Image.new_from_icon_name("preferences-system", Gtk.IconSize.MENU)
        show_item.set_image(show_icon)
        show_item.connect("activate", self.show_window)
        menu.append(show_item)

        recording_area_menu = Gtk.ImageMenuItem(label="Select Recording Area")
        recording_area_icon = Gtk.Image.new_from_icon_name("video-display", Gtk.IconSize.MENU)
        recording_area_menu.set_image(recording_area_icon)
        recording_area_submenu = Gtk.Menu()

        self.recording_area_group = []
        full_screen_item = Gtk.RadioMenuItem.new_with_label_from_widget(None, "Full Screen")
        active_window_item = Gtk.RadioMenuItem.new_with_label_from_widget(full_screen_item, "Active Window")
        custom_region_item = Gtk.RadioMenuItem.new_with_label_from_widget(full_screen_item, "Custom Region")
        camera_only_item = Gtk.RadioMenuItem.new_with_label_from_widget(full_screen_item, "Camera Only")

        full_screen_item.connect("activate", self.set_recording_area, "Full Screen")
        active_window_item.connect("activate", self.set_recording_area, "Active Window")
        custom_region_item.connect("activate", self.set_recording_area, "Custom Region")
        camera_only_item.connect("activate", self.set_recording_area, "Camera Only")

        self.recording_area_group.extend([
            full_screen_item, active_window_item, custom_region_item, camera_only_item
        ])

        recording_area_submenu.append(full_screen_item)
        recording_area_submenu.append(active_window_item)
        recording_area_submenu.append(custom_region_item)
        recording_area_submenu.append(camera_only_item)

        recording_area_menu.set_submenu(recording_area_submenu)
        menu.append(recording_area_menu)

        active_window_menu = Gtk.ImageMenuItem(label="Select Active Window")
        active_window_icon = Gtk.Image.new_from_icon_name("window", Gtk.IconSize.MENU)
        active_window_menu.set_image(active_window_icon)
        active_window_submenu = Gtk.Menu()

        self.active_window_group = []
        active_windows = self.get_active_windows()
        for window in active_windows:
            item = Gtk.RadioMenuItem.new_with_label_from_widget(None if not self.active_window_group else self.active_window_group[0], window)
            item.connect("activate", self.set_active_window, window)
            self.active_window_group.append(item)
            active_window_submenu.append(item)
        active_window_menu.set_submenu(active_window_submenu)
        menu.append(active_window_menu)

        refresh_windows_item = Gtk.ImageMenuItem(label="Refresh Windows")
        refresh_icon = Gtk.Image.new_from_icon_name("view-refresh", Gtk.IconSize.MENU)
        refresh_windows_item.set_image(refresh_icon)
        refresh_windows_item.connect("activate", self.refresh_windows)
        menu.append(refresh_windows_item)

        output_format_menu = Gtk.ImageMenuItem(label="Select Output Format")
        output_format_icon = Gtk.Image.new_from_icon_name("document-save", Gtk.IconSize.MENU)
        output_format_menu.set_image(output_format_icon)
        output_format_submenu = Gtk.Menu()

        self.output_format_group = []
        mkv_item = Gtk.RadioMenuItem.new_with_label_from_widget(None, "mkv")
        mp4_item = Gtk.RadioMenuItem.new_with_label_from_widget(mkv_item, "mp4")
        webm_item = Gtk.RadioMenuItem.new_with_label_from_widget(mkv_item, "webm")
        mkv_item.set_active(True)
        mkv_item.connect("activate", self.set_output_format, "mkv")
        mp4_item.connect("activate", self.set_output_format, "mp4")
        webm_item.connect("activate", self.set_output_format, "webm")
        self.output_format_group.append(mkv_item)
        self.output_format_group.append(mp4_item)
        self.output_format_group.append(webm_item)

        output_format_submenu.append(mkv_item)
        output_format_submenu.append(mp4_item)
        output_format_submenu.append(webm_item)
        output_format_menu.set_submenu(output_format_submenu)
        menu.append(output_format_menu)

        audio_codec_menu = Gtk.ImageMenuItem(label="Select Audio Codec")
        audio_codec_icon = Gtk.Image.new_from_icon_name("audio-x-generic", Gtk.IconSize.MENU)
        audio_codec_menu.set_image(audio_codec_icon)
        audio_codec_submenu = Gtk.Menu()

        self.audio_codec_group = []
        aac_item = Gtk.RadioMenuItem.new_with_label_from_widget(None, "aac")
        mp3_item = Gtk.RadioMenuItem.new_with_label_from_widget(aac_item, "mp3")
        opus_item = Gtk.RadioMenuItem.new_with_label_from_widget(aac_item, "opus")
        aac_item.connect("activate", self.set_audio_codec, "aac")
        mp3_item.connect("activate", self.set_audio_codec, "mp3")
        opus_item.connect("activate", self.set_audio_codec, "opus")
        self.audio_codec_group.append(aac_item)
        self.audio_codec_group.append(mp3_item)
        self.audio_codec_group.append(opus_item)

        audio_codec_submenu.append(aac_item)
        audio_codec_submenu.append(mp3_item)
        audio_codec_submenu.append(opus_item)
        audio_codec_menu.set_submenu(audio_codec_submenu)
        menu.append(audio_codec_menu)

        audio_input_config_menu = Gtk.ImageMenuItem(label="Select Audio Input Configuration")
        audio_input_config_icon = Gtk.Image.new_from_icon_name("preferences-desktop-sound", Gtk.IconSize.MENU)
        audio_input_config_menu.set_image(audio_input_config_icon)
        audio_input_config_submenu = Gtk.Menu()

        self.audio_input_config_group = []
        primary_only_item = Gtk.RadioMenuItem.new_with_label_from_widget(None, "Primary Only")
        secondary_only_item = Gtk.RadioMenuItem.new_with_label_from_widget(primary_only_item, "Secondary Only")
        both_item = Gtk.RadioMenuItem.new_with_label_from_widget(primary_only_item, "Both")
        primary_only_item.connect("activate", self.set_audio_input_config, "Primary Only")
        secondary_only_item.connect("activate", self.set_audio_input_config, "Secondary Only")
        both_item.connect("activate", self.set_audio_input_config, "Both")
        self.audio_input_config_group.append(primary_only_item)
        self.audio_input_config_group.append(secondary_only_item)
        self.audio_input_config_group.append(both_item)

        audio_input_config_submenu.append(primary_only_item)
        audio_input_config_submenu.append(secondary_only_item)
        audio_input_config_submenu.append(both_item)
        audio_input_config_menu.set_submenu(audio_input_config_submenu)
        menu.append(audio_input_config_menu)

        primary_audio_input_menu = Gtk.ImageMenuItem(label="Select Primary Audio Input")
        primary_audio_input_icon = Gtk.Image.new_from_icon_name("audio-input-microphone", Gtk.IconSize.MENU)
        primary_audio_input_menu.set_image(primary_audio_input_icon)
        primary_audio_input_submenu = Gtk.Menu()

        self.primary_audio_input_group = []
        for input_device in self.audio_inputs:
            item = Gtk.RadioMenuItem.new_with_label_from_widget(None if not self.primary_audio_input_group else self.primary_audio_input_group[0], input_device)
            item.connect("activate", self.set_primary_audio_input, input_device)
            self.primary_audio_input_group.append(item)
            primary_audio_input_submenu.append(item)
        primary_audio_input_menu.set_submenu(primary_audio_input_submenu)
        menu.append(primary_audio_input_menu)

        secondary_audio_input_menu = Gtk.ImageMenuItem(label="Select Secondary Audio Input")
        secondary_audio_input_icon = Gtk.Image.new_from_icon_name("audio-input-line", Gtk.IconSize.MENU)
        secondary_audio_input_menu.set_image(secondary_audio_input_icon)
        secondary_audio_input_submenu = Gtk.Menu()

        self.secondary_audio_input_group = []
        for input_device in self.secondary_audio_inputs:
            item = Gtk.RadioMenuItem.new_with_label_from_widget(None if not self.secondary_audio_input_group else self.secondary_audio_input_group[0], input_device)
            item.connect("activate", self.set_secondary_audio_input, input_device)
            self.secondary_audio_input_group.append(item)
            secondary_audio_input_submenu.append(item)
        secondary_audio_input_menu.set_submenu(secondary_audio_input_submenu)
        menu.append(secondary_audio_input_menu)

        select_custom_region_item = Gtk.ImageMenuItem(label="Select Custom Region")
        custom_region_icon = Gtk.Image.new_from_icon_name("image-x-generic", Gtk.IconSize.MENU)
        select_custom_region_item.set_image(custom_region_icon)
        select_custom_region_item.connect("activate", self.select_custom_region)
        menu.append(select_custom_region_item)

        record_item = Gtk.ImageMenuItem(label="Record")
        record_icon = Gtk.Image.new_from_icon_name("media-record", Gtk.IconSize.MENU)
        record_item.set_image(record_icon)
        record_item.connect("activate", self.start_recording)
        menu.append(record_item)

        pause_item = Gtk.ImageMenuItem(label="Pause Recording")
        pause_icon = Gtk.Image.new_from_icon_name("media-playback-pause", Gtk.IconSize.MENU)
        pause_item.set_image(pause_icon)
        pause_item.connect("activate", self.pause_recording)
        menu.append(pause_item)

        resume_item = Gtk.ImageMenuItem(label="Resume Recording")
        resume_icon = Gtk.Image.new_from_icon_name("media-playback-start", Gtk.IconSize.MENU)
        resume_item.set_image(resume_icon)
        resume_item.connect("activate", self.resume_recording)
        menu.append(resume_item)

        stop_record_item = Gtk.ImageMenuItem(label="Stop Recording")
        stop_record_icon = Gtk.Image.new_from_icon_name("media-playback-stop", Gtk.IconSize.MENU)
        stop_record_item.set_image(stop_record_icon)
        stop_record_item.connect("activate", self.stop_recording)
        menu.append(stop_record_item)

        self.recent_recording_menu_item = Gtk.ImageMenuItem(label="No recent recording")
        recent_recording_icon = Gtk.Image.new_from_icon_name("document-open-recent", Gtk.IconSize.MENU)
        self.recent_recording_menu_item.set_image(recent_recording_icon)
        self.recent_recording_menu_item.connect("activate", self.open_recent_recording)
        menu.append(self.recent_recording_menu_item)

        about_item = Gtk.ImageMenuItem(label="About Us")
        about_icon = Gtk.Image.new_from_icon_name("help-about", Gtk.IconSize.MENU)
        about_item.set_image(about_icon)
        about_item.connect("activate", self.show_about_dialog)
        menu.append(about_item)

        quit_item = Gtk.ImageMenuItem(label="Quit")
        quit_icon = Gtk.Image.new_from_icon_name("application-exit", Gtk.IconSize.MENU)
        quit_item.set_image(quit_icon)
        quit_item.connect("activate", self.quit_app)
        menu.append(quit_item)

        separator = Gtk.SeparatorMenuItem()
        menu.append(separator)

        self.recording_status_menu_item = Gtk.MenuItem(label="Not Recording")
        menu.append(self.recording_status_menu_item)

        self.file_size_menu_item = Gtk.MenuItem(label="File Size: N/A")
        menu.append(self.file_size_menu_item)

        self.elapsed_time_menu_item = Gtk.MenuItem(label="Elapsed Time: 00:00:00")
        menu.append(self.elapsed_time_menu_item)

        menu.show_all()
        self.indicator.set_menu(menu)

        # Initialize the tray tooltip with current settings
        self.update_tray_tooltip()

    def set_active_window(self, widget, window):
        if widget.get_active():
            index = self.get_active_windows().index(window)
            self.active_window_combo.set_active(index)
            self.update_tray_selection()

    def refresh_windows(self, widget=None):
        self.update_active_windows()
        self.status_label.set_text("Window list refreshed.")
        self.create_tray_icon()

    def update_tray_selection(self):
        area = self.recording_areas[self.recording_area_combo.get_active()]
        for item in self.recording_area_group:
            if item.get_label() == area:
                item.set_active(True)
                break

        format = ["mkv", "mp4", "webm"][self.output_format_combo.get_active()]
        for item in self.output_format_group:
            if item.get_label() == format:
                item.set_active(True)
                break

        codec = ["aac", "mp3", "opus"][self.audio_codec_combo.get_active()]
        for item in self.audio_codec_group:
            if item.get_label() == codec:
                item.set_active(True)
                break

        config = self.audio_input_configs[self.audio_input_config_combo.get_active()]
        for item in self.audio_input_config_group:
            if item.get_label() == config:
                item.set_active(True)
                break

        primary_input = self.audio_inputs[self.audio_input_combo.get_active()]
        for item in self.primary_audio_input_group:
            if item.get_label() == primary_input:
                item.set_active(True)
                break

        secondary_input = self.secondary_audio_inputs[self.secondary_audio_input_combo.get_active()]
        for item in self.secondary_audio_input_group:
            if item.get_label() == secondary_input:
                item.set_active(True)
                break

        active_window = self.active_window_combo.get_active_text()
        for item in self.active_window_group:
            if item.get_label() == active_window:
                item.set_active(True)
                break

        tooltip_text = f"Recording Area: {area}\nOutput Format: {format}\nAudio Codec: {codec}\nAudio Input Config: {config}\nPrimary Audio Input: {primary_input}\nSecondary Audio Input: {secondary_input}\nActive Window: {active_window}"
        self.recording_status_menu_item.set_label(f"Status: {tooltip_text}")

    def update_tooltips(self):
        self.audio_input_config_combo.set_tooltip_text(f"Selected: {self.audio_input_config_combo.get_active_text()}")
        self.recording_size_combo.set_tooltip_text(f"Selected: {self.recording_size_combo.get_active_text()}")
        self.video_codec_combo.set_tooltip_text(f"Selected: {self.video_codec_combo.get_active_text()}")
        self.audio_codec_combo.set_tooltip_text(f"Selected: {self.audio_codec_combo.get_active_text()}")
        self.audio_input_combo.set_tooltip_text(f"Selected: {self.audio_input_combo.get_active_text()}")
        self.secondary_audio_input_combo.set_tooltip_text(f"Selected: {self.secondary_audio_input_combo.get_active_text()}")
        self.recording_area_combo.set_tooltip_text(f"Selected: {self.recording_area_combo.get_active_text()}")
        self.output_format_combo.set_tooltip_text(f"Selected: {self.output_format_combo.get_active_text()}")
        self.active_window_combo.set_tooltip_text(f"Selected: {self.active_window_combo.get_active_text()}")
        self.camera_combo.set_tooltip_text(f"Selected: {self.camera_combo.get_active_text()}")
        self.camera_resolution_combo.set_tooltip_text(f"Selected: {self.camera_resolution_combo.get_active_text()}")
        self.streaming_combo.set_tooltip_text(f"Selected: {self.streaming_combo.get_active_text()}")
        self.streaming_key_entry.set_tooltip_text(f"Entered: {'******' if self.streaming_key_entry.get_text() else 'N/A'}")
        self.update_tray_tooltip()

    def on_combobox_changed(self, widget):
        self.update_tray_selection()
        self.update_tooltips()
        self.update_tray_tooltip()

    def set_recording_area(self, widget, area):
        if widget.get_active():
            index = self.recording_areas.index(area)
            self.recording_area_combo.set_active(index)
            self.update_tray_selection()

    def set_output_format(self, widget, format):
        if widget.get_active():
            index = ["mkv", "mp4", "webm"].index(format)
            self.output_format_combo.set_active(index)
            self.update_tray_selection()

    def set_audio_codec(self, widget, codec):
        if widget.get_active():
            index = ["aac", "mp3", "opus"].index(codec)
            self.audio_codec_combo.set_active(index)
            self.update_tray_selection()

    def set_audio_input_config(self, widget, config):
        if widget.get_active():
            index = self.audio_input_configs.index(config)
            self.audio_input_config_combo.set_active(index)
            self.update_tray_selection()

    def set_primary_audio_input(self, widget, input_device):
        if widget.get_active():
            index = self.audio_inputs.index(input_device)
            self.audio_input_combo.set_active(index)
            self.update_tray_selection()

    def set_secondary_audio_input(self, widget, input_device):
        if widget.get_active():
            index = self.secondary_audio_inputs.index(input_device)
            self.secondary_audio_input_combo.set_active(index)
            self.update_tray_selection()

    def open_recent_recording(self, widget):
        if self.completed_recordings:
            sorted_recordings = sorted(self.completed_recordings, key=lambda x: x[1], reverse=True)
            most_recent_path = sorted_recordings[0][0]
            try:
                subprocess.Popen(["xdg-open", most_recent_path])
            except Exception as e:
                logging.error(f"Failed to open the recent recording: {e}")
                self.status_label.set_text("Failed to open the recent recording.")
        else:
            self.status_label.set_text("No completed recordings found.")

    def update_recent_recording_menu_item(self):
        if self.completed_recordings:
            sorted_recordings = sorted(self.completed_recordings, key=lambda x: x[1], reverse=True)
            most_recent_path = sorted_recordings[0][0]
            most_recent_filename = os.path.basename(most_recent_path)
            most_recent_file_size = self.convert_size(os.path.getsize(most_recent_path))
            label_text = f"Recent Recording: {most_recent_filename} ({most_recent_file_size})"
        else:
            label_text = "No recent recording"

        if self.recent_recording_menu_item:
            self.recent_recording_menu_item.set_label(label_text)
        else:
            self.recent_recording_menu_item = Gtk.MenuItem(label=label_text)
            self.indicator.get_menu().append(self.recent_recording_menu_item)
            self.recent_recording_menu_item.show()

        GLib.idle_add(self.recent_recording_info_label.set_text, label_text)

    def show_window(self, widget):
        if self.get_window().get_state() & Gdk.WindowState.ICONIFIED:
            self.deiconify()
            self.present()
            self.set_keep_above(False)
        else:
            if self.is_active():
                self.iconify()
            else:
                self.show_all()
                self.present()
                self.set_keep_above(False)

    def quit_app(self, widget):
        self.cleanup_on_exit()
        os._exit(0)

    def on_show_screen_preview_toggled(self, button):
        if button.get_active():
            self.preview_window = ScreenPreview()
            self.preview_window.connect("destroy", self.on_preview_window_destroyed)
            self.preview_window.show_all()
        else:
            if self.preview_window:
                self.preview_window.stop_preview()
                self.preview_window.destroy()
                self.preview_window = None

    def on_preview_window_destroyed(self, widget):
        self.preview_window = None
        self.show_screen_preview_checkbox.set_active(False)

    def setup_hotkeys(self):
        def on_activate_start_recording():
            GLib.idle_add(self.start_recording, None)

        def on_activate_stop_recording():
            GLib.idle_add(self.stop_recording, None)

        def on_activate_pause_recording():
            GLib.idle_add(self.pause_recording, None)

        def on_activate_resume_recording():
            GLib.idle_add(self.resume_recording, None)

        hotkeys = {
            "<ctrl>+<alt>+r": on_activate_start_recording,
            "<ctrl>+<alt>+s": on_activate_stop_recording,
            "<ctrl>+<alt>+p": on_activate_pause_recording,
            "<ctrl>+<alt>+e": on_activate_resume_recording
        }

        for key, handler in hotkeys.items():
            hotkey = keyboard.HotKey(keyboard.HotKey.parse(key), handler)
            keyboard.Listener(on_press=hotkey.press).start()

    def signal_handler(self, sig, frame):
        logging.info("Received SIGINT signal. Exiting...")
        self.cleanup_on_exit()
        Gtk.main_quit()

    def show_about_dialog(self, widget):
        about_dialog = Gtk.AboutDialog()
        about_dialog.set_program_name("StormOS Screen Recorder")
        about_dialog.set_version("v1.0")
        about_dialog.set_comments("A powerful and easy-to-use screen recording application.")
        about_dialog.set_license_type(Gtk.License.MIT_X11)
        about_dialog.set_authors(["The Seeker"])
        about_dialog.set_documenters(["Ben StormOS Dev (Tester/Contributor)", "Ricki aka YughioMaster88 (Tester/Contributor)", "Fishman aka Pescado (Tester/Contributor)"])

        # Add notes for users
        notes_text = (
            "Notes:\n"
            "1. Ensure you have sufficient disk space before recording.\n"
            "2. For best performance, close unnecessary applications.\n"
            "3. If you encounter any issues, please report them to the StormOS Project Team."
            "4. Also please remember this program is a Work In Progress."
            "5. Hotkeys: Ctrl+Alt+R to start recording, Ctrl+Alt+S to stop recording, Ctrl+Alt+P to pause recording, Ctrl+Alt+E to resume recording"
        )
        about_dialog.set_comments(about_dialog.get_comments() + "\n\n" + notes_text)

        about_dialog.run()
        about_dialog.destroy()

    def on_delete_event(self, widget, event):
        self.hide()
        return True

    def on_destroy(self, widget):
        Gtk.main_quit()

def main():
    recorder = ScreenRecorder()
    recorder.connect("delete-event", recorder.on_delete_event)
    recorder.connect("destroy", recorder.on_destroy)
    try:
        recorder.create_tray_icon()
        recorder.setup_hotkeys()  # Make sure to set up hotkeys
        signal.signal(signal.SIGINT, recorder.signal_handler)
        Gtk.main()
    except KeyboardInterrupt:
        recorder.stop_recording(None)
        Gtk.main_quit()
    except Exception as e:
        logging.error(f"An error occurred: {e}")
        Gtk.main_quit()

if __name__ == "__main__":
    main()
