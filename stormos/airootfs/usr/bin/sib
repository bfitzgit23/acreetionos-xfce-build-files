#!/usr/bin/env python3

import gi
import subprocess
import os
import time
import shutil
import threading
import traceback  # To capture detailed error messages
from datetime import datetime

gi.require_version('Gtk', '3.0')
from gi.repository import Gtk, GLib

class ArchIsoBuilder(Gtk.Window):

    REQUIRED_PACKAGES = [
        'archiso', 'mkinitcpio-archiso', 'calamares-app'
    ]

    # Use dynamic USER_HOME path instead of hardcoding any directory
    USER_HOME = os.path.expanduser("~")
    STORMOS_DIR = os.path.join(USER_HOME, "Desktop", "stormos-build-files", "stormos", "stormos")
    OUTPUT_DIR = os.path.join(USER_HOME, "Desktop", "StormOS-ISO")
    GIT_REPO = "https://github.com/bfitzgit23/stormos-build-files"

    def __init__(self):
        Gtk.Window.__init__(self, title="StormOS ISO Builder")
        self.set_border_width(10)
        self.set_default_size(600, 500)

        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10)
        self.add(vbox)

        self.output_scrolled_window = Gtk.ScrolledWindow()
        self.output_scrolled_window.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        vbox.pack_start(self.output_scrolled_window, True, True, 0)

        self.output_textview = Gtk.TextView()
        self.output_textview.set_editable(False)
        self.output_textview.set_cursor_visible(False)
        self.output_scrolled_window.add(self.output_textview)

        self.progress_bar = Gtk.ProgressBar()
        vbox.pack_start(self.progress_bar, False, False, 0)

        hbox = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=10)
        vbox.pack_start(hbox, False, False, 0)

        self.use_existing_checkbox = Gtk.CheckButton(label="Use existing git clone")
        hbox.pack_start(self.use_existing_checkbox, False, False, 0)

        self.update_git_button = Gtk.Button(label="Update Git Clone")
        self.update_git_button.connect("clicked", self.on_update_git_button_clicked)
        hbox.pack_start(self.update_git_button, False, False, 0)

        self.build_button = Gtk.Button(label="Build ISO")
        self.build_button.connect("clicked", self.on_build_button_clicked)
        hbox.pack_start(self.build_button, False, False, 0)

        # Initialize the output buffer
        self.output_buffer = []

        # Ensure the OUTPUT_DIR and STORMOS_DIR exist before proceeding
        self.ensure_directories_exist()

        # Ensure the necessary packages are installed
        self.check_and_install_packages()

        # Do not automatically update the Git repo at startup

    def ensure_directories_exist(self):
        """Ensure that OUTPUT_DIR and STORMOS_DIR exist, create them if necessary."""
        self.append_text(f"Checking if necessary directories exist...\n")
        
        # Check and create OUTPUT_DIR if it does not exist
        if not os.path.exists(self.OUTPUT_DIR):
            self.append_text(f"Output directory {self.OUTPUT_DIR} does not exist. Creating...\n")
            os.makedirs(self.OUTPUT_DIR, exist_ok=True)
            self.append_text(f"Created output directory: {self.OUTPUT_DIR}\n")

        # Check and create STORMOS_DIR if it does not exist
        if not os.path.exists(self.STORMOS_DIR):
            self.append_text(f"StormOS directory {self.STORMOS_DIR} does not exist. Creating...\n")
            os.makedirs(self.STORMOS_DIR, exist_ok=True)
            self.append_text(f"Created StormOS directory: {self.STORMOS_DIR}\n")

    def check_and_install_packages(self):
        """Check if required packages are installed and install missing ones."""
        self.append_text("Checking required packages...\n")
        missing_packages = []

        # Check if each required package is installed
        for package in self.REQUIRED_PACKAGES:
            if not self.is_package_installed(package):
                missing_packages.append(package)

        # Install missing packages using pkexec for privilege escalation
        if missing_packages:
            self.append_text(f"Missing packages: {', '.join(missing_packages)}. Installing...\n")
            self.install_missing_packages(missing_packages)
        else:
            self.append_text("All required packages are already installed.\n")

    def is_package_installed(self, package_name):
        """Check if a package is installed using pacman."""
        result = subprocess.run(['pacman', '-Qq', package_name], capture_output=True, text=True)
        return result.returncode == 0

    def install_missing_packages(self, packages):
        """Install the missing packages using pacman with pkexec for sudo privileges."""
        self.append_text(f"Installing missing packages: {', '.join(packages)}\n")
        result = subprocess.run(['pkexec', 'pacman', '-S', '--noconfirm'] + packages, capture_output=True, text=True)
        if result.returncode == 0:
            self.append_text(f"Successfully installed: {', '.join(packages)}\n")
        else:
            self.append_text(f"Failed to install: {', '.join(packages)}\n")
            if result.stdout:
                self.append_text(result.stdout)
            if result.stderr:
                self.append_text(result.stderr)

    def clone_or_update_git_repo(self, force_update=False):
        use_existing = self.use_existing_checkbox.get_active()

        # Only clone or update the repo when explicitly requested
        if not use_existing or force_update:
            repo_parent_dir = os.path.dirname(self.STORMOS_DIR)
            
            # If "Use existing" is unchecked or force_update is True, delete and re-clone the repo
            if os.path.exists(repo_parent_dir):
                self.append_text("Deleting existing repository to download a fresh copy...\n")
                shutil.rmtree(repo_parent_dir)

            self.append_text(f"Cloning repository from {self.GIT_REPO}...\n")
            try:
                # Use Popen for real-time output
                process = subprocess.Popen(
                    ['git', 'clone', '--progress', self.GIT_REPO, repo_parent_dir],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    bufsize=1
                )

                # Stream the output from the process in real-time
                for line in iter(process.stdout.readline, ''):
                    GLib.idle_add(self.append_text, line.strip())

                process.wait()

                if process.returncode != 0:
                    error_output = process.stdout.read()
                    self.append_text(f"Git clone failed with error:\n{error_output}")
                else:
                    self.append_text("Repository cloned successfully.\n")

            except subprocess.CalledProcessError as e:
                self.append_text(f"Git clone failed: {e}\n")
                if e.stdout:
                    self.append_text(e.stdout)
                if e.stderr:
                    self.append_text(e.stderr)
        else:
            self.append_text("Using existing Git clone. No update needed.\n")


    def on_update_git_button_clicked(self, widget):
        """Handler for the 'Update Git Clone' button."""
        self.append_text("Updating Git clone...\n")
        update_thread = threading.Thread(target=self.clone_or_update_git_repo, kwargs={"force_update": True})
        update_thread.start()

    def scan_stormos_dir(self):
        self.append_text(f"Scanning {self.STORMOS_DIR} for necessary files and folders...\n")
        required_files = ["packages.x86_64", "profiledef.sh", "pacman.conf"]
        required_dirs = ["syslinux", "grub"]

        for required_file in required_files:
            file_path = os.path.join(self.STORMOS_DIR, required_file)
            if not os.path.exists(file_path):
                self.append_text(f"Missing: {required_file}. Creating default...\n")
                self.create_required_file(required_file)
            else:
                self.append_text(f"Found: {required_file}\n")

        for required_dir in required_dirs:
            dir_path = os.path.join(self.STORMOS_DIR, required_dir)
            if not os.path.exists(dir_path):
                self.append_text(f"Missing: {required_dir} directory. Creating it...\n")
                os.makedirs(dir_path)
                self.create_required_file(required_dir)
            else:
                self.append_text(f"Found: {required_dir} directory\n")

    def create_required_file(self, filename):
        # Logic to create missing files like "packages.x86_64", "profiledef.sh", etc.
        if filename == "packages.x86_64":
            with open(os.path.join(self.STORMOS_DIR, "packages.x86_64"), "w") as f:
                f.write("base\nlinux\nlinux-firmware\nsyslinux\n")

        elif filename == "pacman.conf":
            default_pacman_conf = "/etc/pacman.conf"
            if os.path.exists(default_pacman_conf):
                shutil.copy(default_pacman_conf, os.path.join(self.STORMOS_DIR, "pacman.conf"))

        elif filename == "syslinux":
            syslinux_dir = os.path.join(self.STORMOS_DIR, "syslinux")
            os.makedirs(syslinux_dir, exist_ok=True)
            with open(os.path.join(syslinux_dir, "syslinux.cfg"), "w") as f:
                f.write(
                    "DEFAULT linux\n"
                    "LABEL linux\n"
                    "    LINUX /boot/vmlinuz-linux\n"
                    "    INITRD /boot/initramfs-linux.img\n"
                    "    APPEND root=/dev/sda1 rw\n"
                )

        elif filename == "grub":
            grub_dir = os.path.join(self.STORMOS_DIR, "grub")
            os.makedirs(grub_dir, exist_ok=True)
            with open(os.path.join(grub_dir, "grub.cfg"), "w") as f:
                f.write(
                    "set default=0\n"
                    "set timeout=5\n\n"
                    "menuentry 'Arch Linux' {\n"
                    "    linux /boot/vmlinuz-linux root=/dev/sda1 rw\n"
                    "    initrd /boot/initramfs-linux.img\n"
                    "}\n"
                )

        elif filename == "profiledef.sh":
            profiledef_path = os.path.join(self.STORMOS_DIR, "profiledef.sh")
            with open(profiledef_path, "w") as f:
                f.write(
                    "#!/bin/bash\n"
                    "iso_name=\"stormos\"\n"
                    "iso_label=\"STORMOS_$(date +%Y%m)\"\n"
                    "iso_version=\"$(date +%Y.%m.%d)\"\n"
                )
            os.chmod(profiledef_path, 0o755)

        self.append_text(f"Created required file: {filename}\n")

    def generate_generic_calamares_config(self):
        self.append_text("Generating generic Calamares configuration...\n")
        
        generic_config = """
---
# Calamares Generic Config
modules:
  - welcome
  - locale
  - keyboard
  - partition
  - users
  - summary
  - finished
"""
        calamares_dir = os.path.join(self.STORMOS_DIR, 'calamares')
        os.makedirs(calamares_dir, exist_ok=True)

        with open(os.path.join(calamares_dir, 'settings.conf'), 'w') as f:
            f.write(generic_config)

        self.append_text("Generic Calamares configuration generated successfully.\n")

    def on_build_button_clicked(self, widget):
        self.append_text("Starting ISO build...\n")
        build_thread = threading.Thread(target=self.build_iso)
        build_thread.start()

    def clean_up_previous_build(self):
        self.append_text("Cleaning up previous build files...\n")

        work_dir = os.path.join(self.OUTPUT_DIR, 'work')
        if os.path.exists(work_dir):
            result = subprocess.run(['pkexec', 'rm', '-rf', work_dir], capture_output=True, text=True)
            if result.returncode == 0:
                self.append_text("Previous work directory cleaned up.\n")
            else:
                self.append_text("Failed to clean up previous work directory.\n")

        if os.path.exists(self.OUTPUT_DIR):
            for file_name in os.listdir(self.OUTPUT_DIR):
                if file_name.endswith('.iso'):
                    file_path = os.path.join(self.OUTPUT_DIR, file_name)
                    result = subprocess.run(['pkexec', 'rm', '-f', file_path], capture_output=True, text=True)
                    if result.returncode == 0:
                        self.append_text(f"Removed old ISO file: {file_path}\n")
                    else:
                        self.append_text(f"Failed to remove old ISO file: {file_path}\n")

    def build_iso(self):
        try:
            # Start the timer
            start_time = time.time()

            self.clean_up_previous_build()
            self.scan_stormos_dir()

            self.append_text("Starting mkarchiso build process...\n")

            # Ensure work directory exists before starting mkarchiso
            work_dir = os.path.join(self.OUTPUT_DIR, 'work')
            os.makedirs(work_dir, exist_ok=True)  # Create the work directory if it doesn't exist

            mkarchiso_command = [
                'pkexec', 'mkarchiso', '-v',
                '-w', work_dir,
                '-o', self.OUTPUT_DIR,
                self.STORMOS_DIR
            ]

            process = subprocess.Popen(
                mkarchiso_command,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            # Read stdout and stderr from mkarchiso in real-time and display in the text box
            def read_output(pipe, tag):
                for line in iter(pipe.readline, ''):
                    if tag == "stderr":  # Highlight stderr messages
                        GLib.idle_add(self.append_text, f"ERROR: {line.strip()}")
                    else:
                        GLib.idle_add(self.append_text, line.strip())
                pipe.close()

            # Create separate threads to handle stdout and stderr
            threading.Thread(target=read_output, args=(process.stdout, "stdout")).start()
            threading.Thread(target=read_output, args=(process.stderr, "stderr")).start()

            process.wait()

            # End the timer
            end_time = time.time()

            if process.returncode != 0:
                raise subprocess.CalledProcessError(process.returncode, mkarchiso_command)

            self.update_progress(1.0, "Build completed.")

            iso_files = [f for f in os.listdir(self.OUTPUT_DIR) if f.endswith('.iso')]
            if iso_files:
                iso_path = os.path.join(self.OUTPUT_DIR, iso_files[0])
                GLib.idle_add(self.append_text, f"ISO build completed successfully. ISO located at: {iso_path}\n")
            else:
                GLib.idle_add(self.append_text, "ISO build completed, but no ISO file found.\n")

            # Calculate and display the total build time
            total_time = end_time - start_time
            minutes, seconds = divmod(total_time, 60)
            GLib.idle_add(self.append_text, f"Total build time: {int(minutes)} minutes and {int(seconds)} seconds.\n")

        except subprocess.CalledProcessError as e:
            error_message = f"Build failed with error code {e.returncode}."
            self.append_text(f"{error_message}\n")
            self.show_error_dialog(f"Build failed", error_message)
        except Exception as e:
            error_message = traceback.format_exc()  # Capture the full traceback
            self.append_text(f"An unexpected error occurred: {error_message}\n")
            self.show_error_dialog("Unexpected Error", error_message)

    def show_error_dialog(self, title, message):
        """Show an error dialog to alert the user of an issue."""
        dialog = Gtk.MessageDialog(
            self,
            0,
            Gtk.MessageType.ERROR,
            Gtk.ButtonsType.OK,
            title
        )
        dialog.format_secondary_text(message)
        dialog.run()
        dialog.destroy()


    def append_text(self, text):
        """Append text to the Gtk.TextView and scroll to bottom, with throttling."""
        self.output_buffer.append(text + "\n")

        # Append the text in batches to avoid overwhelming the Gtk.TextView
        if len(self.output_buffer) >= 10:  # Adjust the threshold as necessary
            self.flush_output_buffer()

    def flush_output_buffer(self):
        """Flush the output buffer to the Gtk.TextView."""
        buffer = self.output_textview.get_buffer()
        batch_text = ''.join(self.output_buffer)
        self.output_buffer.clear()  # Clear the buffer after flushing

        # Append the batch of text to the Gtk.TextView
        GLib.idle_add(self._safe_append, buffer, batch_text)

    def _safe_append(self, buffer, text):
        """Safely append text to the buffer and scroll down."""
        end_iter = buffer.get_end_iter()
        buffer.insert(end_iter, text)

        # Scroll to the bottom
        GLib.idle_add(self.scroll_to_bottom)

    def update_progress(self, fraction, message):
        """Update the progress bar and the window title with the current progress."""
        GLib.idle_add(self.progress_bar.set_fraction, fraction)
        GLib.idle_add(self.progress_bar.set_text, message)
        GLib.idle_add(self.set_title, f"StormOS ISO Builder - {int(fraction * 100)}%")

    def scroll_to_bottom(self):
        buffer = self.output_textview.get_buffer()
        mark = buffer.create_mark(None, buffer.get_end_iter(), False)
        self.output_textview.scroll_to_mark(mark, 0.05, True, 0.0, 1.0)


if __name__ == "__main__":
    builder = ArchIsoBuilder()
    builder.connect("destroy", Gtk.main_quit)
    builder.show_all()
    Gtk.main()