#!/usr/bin/env python3

import gi
import subprocess
import time
import re
import os
import threading
import signal
import math
import atexit
import logging
import sys
import select
import fcntl

gi.require_version('Gtk', '3.0')
gi.require_version('AppIndicator3', '0.1')
gi.require_version('Gst', '1.0')
from gi.repository import Gtk, Gdk, GLib, AppIndicator3, Gst, GdkX11

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Create a unique lock file
lock_file_path = '/tmp/screen_recorder_indicator.lock'
lock_file = open(lock_file_path, 'w')

try:
    # Try to acquire the lock
    fcntl.flock(lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
except IOError:
    # If the lock is already held by another process, exit
    print("Another instance of the application is already running.")
    sys.exit(1)

# Ensure the lock is released on exit
def release_lock():
    fcntl.flock(lock_file, fcntl.LOCK_UN)
    lock_file.close()
    os.remove(lock_file_path)

atexit.register(release_lock)

def ensure_even_dimensions(width, height):
    if width % 2 != 0:
        width += 1
    if height % 2 != 0:
        height += 1
    return width, height



class AudioVisualizer(Gtk.DrawingArea):
    def __init__(self):
        super().__init__()
        self.set_size_request(200, 60)
        self.level = 0
        self.connect("draw", self.on_draw)

    def on_draw(self, widget, cr):
        width = widget.get_allocated_width()
        height = widget.get_allocated_height()

        # Background
        cr.set_source_rgb(0.1, 0.1, 0.1)
        cr.rectangle(0, 0, width, height)
        cr.fill()

        # Level bar
        cr.set_source_rgb(0, 0.7, 0)
        bar_width = int(width * self.level)
        cr.rectangle(0, 0, bar_width, height)
        cr.fill()

        return False

    def update_level(self, level):
        self.level = level
        self.queue_draw()

class VideoTrimmingDialog(Gtk.Dialog):
    def __init__(self, parent, video_path):
        super().__init__(title="Trim Video", transient_for=parent, flags=0)
        self.video_path = video_path
        self.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_OK, Gtk.ResponseType.OK
        )

        self.set_default_size(350, 150)

        box = self.get_content_area()
        
        # Start time entry
        start_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        start_label = Gtk.Label(label="Start Time (seconds):")
        self.start_entry = Gtk.Entry()
        start_box.pack_start(start_label, False, False, 0)
        start_box.pack_start(self.start_entry, True, True, 0)
        box.add(start_box)

        # End time entry
        end_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        end_label = Gtk.Label(label="End Time (seconds):")
        self.end_entry = Gtk.Entry()
        end_box.pack_start(end_label, False, False, 0)
        end_box.pack_start(self.end_entry, True, True, 0)
        box.add(end_box)

        # Video duration label
        self.duration_label = Gtk.Label()
        box.add(self.duration_label)

        self.show_all()
        self.get_video_duration()

    def get_video_duration(self):
        try:
            result = subprocess.run(['ffprobe', '-v', 'error', '-show_entries', 'format=duration', '-of', 'default=noprint_wrappers=1:nokey=1', self.video_path], 
                                    stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
            duration = float(result.stdout)
            self.duration_label.set_text(f"Video Duration: {duration:.2f} seconds")
        except Exception as e:
            print(f"Error getting video duration: {e}")
            self.duration_label.set_text("Unable to get video duration")

    def get_trim_times(self):
        start = float(self.start_entry.get_text() or 0)
        end = float(self.end_entry.get_text() or 0)
        return start, end




class ScreenRecorder(Gtk.Window):
    def __init__(self):
        super().__init__(title="Seekers Screen Recorder")
        self.set_default_size(600, 450)
        self.connect("delete-event", self.on_window_delete_event)

        # Save a reference to the main window
        self.main_window = self

        self.output_directory = os.path.join(os.path.expanduser('~'), 'Videos')
        self.temp_directory = os.path.join(self.output_directory, 'temp')
        os.makedirs(self.output_directory, exist_ok=True)
        os.makedirs(self.temp_directory, exist_ok=True)

        self.use_custom_save = False
        self.custom_save_location = self.output_directory  # Default to the output directory



        self.is_recording = False
        self.is_paused = False
        self.start_time = 0
        self.output_filename = None
        self.ffmpeg_process = None
        self.file_size = 0
        self.custom_region_start_x = None
        self.custom_region_start_y = None
        self.custom_region_end_x = None
        self.custom_region_end_y = None

        self.is_custom_region = False

        self.recording_region = None
        self.completed_recordings = []
        self.recent_recording_menu_item = None
        self.camera_window = None
        self.camera_window_id = None

        self.is_camera_on_top = False
        self.is_webcam_overlay = False  # New variable for webcam overlay
        self.webcam_position = "top-right"  # Default position
        self.webcam_resolution = "640x480"  # Default webcam resolution
        self.is_journal_mode = False  # Initialize journaling mode
        self.is_keep_mode = False  # Add missing initialization

        self.timer_active = False
        self.timer_seconds = 0
        self.timer_thread = None
        self.timer_completed = False

        self.webcam_size_percentage = 20  




        atexit.register(self.cleanup_on_exit)

        signal.signal(signal.SIGINT, self.cleanup_on_exit)
        signal.signal(signal.SIGTERM, self.cleanup_on_exit)

        notebook = Gtk.Notebook()
        notebook.set_tab_pos(Gtk.PositionType.LEFT)  # Set the tabs to be on the left
        self.add(notebook)

        # Create settings page
        settings_grid = Gtk.Grid()
        settings_grid.set_column_spacing(10)
        settings_grid.set_row_spacing(10)

        self.audio_input_configs = ["Primary Only", "Secondary Only"]
        self.audio_input_config_label = Gtk.Label(label="Select Audio Input Configuration:")
        settings_grid.attach(self.audio_input_config_label, 0, 0, 1, 1)
        self.audio_input_config_combo = Gtk.ComboBoxText()
        for config in self.audio_input_configs:
            self.audio_input_config_combo.append_text(config)
        self.audio_input_config_combo.set_active(0)
        self.audio_input_config_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.audio_input_config_combo, 1, 0, 1, 1)

        self.recording_sizes = self.get_available_resolutions()
        if not self.recording_sizes:
            self.recording_sizes = [
                ("1920x1080", "1920x1080"),
                ("1280x720", "1280x720"),
                ("640x480", "640x480"),
                ("2560x1440", "2560x1440"),
                ("3840x2160", "3840x2160")
            ]
        self.recording_size_label = Gtk.Label(label="Select Recording Size:")
        settings_grid.attach(self.recording_size_label, 0, 1, 1, 1)
        self.recording_size_combo = Gtk.ComboBoxText()
        for size in self.recording_sizes:
            self.recording_size_combo.append_text(size[0])
        self.recording_size_combo.set_active(0)
        self.recording_size_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.recording_size_combo, 1, 1, 1, 1)

        self.video_codec_label = Gtk.Label(label="Select Video Codec:")
        settings_grid.attach(self.video_codec_label, 0, 2, 1, 1)
        self.video_codec_combo = Gtk.ComboBoxText()
        self.video_codecs = ["libx264", "libvpx-vp9", "libx265", "libvpx"]
        for codec in self.video_codecs:
            self.video_codec_combo.append_text(codec)
        self.video_codec_combo.set_active(0)
        self.video_codec_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.video_codec_combo, 1, 2, 1, 1)

        self.audio_codec_label = Gtk.Label(label="Select Audio Codec:")
        settings_grid.attach(self.audio_codec_label, 0, 3, 1, 1)
        self.audio_codec_combo = Gtk.ComboBoxText()
        self.audio_codecs = ["aac", "mp3", "opus"]
        for codec in self.audio_codecs:
            self.audio_codec_combo.append_text(codec)
        self.audio_codec_combo.set_active(0)
        self.audio_codec_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.audio_codec_combo, 1, 3, 1, 1)

        self.audio_input_label = Gtk.Label(label="Select Primary Audio Input:")
        settings_grid.attach(self.audio_input_label, 0, 4, 1, 1)
        self.audio_input_combo = Gtk.ComboBoxText()
        self.audio_inputs = self.get_available_audio_inputs()
        for input_device in self.audio_inputs:
            self.audio_input_combo.append_text(input_device)
        self.audio_input_combo.set_active(0)
        self.audio_input_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.audio_input_combo, 1, 4, 1, 1)

        self.secondary_audio_input_label = Gtk.Label(label="Select Secondary Audio Input:")
        settings_grid.attach(self.secondary_audio_input_label, 0, 5, 1, 1)
        self.secondary_audio_input_combo = Gtk.ComboBoxText()
        self.secondary_audio_inputs = self.get_available_audio_inputs()
        for input_device in self.secondary_audio_inputs:
            self.secondary_audio_input_combo.append_text(input_device)
        self.secondary_audio_input_combo.set_active(0)
        self.secondary_audio_input_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.secondary_audio_input_combo, 1, 5, 1, 1)

        self.recording_area_label = Gtk.Label(label="Select Recording Area:")
        settings_grid.attach(self.recording_area_label, 0, 6, 1, 1)
        self.recording_area_combo = Gtk.ComboBoxText()
        self.recording_areas = ["Full Screen", "Camera Only", "Active Window", "Custom Region"]
        for area in self.recording_areas:
            self.recording_area_combo.append_text(area)
        self.recording_area_combo.set_active(0)
        self.recording_area_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.recording_area_combo, 1, 6, 1, 1)

        self.output_format_label = Gtk.Label(label="Select Output Format:")
        settings_grid.attach(self.output_format_label, 0, 7, 1, 1)
        self.output_format_combo = Gtk.ComboBoxText()
        output_formats = ["mkv", "mp4", "webm"]
        for format in output_formats:
            self.output_format_combo.append_text(format)
        self.output_format_combo.set_active(0)
        self.output_format_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.output_format_combo, 1, 7, 1, 1)

        self.active_window_label = Gtk.Label(label="Select Active Window:")
        settings_grid.attach(self.active_window_label, 0, 8, 1, 1)
        self.active_window_combo = Gtk.ComboBoxText()
        self.update_active_windows()
        self.active_window_combo.connect("changed", self.on_combobox_changed)
        settings_grid.attach(self.active_window_combo, 1, 8, 1, 1)

        # In the settings tab
        self.settings_record_button = Gtk.Button(label="Record")
        record_icon = Gtk.Image.new_from_icon_name("media-record", Gtk.IconSize.BUTTON)
        self.settings_record_button.set_image(record_icon)
        self.settings_record_button.set_always_show_image(True)
        self.settings_record_button.connect("clicked", self.start_recording)
        settings_grid.attach(self.settings_record_button, 0, 9, 1, 1)

        self.stop_button_settings = Gtk.Button(label="Stop")
        stop_icon = Gtk.Image.new_from_icon_name("media-playback-stop", Gtk.IconSize.BUTTON)
        self.stop_button_settings.set_image(stop_icon)
        self.stop_button_settings.set_always_show_image(True)
        self.stop_button_settings.connect("clicked", self.stop_recording)
        self.stop_button_settings.set_sensitive(False)
        settings_grid.attach(self.stop_button_settings, 1, 9, 1, 1)

        self.refresh_windows_button = Gtk.Button(label="Refresh Windows")
        refresh_icon = Gtk.Image.new_from_icon_name("view-refresh", Gtk.IconSize.BUTTON)
        self.refresh_windows_button.set_image(refresh_icon)
        self.refresh_windows_button.set_always_show_image(True)
        self.refresh_windows_button.connect("clicked", self.refresh_windows)
        settings_grid.attach(self.refresh_windows_button, 0, 10, 1, 1)

        self.select_custom_region_button = Gtk.Button(label="Select Custom Region")
        custom_region_icon = Gtk.Image.new_from_icon_name("image-x-generic", Gtk.IconSize.BUTTON)
        self.select_custom_region_button.set_image(custom_region_icon)
        self.select_custom_region_button.set_always_show_image(True)
        self.select_custom_region_button.connect("clicked", self.select_custom_region)
        settings_grid.attach(self.select_custom_region_button, 1, 10, 1, 1)

        self.journaling_mode_checkbox = Gtk.CheckButton(label="Journaling Mode")
        settings_grid.attach(self.journaling_mode_checkbox, 1, 11, 1, 1)
        self.journaling_mode_checkbox.connect("toggled", self.on_journaling_mode_toggled)


        # Timer configuration
        self.timer_checkbox = Gtk.CheckButton(label="Enable Timer")
        self.timer_checkbox.connect("toggled", self.on_timer_toggled)
        settings_grid.attach(self.timer_checkbox, 0, 11, 1, 1)

        self.timer_label = Gtk.Label(label="Set Timer:")
        settings_grid.attach(self.timer_label, 0, 12, 1, 1)

        self.timer_hours_combo = Gtk.ComboBoxText()
        for hour in range(24):
            self.timer_hours_combo.append_text(str(hour))
        self.timer_hours_combo.set_active(0)
        settings_grid.attach(self.timer_hours_combo, 1, 12, 1, 1)

        self.timer_minutes_combo = Gtk.ComboBoxText()
        for minute in range(60):
            self.timer_minutes_combo.append_text(str(minute))
        self.timer_minutes_combo.set_active(0)
        settings_grid.attach(self.timer_minutes_combo, 2, 12, 1, 1)

        self.timer_hours_combo.connect("changed", self.on_timer_changed)
        self.timer_minutes_combo.connect("changed", self.on_timer_changed)

        notebook.append_page(settings_grid, Gtk.Label(label="Settings"))

        controls_camera_streaming_grid = Gtk.Grid()
        controls_camera_streaming_grid.set_column_spacing(10)
        controls_camera_streaming_grid.set_row_spacing(10)

        # In the controls tab
        self.controls_record_button = Gtk.Button(label="Record")
        record_icon = Gtk.Image.new_from_icon_name("media-record", Gtk.IconSize.BUTTON)
        self.controls_record_button.set_image(record_icon)
        self.controls_record_button.set_always_show_image(True)
        self.controls_record_button.connect("clicked", self.start_recording)
        controls_camera_streaming_grid.attach(self.controls_record_button, 0, 0, 1, 1)

        self.stop_button = Gtk.Button(label="Stop")
        stop_icon = Gtk.Image.new_from_icon_name("media-playback-stop", Gtk.IconSize.BUTTON)
        self.stop_button.set_image(stop_icon)
        self.stop_button.set_always_show_image(True)
        self.stop_button.connect("clicked", self.stop_recording)
        self.stop_button.set_sensitive(False)
        controls_camera_streaming_grid.attach(self.stop_button, 1, 0, 1, 1)

        self.pause_button = Gtk.Button(label="Pause")
        pause_icon = Gtk.Image.new_from_icon_name("media-playback-pause", Gtk.IconSize.BUTTON)
        self.pause_button.set_image(pause_icon)
        self.pause_button.set_always_show_image(True)
        self.pause_button.connect("clicked", self.pause_recording)
        self.pause_button.set_sensitive(False)
        controls_camera_streaming_grid.attach(self.pause_button, 0, 1, 1, 1)

        self.resume_button = Gtk.Button(label="Resume")
        resume_icon = Gtk.Image.new_from_icon_name("media-playback-start", Gtk.IconSize.BUTTON)
        self.resume_button.set_image(resume_icon)
        self.resume_button.set_always_show_image(True)
        self.resume_button.connect("clicked", self.resume_recording)
        self.resume_button.set_sensitive(False)
        controls_camera_streaming_grid.attach(self.resume_button, 1, 1, 1, 1)

        self.status_label = Gtk.Label(label="Press Record to start recording.")
        self.status_label.set_justify(Gtk.Justification.CENTER)
        self.status_label.set_halign(Gtk.Align.CENTER)
        controls_camera_streaming_grid.attach(self.status_label, 0, 2, 2, 1)

        self.play_recent_button = Gtk.Button(label="Play Recent Recording")
        recent_recording_icon = Gtk.Image.new_from_icon_name("media-playback-start", Gtk.IconSize.BUTTON)
        self.play_recent_button.set_image(recent_recording_icon)
        self.play_recent_button.set_always_show_image(True)
        self.play_recent_button.connect("clicked", self.open_recent_recording)
        controls_camera_streaming_grid.attach(self.play_recent_button, 0, 3, 1, 1)


        # Add this after the 'Play Recent Recording' button
        self.trim_button = Gtk.Button(label="Trim Recent Recording")
        trim_icon = Gtk.Image.new_from_icon_name("edit-cut", Gtk.IconSize.BUTTON)
        self.trim_button.set_image(trim_icon)
        self.trim_button.set_always_show_image(True)
        self.trim_button.connect("clicked", self.trim_video)
        controls_camera_streaming_grid.attach(self.trim_button, 0, 4, 1, 1)  # Adjust the grid position as needed



        self.recent_recording_info_label = Gtk.Label(label="No recent recording")
        self.recent_recording_info_label.set_justify(Gtk.Justification.CENTER)
        self.recent_recording_info_label.set_halign(Gtk.Align.CENTER)
        controls_camera_streaming_grid.attach(self.recent_recording_info_label, 1, 3, 1, 1)


        # Add the recent recordings label in the Control and Streaming tab
        #self.recent_recordings_label_controls = Gtk.Label(label="Recent Recordings:\nNone")
        #controls_camera_streaming_grid.attach(self.recent_recordings_label_controls, 0, 3, 2, 1)



        self.file_size_label = Gtk.Label(label="")
        self.file_size_label.set_justify(Gtk.Justification.CENTER)
        self.file_size_label.set_halign(Gtk.Align.CENTER)
        controls_camera_streaming_grid.attach(self.file_size_label, 0, 4, 2, 1)

        self.available_cameras = self.get_available_cameras_v4l2()
        self.camera_label = Gtk.Label(label="Select Camera:")
        controls_camera_streaming_grid.attach(self.camera_label, 0, 5, 1, 1)
        self.camera_combo = Gtk.ComboBoxText()
        for camera in self.available_cameras:
            self.camera_combo.append_text(camera)
        self.camera_combo.set_active(0)
        controls_camera_streaming_grid.attach(self.camera_combo, 1, 5, 1, 1)

        self.camera_resolution_label = Gtk.Label(label="Select Camera Resolution:")
        controls_camera_streaming_grid.attach(self.camera_resolution_label, 0, 6, 1, 1)
        self.camera_resolution_combo = Gtk.ComboBoxText()
        camera_resolutions = ["480x320", "640x480", "1280x720", "1920x1080"]
        for resolution in camera_resolutions:
            self.camera_resolution_combo.append_text(resolution)
        self.camera_resolution_combo.set_active(0)
        self.camera_resolution_combo.connect("changed", self.on_combobox_changed)
        controls_camera_streaming_grid.attach(self.camera_resolution_combo, 1, 6, 1, 1)

        self.camera_button = Gtk.Button(label="Show Camera")
        camera_icon = Gtk.Image.new_from_icon_name("camera-photo", Gtk.IconSize.BUTTON)
        self.camera_button.set_image(camera_icon)
        self.camera_button.set_always_show_image(True)
        self.camera_button.connect("clicked", self.show_camera_window)
        controls_camera_streaming_grid.attach(self.camera_button, 0, 7, 1, 1)

        self.close_camera_button = Gtk.Button(label="Close Camera")
        close_camera_icon = Gtk.Image.new_from_icon_name("window-close", Gtk.IconSize.BUTTON)
        self.close_camera_button.set_image(close_camera_icon)
        self.close_camera_button.set_always_show_image(True)
        self.close_camera_button.connect("clicked", self.close_camera_window)
        controls_camera_streaming_grid.attach(self.close_camera_button, 1, 7, 1, 1)

        self.keep_camera_on_top_checkbox = Gtk.CheckButton(label="Keep Camera on Top")
        controls_camera_streaming_grid.attach(self.keep_camera_on_top_checkbox, 0, 8, 1, 1)
        self.keep_camera_on_top_checkbox.connect("toggled", self.on_keep_camera_on_top_toggled)

        # Add webcam overlay checkbox
        self.webcam_overlay_checkbox = Gtk.CheckButton(label="Enable Webcam Overlay")
        controls_camera_streaming_grid.attach(self.webcam_overlay_checkbox, 0, 9, 1, 1)
        self.webcam_overlay_checkbox.connect("toggled", self.on_webcam_overlay_toggled)

        # Add webcam position selection
        self.webcam_positions = ["top-left", "top-right", "bottom-left", "bottom-right", "center"]
        self.webcam_position_label = Gtk.Label(label="Select Webcam Position:")
        controls_camera_streaming_grid.attach(self.webcam_position_label, 0, 10, 1, 1)
        self.webcam_position_combo = Gtk.ComboBoxText()
        for position in self.webcam_positions:
            self.webcam_position_combo.append_text(position)
        self.webcam_position_combo.set_active(1)  # Default to top-right
        self.webcam_position_combo.connect("changed", self.on_combobox_changed)
        controls_camera_streaming_grid.attach(self.webcam_position_combo, 1, 10, 1, 1)

        # Streaming section
        self.streaming_label = Gtk.Label(label="Streaming Options:")
        controls_camera_streaming_grid.attach(self.streaming_label, 0, 12, 1, 1)
        self.streaming_combo = Gtk.ComboBoxText()
        streaming_options = ["None", "Twitch", "YouTube"]
        for option in streaming_options:
            self.streaming_combo.append_text(option)
        self.streaming_combo.set_active(0)
        self.streaming_combo.connect("changed", self.on_combobox_changed)
        controls_camera_streaming_grid.attach(self.streaming_combo, 1, 12, 1, 1)

        self.streaming_key_label = Gtk.Label(label="Streaming Key:")
        controls_camera_streaming_grid.attach(self.streaming_key_label, 0, 13, 1, 1)
        self.streaming_key_entry = Gtk.Entry()
        controls_camera_streaming_grid.attach(self.streaming_key_entry, 1, 13, 1, 1)

        # Add this after creating other controls, but before attaching the grid to the notebook
        self.audio_visualizer = AudioVisualizer()
        controls_camera_streaming_grid.attach(self.audio_visualizer, 0, 5, 2, 1)



        self.webcam_size_label = Gtk.Label(label="Webcam Overlay Size:")
        controls_camera_streaming_grid.attach(self.webcam_size_label, 0, 11, 1, 1)

        self.webcam_size_scale = Gtk.Scale.new_with_range(Gtk.Orientation.HORIZONTAL, 10, 100, 5)
        self.webcam_size_scale.set_value(20)  # Default to 20% of screen size
        self.webcam_size_scale.connect("value-changed", self.on_webcam_size_changed)
        controls_camera_streaming_grid.attach(self.webcam_size_scale, 1, 11, 1, 1)



        # Add these lines after the other UI elements in the settings grid
        self.custom_save_checkbox = Gtk.CheckButton(label="Custom File Name and Location")
        self.custom_save_checkbox.connect("toggled", self.on_custom_save_toggled)
        settings_grid.attach(self.custom_save_checkbox, 0, 14, 1, 1)

        self.custom_filename_entry = Gtk.Entry()
        self.custom_filename_entry.set_placeholder_text("Enter custom file name")
        self.custom_filename_entry.set_sensitive(False)
        settings_grid.attach(self.custom_filename_entry, 1, 14, 1, 1)

        self.choose_location_button = Gtk.Button(label="Choose Save Location")
        self.choose_location_button.connect("clicked", self.on_choose_location_clicked)
        self.choose_location_button.set_sensitive(False)
        settings_grid.attach(self.choose_location_button, 0, 15, 1, 1)

        self.save_location_label = Gtk.Label(label="Default save location")
        settings_grid.attach(self.save_location_label, 1, 15, 1, 1)

        notebook.append_page(controls_camera_streaming_grid, Gtk.Label(label="Controls & Streaming"))

        about_page = Gtk.Grid()
        about_page.set_column_spacing(10)
        about_page.set_row_spacing(10)

        about_label = Gtk.Label(label="Seekers Screen Recorder\nVersion 2.0\n\nA powerful and easy-to-use screen recording application.")
        about_label.set_justify(Gtk.Justification.CENTER)
        about_page.attach(about_label, 0, 0, 1, 1)

        author_label = Gtk.Label(label="Authors:\nThe Seeker\nBen StormOS Dev (Tester/Contributor)\nRicki aka YughioMaster88 (Tester/Contributor)\nFishman aka Pescado (Tester/Contributor)")
        author_label.set_justify(Gtk.Justification.LEFT)
        about_page.attach(author_label, 0, 1, 1, 1)

        notes_text = (
            "Notes:\n"
            "1. Ensure you have sufficient disk space before recording.\n"
            "2. For best performance, close unnecessary applications.\n"
            "3. If you encounter any issues, please report them to the Seekers Project Team.\n"
            "4. Also please remember this program is a Work In Progress.\n"
            #"5. Hotkeys: Ctrl+Alt+R to start recording, Ctrl+Alt+S to stop recording, Ctrl+Alt+P to pause recording, Ctrl+Alt+E to resume recording"
        )
        notes_label = Gtk.Label(label=notes_text)
        notes_label.set_justify(Gtk.Justification.LEFT)
        about_page.attach(notes_label, 0, 2, 1, 1)

        notebook.append_page(about_page, Gtk.Label(label="About Us"))

        self.show_all()
        self.create_tray_icon()
        self.update_tray_tooltip()  # Add this line to initialize the tooltip with the current settings





    def on_custom_save_toggled(self, button):
        self.use_custom_save = button.get_active()
        self.custom_filename_entry.set_sensitive(self.use_custom_save)
        self.choose_location_button.set_sensitive(self.use_custom_save)
        self.update_tray_tooltip()

    def on_choose_location_clicked(self, button):
        dialog = Gtk.FileChooserDialog(
            title="Choose Save Location",
            parent=self,
            action=Gtk.FileChooserAction.SELECT_FOLDER,
        )
        dialog.add_buttons(
            Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OPEN, Gtk.ResponseType.OK
        )
        
        response = dialog.run()
        if response == Gtk.ResponseType.OK:
            self.custom_save_location = dialog.get_filename()
            self.save_location_label.set_text(self.custom_save_location)
            self.update_tray_tooltip()
        
        dialog.destroy()


    def on_custom_save_toggled_tray(self, widget):
        self.use_custom_save = widget.get_active()
        self.custom_save_checkbox.set_active(self.use_custom_save)
        self.on_custom_save_toggled(self.custom_save_checkbox)

    def on_webcam_size_changed(self, scale):
        self.webcam_size_percentage = scale.get_value()
        screen_width, screen_height = self.get_screen_resolution()
        webcam_width, webcam_height = self.calculate_webcam_size(screen_width, screen_height)
        webcam_position = self.get_webcam_position(screen_width, screen_height)
        self.update_tray_tooltip()
        # Update your overlay position dynamically here if necessary






    def on_combobox_changed(self, combo):
        self.update_tray_tooltip()



    def update_recent_recording_info_label(self):
        if self.completed_recordings:
            most_recent_recording = sorted(self.completed_recordings, key=lambda x: x[1], reverse=True)[0][0]
            if os.path.exists(most_recent_recording):
                recent_recording_filename = os.path.basename(most_recent_recording)
                self.recent_recording_info_label.set_text(f"Recent Recording: {recent_recording_filename}")
            else:
                self.recent_recording_info_label.set_text("Recent recording file not found")
        else:
            self.recent_recording_info_label.set_text("No recent recording")






    def on_window_delete_event(self, widget, event):
        self.hide()
        return True

    def on_journaling_mode_toggled(self, button):
        self.is_journal_mode = button.get_active()

    def get_available_resolutions(self):
        try:
            output = subprocess.check_output(['xrandr']).decode('utf-8')
            resolutions = re.findall(r'(\d+x\d+)\s+\d+\.\d+\*', output)
            return [(res, res) for res in resolutions]
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting available resolutions: {e}")
            return []

    def get_available_audio_inputs(self):
        try:
            output = subprocess.check_output(['pactl', 'list', 'sources']).decode('utf-8')
            inputs = re.findall(r'Name: (.+)', output)
            logging.debug(f"Available audio inputs: {inputs}")
            return inputs
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting available audio inputs: {e}")
            return []

    def get_active_windows(self):
        try:
            output = subprocess.check_output(['wmctrl', '-l']).decode('utf-8')
            windows = re.findall(r'0x[0-9a-fA-F]+\s+\d+\s+\S+\s+(.+)', output)
            return windows
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting active windows: {e}")
            return []

    def update_active_windows(self):
        self.active_window_combo.remove_all()
        active_windows = self.get_active_windows()
        for window in active_windows:
            self.active_window_combo.append_text(window)
        self.active_window_combo.set_active(0)

    def refresh_windows(self, widget):
        self.update_active_windows()
        self.status_label.set_text("Window list refreshed.")

    def cleanup_on_exit(self, signum=None, frame=None):
        if self.ffmpeg_process:
            try:
                self.ffmpeg_process.terminate()
                self.ffmpeg_process.wait(timeout=20)
            except subprocess.TimeoutExpired:
                logging.warning("FFmpeg process termination timed out. Attempting to kill with pkill...")
                try:
                    subprocess.run(['pkill', '-f', 'ffmpeg'])
                except Exception as e:
                    logging.error(f"Error killing FFmpeg process with pkill: {e}")
            except Exception as e:
                logging.error(f"Error terminating FFmpeg process: {e}")
            finally:
                self.ffmpeg_process = None

        try:
            subprocess.run(['pkill', '-f', 'ffplay'])
        except Exception as e:
            logging.error(f"Error closing ffplay windows: {e}")

        if hasattr(self, 'indicator') and self.indicator:
            self.indicator.set_status(AppIndicator3.IndicatorStatus.PASSIVE)
            del self.indicator

        if Gtk.main_level() > 0:
            Gtk.main_quit()

    def get_screen_resolution(self):
        try:
            output = subprocess.check_output(['xrandr']).decode('utf-8')
            match = re.search(r'current (\d+) x (\d+)', output)
            if match:
                return int(match.group(1)), int(match.group(2))
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting screen resolution: {e}")
        return 1920, 1080  # Default to 1920x1080 if resolution cannot be determined

    def calculate_webcam_size(self, screen_width, screen_height):
        webcam_width = int(screen_width * (self.webcam_size_percentage / 100))
        webcam_height = int(screen_height * (self.webcam_size_percentage / 100))
        return self.ensure_even_dimensions(webcam_width, webcam_height)




    def ensure_even_dimensions(self, width, height):
        if width % 2 != 0:
            width += 1
        if height % 2 != 0:
            height += 1
        return width, height



    def start_recording(self, widget):
        if not self.is_recording:
            logging.debug("Record button clicked, starting recording...")

            # Disable record buttons
            self.settings_record_button.set_sensitive(False)
            self.controls_record_button.set_sensitive(False)
            if hasattr(self, 'tray_record_item'):
                self.tray_record_item.set_sensitive(False)

            logging.debug(f"Settings record button sensitivity: {self.settings_record_button.get_sensitive()}")
            logging.debug(f"Controls record button sensitivity: {self.controls_record_button.get_sensitive()}")

            self.is_recording = True
            self.start_time = time.time()

            # Get recording settings
            selected_size = self.recording_size_combo.get_active_text()
            selected_output_format = ["mkv", "mp4", "webm"][self.output_format_combo.get_active()]
            selected_recording_area = self.recording_areas[self.recording_area_combo.get_active()]
            selected_video_codec = self.video_codecs[self.video_codec_combo.get_active()]
            selected_audio_codec = self.audio_codecs[self.audio_codec_combo.get_active()]
            selected_audio_config = self.audio_input_configs[self.audio_input_config_combo.get_active()]
            selected_streaming_service = self.streaming_combo.get_active_text()
            streaming_key = self.streaming_key_entry.get_text()

            self.is_custom_region = (selected_recording_area == "Custom Region")

            if selected_size is None:
                self.status_label.set_text("Error: No recording size selected.")
                return

            if "x" in selected_size:
                width, height = map(int, selected_size.split('x'))
                width, height = self.ensure_even_dimensions(width, height)
            else:
                self.status_label.set_text("Error: Invalid recording size.")
                return

            # Prepare output filename
            timestamp = time.strftime("%m-%d-%Y_%I-%M-%S%p")
            if self.use_custom_save:
                custom_filename = self.custom_filename_entry.get_text()
                if custom_filename:
                    filename_prefix = custom_filename
                else:
                    filename_prefix = "recording"
                self.output_filename = os.path.join(self.custom_save_location, f"{filename_prefix}_{timestamp}.{selected_output_format}")
            else:
                filename_prefix = "Journal" if self.is_journal_mode else "recording"
                if self.is_keep_mode:
                    filename_prefix += "_keep"
                self.output_filename = os.path.join(self.output_directory, f"{filename_prefix}_{timestamp}.{selected_output_format}")

            os.makedirs(os.path.dirname(self.output_filename), exist_ok=True)

            # Prepare audio inputs
            primary_audio_input = self.audio_inputs[self.audio_input_combo.get_active()]
            secondary_audio_input = self.secondary_audio_inputs[self.secondary_audio_input_combo.get_active()]

            logging.info(f"Primary audio input: {primary_audio_input}")
            logging.info(f"Secondary audio input: {secondary_audio_input}")

            # Prepare FFmpeg command
            input_args = ["-thread_queue_size", "1024"]

            if self.is_webcam_overlay:
                input_args.extend(["-itsoffset", "-1.1"])

            # Add video input based on selected recording area
            if selected_recording_area == "Full Screen":
                input_args.extend(["-f", "x11grab", "-framerate", "30", "-video_size", f"{width}x{height}", "-i", ":0.0"])
            elif selected_recording_area == "Camera Only":
                selected_camera = self.camera_combo.get_active_text()
                if selected_camera:
                    try:
                        camera_index = self.extract_camera_index(selected_camera)
                        device = f"/dev/video{camera_index}"
                        resolution = self.camera_resolution_combo.get_active_text()
                        input_args.extend(["-f", "v4l2", "-video_size", resolution, "-framerate", "30", "-i", device])
                        input_args.extend(["-f", "alsa", "-i", "hw:1"])
                    except ValueError as e:
                        self.status_label.set_text(f"Error: {e}")
                        return
                else:
                    self.status_label.set_text("Error: No camera selected.")
                    return
            elif selected_recording_area == "Active Window":
                selected_window = self.active_window_combo.get_active_text()
                if selected_window:
                    window_info = self.get_window_info_by_name(selected_window)
                    if window_info:
                        x_pos, y_pos, width, height = window_info
                        width, height = self.ensure_even_dimensions(width, height)
                        input_args.extend(["-f", "x11grab", "-framerate", "30", "-video_size", f"{width}x{height}", "-i", f":0.0+{x_pos},{y_pos}"])
            elif selected_recording_area == "Custom Region":
                if self.recording_region:
                    x, y, w, h = self.recording_region
                    w, h = self.ensure_even_dimensions(w, h)
                    input_args.extend(["-f", "x11grab", "-framerate", "30", "-video_size", f"{w}x{h}", "-i", f":0.0+{x},{y}"])
                else:
                    self.status_label.set_text("Error: No custom region selected.")
                    return

            # Prepare audio filters
            audio_filters = "aresample=async=1:min_hard_comp=0.100000:first_pts=0"
            if selected_audio_codec == "aac":
                audio_filters += ", volume=1.5, equalizer=f=1000:t=q:w=1:g=-5"

            # Add audio input based on selected configuration
            audio_args = []
            if selected_audio_config == "Primary Only":
                audio_args.extend(["-f", "pulse", "-i", primary_audio_input, "-af", audio_filters])
            elif selected_audio_config == "Secondary Only":
                audio_args.extend(["-f", "pulse", "-i", secondary_audio_input, "-af", audio_filters])

            buffer_args = ["-bufsize", "750M", "-rtbufsize", "750M"]
            sync_args = ["-vsync", "1", "-async", "1"]

            # Add webcam overlay if enabled
            if self.is_webcam_overlay:
                selected_camera = self.camera_combo.get_active_text()
                if selected_camera:
                    try:
                        camera_index = self.extract_camera_index(selected_camera)
                        webcam_device = f"/dev/video{camera_index}"
                        screen_width, screen_height = self.get_screen_resolution()
                        webcam_width, webcam_height = self.calculate_webcam_size(screen_width, screen_height)
                        input_args.extend(["-f", "v4l2", "-video_size", f"{webcam_width}x{webcam_height}", "-framerate", "30", "-i", webcam_device])
                        filter_args = [
                            "-filter_complex", f"[0:v]fps=fps=30[v0];[1:v]fps=fps=30[v1];[v0][v1]overlay={self.get_webcam_position(width, height)},fps=fps=30"
                        ]
                    except ValueError as e:
                        self.status_label.set_text(f"Error: {e}")
                        return
                else:
                    self.status_label.set_text("Error: No webcam selected.")
                    return
            else:
                filter_args = []

            # Prepare output arguments based on streaming service
            if selected_streaming_service == "None":
                output_args = ["-c:v", selected_video_codec, "-c:a", selected_audio_codec, "-preset", "ultrafast", "-crf", "23", "-b:v", "5M", "-maxrate", "5M", "-bufsize", "10M", "-b:a", "320k", self.output_filename]
            elif selected_streaming_service == "Twitch":
                output_args = ["-f", "flv", f"rtmp://live.twitch.tv/app/{streaming_key}"]
            elif selected_streaming_service == "YouTube":
                output_args = ["-f", "flv", f"rtmp://a.rtmp.youtube.com/live2/{streaming_key}"]
            else:
                self.status_label.set_text("Error: Invalid streaming service selected.")
                return

            # Combine all arguments into final command
            command = ["ffmpeg", "-y"] + input_args + audio_args + buffer_args + sync_args + filter_args + output_args

            logging.info(f"FFmpeg command: {' '.join(command)}")

            # Set up audio monitor for visualizer
            self.setup_audio_monitor()

            # Start recording process and monitoring threads
            threading.Thread(target=self.start_ffmpeg_process, args=(command,)).start()
            threading.Thread(target=self.monitor_file_size).start()
            threading.Thread(target=self.update_tray_info).start()
            threading.Thread(target=self.update_tray_tooltip_continuously).start()

            self.update_tray_status(True)

            # Enable the stop button in the settings window
            self.stop_button_settings.set_sensitive(True)

            # Handle timer if active
            if self.timer_active:
                hours = int(self.timer_hours_combo.get_active_text() or "0")
                minutes = int(self.timer_minutes_combo.get_active_text() or "0")
                self.timer_seconds = hours * 3600 + minutes * 60
                if self.timer_seconds <= 0:
                    logging.warning("Timer is active but duration is set to 0 seconds. No timer will be used.")
                    self.timer_active = False
                else:
                    logging.info(f"Timer active. Duration: {self.timer_seconds} seconds")
                    self.start_timer()
            else:
                logging.info("Timer not active")

            # Update UI
            GLib.idle_add(self.update_ui_for_recording_start)




#-------------------------TRIM METHOD-----------------------------

    def trim_video(self, widget):
        if not self.completed_recordings:
            self.status_label.set_text("No recordings available to trim.")
            return

        most_recent_recording = sorted(self.completed_recordings, key=lambda x: x[1], reverse=True)[0][0]
        
        dialog = VideoTrimmingDialog(self, most_recent_recording)
        response = dialog.run()

        if response == Gtk.ResponseType.OK:
            start_time, end_time = dialog.get_trim_times()
            dialog.destroy()

            # Perform trimming
            output_path = os.path.splitext(most_recent_recording)[0] + "_trimmed" + os.path.splitext(most_recent_recording)[1]
            command = [
                'ffmpeg', '-i', most_recent_recording,
                '-ss', str(start_time),
                '-to', str(end_time),
                '-c', 'copy',  # This copies the streams without re-encoding
                output_path
            ]

            try:
                subprocess.run(command, check=True)
                self.status_label.set_text(f"Video trimmed successfully: {output_path}")
                # Add the trimmed video to completed recordings
                self.completed_recordings.append((output_path, time.time()))
                self.update_recent_recording_info_label()
            except subprocess.CalledProcessError as e:
                self.status_label.set_text(f"Error trimming video: {e}")
        else:
            dialog.destroy()

#-------------------------END TRIM METHOD-------------------------






    def setup_audio_monitor(self):
        pipeline_str = f"pulsesrc device={self.audio_input_combo.get_active_text()} ! level ! fakesink"
        self.audio_monitor = Gst.parse_launch(pipeline_str)
        bus = self.audio_monitor.get_bus()
        bus.add_signal_watch()
        bus.connect('message::element', self.on_audio_level)
        self.audio_monitor.set_state(Gst.State.PLAYING)

    def on_audio_level(self, bus, message):
        if message.get_structure().get_name() == 'level':
            structure = message.get_structure()
            level = structure.get_value('peak')[0]
            normalized_level = min(max(0, (level + 60) / 60), 1)  # Normalize to 0-1 range
            GLib.idle_add(self.audio_visualizer.update_level, normalized_level)



    def start_timer(self):
        if self.timer_thread and self.timer_thread.is_alive():
            logging.info("Timer thread already running. Stopping existing timer.")
            self.timer_active = False
            self.timer_thread.join()

        self.timer_active = True
        self.timer_thread = threading.Thread(target=self.timer_countdown)
        self.timer_thread.start()
        logging.info("Timer thread started")



    def update_ui_for_recording_start(self):
        logging.debug("Updating UI for recording start...")
        self.status_label.set_text("Recording...")
        self.settings_record_button.set_sensitive(False)
        self.controls_record_button.set_sensitive(False)
        self.stop_button_settings.set_sensitive(True)  # Enable the stop button in the settings window
        self.stop_button.set_sensitive(True)  # Enable the stop button in the controls window
        if hasattr(self, 'tray_record_item'):
            self.tray_record_item.set_sensitive(False)
        self.pause_button.set_sensitive(True)
        self.resume_button.set_sensitive(False)
        
        # Update tray icon and tooltip
        self.update_tray_status(True)
        self.update_tray_tooltip()
        
        logging.debug("UI update for recording start completed")
        return False  # Important for GLib.idle_add

    def update_ui_for_recording_stop(self):
        logging.debug("Updating UI for recording stop...")
        
        self.status_label.set_text("Recording stopped.")
        self.settings_record_button.set_sensitive(True)
        self.controls_record_button.set_sensitive(True)
        logging.debug(f"Settings record button sensitivity after stop: {self.settings_record_button.get_sensitive()}")
        logging.debug(f"Controls record button sensitivity after stop: {self.controls_record_button.get_sensitive()}")
        
        if hasattr(self, 'tray_record_item'):
            self.tray_record_item.set_sensitive(True)
        self.stop_button.set_sensitive(False)
        self.stop_button_settings.set_sensitive(False)  # Disable the stop button in the settings window
        self.pause_button.set_sensitive(False)
        self.resume_button.set_sensitive(False)

        # Update file size and elapsed time one last time
        if self.output_filename and os.path.exists(self.output_filename):
            final_size = os.path.getsize(self.output_filename)
            self.file_size_label.set_text(f"File size: {self.convert_size(final_size)}")
        
        elapsed_time = time.time() - self.start_time
        self.elapsed_time_menu_item.set_label(f"Elapsed Time: {self.format_time(elapsed_time)}")

        # Reset timer if it was active
        if hasattr(self, 'timer_checkbox'):
            self.timer_checkbox.set_active(False)
            if hasattr(self, 'timer_hours_combo'):
                self.timer_hours_combo.set_active(0)
            if hasattr(self, 'timer_minutes_combo'):
                self.timer_minutes_combo.set_active(0)

        # Update tray icon and tooltip
        self.update_tray_status(False)
        self.update_tray_tooltip()

        logging.debug("UI update for recording stop completed")
        return False  # Important for GLib.idle_add





    def on_timer_toggled(self, button):
        self.timer_active = button.get_active()
        self.tray_timer_item.set_active(self.timer_active)  # Synchronize with tray icon menu
        self.update_tray_tooltip()
        if self.timer_active:
            hours = int(self.timer_hours_combo.get_active_text() or "0")
            minutes = int(self.timer_minutes_combo.get_active_text() or "0")
            self.timer_seconds = hours * 3600 + minutes * 60
            self.update_timer_display(self.timer_seconds)
            self.timer_completed = False  # Reset the flag when timer is enabled
            if self.is_recording:
                self.start_timer()
            else:
                self.status_label.set_text("Timer enabled")
        else:
            self.status_label.set_text("Timer disabled")
            if self.timer_thread and self.timer_thread.is_alive():
                self.timer_thread.join()
            self.timer_thread = None
            self.timer_seconds = 0

    def on_timer_toggled_tray(self, widget):
        self.timer_active = widget.get_active()
        self.timer_checkbox.set_active(self.timer_active)  # Synchronize with main window
        self.on_timer_toggled(self.timer_checkbox)

    def de_toggle_timer_checkbox(self):
        self.timer_checkbox.set_active(False)
        self.tray_timer_item.set_active(False)  # Synchronize with tray icon menu
        self.timer_hours_combo.set_active(0)  # Reset hours to 0
        self.timer_minutes_combo.set_active(0)  # Reset minutes to 0
        self.on_timer_toggled(self.timer_checkbox)  # Call this to update any related UI elements
        self.update_tray_tooltip()  # Update the tray tooltip to reflect the changes


    def on_timer_changed(self, widget):
        if self.timer_active:
            hours = int(self.timer_hours_combo.get_active_text() or "0")
            minutes = int(self.timer_minutes_combo.get_active_text() or "0")
            self.timer_seconds = hours * 3600 + minutes * 60
            self.update_timer_display(self.timer_seconds)
            self.update_tray_tooltip()
            if self.is_recording and not self.timer_thread:
                self.start_timer()




    def timer_countdown(self):
        logging.info(f"Starting timer countdown from {self.timer_seconds} seconds")
        start_time = time.time()
        while self.is_recording and self.timer_active and self.timer_seconds > 0:
            elapsed_time = time.time() - start_time
            remaining = max(0, self.timer_seconds - elapsed_time)

            logging.debug(f"Timer countdown: remaining={remaining:.2f}, is_recording={self.is_recording}, timer_active={self.timer_active}")

            if remaining <= 0:
                logging.info("Timer reached 0. Attempting to stop recording.")
                self.timer_completed = True
                GLib.idle_add(self.update_timer_display, 0)
                GLib.idle_add(self.safe_stop_recording)
                GLib.idle_add(self.de_toggle_timer_checkbox)  # Deactivate timer in both main window and tray icon menu
                break
            else:
                GLib.idle_add(self.update_timer_display, int(remaining))

            time.sleep(1)

        if not self.is_recording:
            logging.info("Timer countdown interrupted: Recording stopped")
        elif not self.timer_active:
            logging.info("Timer countdown interrupted: Timer deactivated")
        else:
            logging.info("Timer countdown finished")

        self.timer_thread = None
        logging.info("Timer thread ended")


    def de_toggle_timer_checkbox(self):
        self.timer_checkbox.set_active(False)
        self.timer_hours_combo.set_active(0)  # Reset hours to 0
        self.timer_minutes_combo.set_active(0)  # Reset minutes to 0
        self.on_timer_toggled(self.timer_checkbox)  # Call this to update any related UI elements

        # Update the tray icon menu item
        if hasattr(self, 'tray_timer_item'):
            self.tray_timer_item.set_active(False)





    def safe_stop_recording(self):
        logging.info("safe_stop_recording called")
        if self.is_recording:
            self.stop_recording(None)
        else:
            logging.warning("safe_stop_recording called but is_recording is already False")
        # De-toggle the timer in the main window
        self.timer_checkbox.set_active(False)
        # De-toggle the timer in the tray icon menu
        for item in self.indicator.get_menu().get_children():
            if isinstance(item, Gtk.CheckMenuItem) and item.get_label() == "Enable Timer":
                item.set_active(False)
        return False  # Important for GLib.idle_add






    def update_timer_display(self, remaining_seconds):
        minutes, seconds = divmod(remaining_seconds, 60)
        hours, minutes = divmod(minutes, 60)
        timer_text = f"Timer Remaining: {hours:02d}:{minutes:02d}:{seconds:02d}"
        self.status_label.set_text(f"Recording... {timer_text}")
        return False


    def get_webcam_position(self, screen_width, screen_height):
        position = self.webcam_position_combo.get_active_text()
        webcam_width, webcam_height = map(int, self.webcam_resolution.split('x'))
        
        # Ensure the webcam overlay doesn't exceed a certain percentage of the screen
        max_width = int(screen_width * 0.3)
        max_height = int(screen_height * 0.3)
        
        if webcam_width > max_width or webcam_height > max_height:
            scale = min(max_width / webcam_width, max_height / webcam_height)
            webcam_width = int(webcam_width * scale)
            webcam_height = int(webcam_height * scale)

        if position == "top-left":
            return f"10:10:{webcam_width}:{webcam_height}"
        elif position == "top-right":
            return f"{screen_width - webcam_width - 10}:10:{webcam_width}:{webcam_height}"
        elif position == "bottom-left":
            return f"10:{screen_height - webcam_height - 10}:{webcam_width}:{webcam_height}"
        elif position == "bottom-right":
            return f"{screen_width - webcam_width - 10}:{screen_height - webcam_height - 10}:{webcam_width}:{webcam_height}"
        elif position == "center":
            return f"{(screen_width - webcam_width) // 2}:{(screen_height - webcam_height) // 2}:{webcam_width}:{webcam_height}"
        else:
            return f"10:10:{webcam_width}:{webcam_height}"  # Default to top-left if position is not recognized






    def get_webcam_position(self, screen_width, screen_height):
        position = self.webcam_position_combo.get_active_text()
        webcam_width, webcam_height = self.calculate_webcam_size(screen_width, screen_height)

        if position == "top-left":
            return f"10:10"
        elif position == "top-right":
            return f"{screen_width - webcam_width - 10}:10"
        elif position == "bottom-left":
            return f"10:{screen_height - webcam_height - 10}"
        elif position == "bottom-right":
            return f"{screen_width - webcam_width - 10}:{screen_height - webcam_height - 10}"
        elif position == "center":
            return f"{(screen_width - webcam_width) // 2}:{(screen_height - webcam_height) // 2}"
        else:
            return f"10:10"  # Default to top-left if position is not recognized


    def start_ffmpeg_process(self, command):
        try:
            self.ffmpeg_process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            self.monitor_ffmpeg_output()
            self.ffmpeg_process.wait()
        except Exception as e:
            logging.error(f"Error starting FFmpeg process: {e}")
        finally:
            self.is_recording = False
            GLib.idle_add(self.update_status, "Recording stopped.")

    def monitor_ffmpeg_output(self):
        if self.ffmpeg_process:
            while self.ffmpeg_process.poll() is None:
                rlist, _, _ = select.select([self.ffmpeg_process.stdout, self.ffmpeg_process.stderr], [], [])
                for stream in rlist:
                    output = stream.readline()
                    if output:
                        print(output.strip().decode('utf-8'))

    def pause_recording(self, widget):
        if self.is_recording and not self.is_paused:
            if self.ffmpeg_process:
                self.ffmpeg_process.send_signal(signal.SIGSTOP)
                self.is_paused = True
                self.status_label.set_text("Recording paused.")
                self.update_tray_status(paused=True)
                self.pause_button.set_sensitive(False)
                self.resume_button.set_sensitive(True)

    def resume_recording(self, widget):
        if self.is_recording and self.is_paused:
            if self.ffmpeg_process:
                self.ffmpeg_process.send_signal(signal.SIGCONT)
                self.is_paused = False
                self.status_label.set_text("Recording resumed.")
                self.update_tray_status(resumed=True)
                self.pause_button.set_sensitive(True)
                self.resume_button.set_sensitive(False)

    def update_status(self, status_text):
        self.status_label.set_text(status_text)
        self.settings_record_button.set_sensitive(True)
        self.controls_record_button.set_sensitive(True)
        self.stop_button.set_sensitive(False)
        self.pause_button.set_sensitive(False)
        self.resume_button.set_sensitive(False)
        if hasattr(self, 'tray_record_item'):
            self.tray_record_item.set_sensitive(True)
        self.update_recent_recording_menu_item()
        return False

    def update_tray_info(self):
        while self.is_recording:
            file_size_text = f"File Size: {self.convert_size(self.file_size)}"
            elapsed_time = time.time() - self.start_time
            elapsed_time_text = f"Elapsed Time: {self.format_time(elapsed_time)}"
            recording_status_text = "Status: Recording..."

            if self.completed_recordings:
                sorted_recordings = sorted(self.completed_recordings, key=lambda x: x[1], reverse=True)
                most_recent_path = sorted_recordings[0][0]
                most_recent_filename = os.path.basename(most_recent_path)
                try:
                    if os.path.exists(most_recent_path):
                        most_recent_file_size = self.convert_size(os.path.getsize(most_recent_path))
                        recent_recording_text = f"Recent Recording: {most_recent_filename} ({most_recent_file_size})"
                    else:
                        recent_recording_text = f"Recent Recording: {most_recent_filename} (File not found)"
                except Exception as e:
                    logging.error(f"Error accessing recent recording: {e}")
                    recent_recording_text = "Error accessing recent recording"
            else:
                recent_recording_text = "No recent recording"

            GLib.idle_add(self.file_size_menu_item.set_label, file_size_text)
            GLib.idle_add(self.elapsed_time_menu_item.set_label, elapsed_time_text)
            GLib.idle_add(self.recording_status_menu_item.set_label, recording_status_text)
            GLib.idle_add(self.recent_recording_menu_item.set_label, recent_recording_text)

            time.sleep(1)

    def update_tray_status(self, recording=False, paused=False, resumed=False, duration=None, file_size=None):
        if recording:
            status = "Recording..."
            icon_name = "media-record"
            if duration is not None:
                status += f" Duration: {self.format_time(duration)}"
            if file_size is not None:
                status += f" File Size: {self.convert_size(file_size)}"
        elif paused:
            status = "Recording paused"
            icon_name = "media-playback-pause"
        elif resumed:
            status = "Recording resumed"
            icon_name = "media-record"
        else:
            status = "Not Recording"
            icon_name = "media-playback-stop"

        GLib.idle_add(self.recording_status_menu_item.set_label, status)
        GLib.idle_add(self.indicator.set_icon_full, icon_name, status)

    def update_tray_tooltip(self):
        settings = []

        def safe_get_text(combo):
            try:
                return combo.get_active_text() or "Not selected"
            except:
                return "Error"

        attribute_map = {
            'audio_input_config_combo': "Audio Input Config",
            'recording_size_combo': "Recording Size",
            'video_codec_combo': "Video Codec",
            'audio_codec_combo': "Audio Codec",
            'audio_input_combo': "Primary Audio Input",
            'secondary_audio_input_combo': "Secondary Audio Input",
            'recording_area_combo': "Recording Area",
            'output_format_combo': "Output Format",
            'active_window_combo': "Active Window",
            'camera_combo': "Camera",
            'camera_resolution_combo': "Camera Resolution",
            'webcam_position_combo': "Webcam Position",
            'streaming_combo': "Streaming Service"
        }

        for attr, label in attribute_map.items():
            if hasattr(self, attr):
                combo = getattr(self, attr)
                if isinstance(combo, Gtk.ComboBoxText):
                    settings.append(f"{label}: {safe_get_text(combo)}")

        if hasattr(self, 'is_webcam_overlay'):
            settings.append(f"Webcam Overlay: {'Enabled' if self.is_webcam_overlay else 'Disabled'}")
        
        if hasattr(self, 'streaming_key_entry'):
            key = self.streaming_key_entry.get_text()
            settings.append(f"Streaming Key: {'******' if key else 'N/A'}")

        if hasattr(self, 'timer_active') and self.timer_active:
            if hasattr(self, 'timer_hours_combo') and hasattr(self, 'timer_minutes_combo'):
                hours = safe_get_text(self.timer_hours_combo)
                minutes = safe_get_text(self.timer_minutes_combo)
                timer_set_for = f"{hours}h {minutes}m"
                settings.append(f"Timer Active: Yes\nTimer Set For: {timer_set_for}")
        else:
            settings.append("Timer Active: No")

        # Add custom save information
        if self.use_custom_save:
            settings.append("Custom Save: Enabled")
            settings.append(f"Save Location: {self.custom_save_location}")
            custom_filename = self.custom_filename_entry.get_text()
            settings.append(f"Custom Filename: {custom_filename if custom_filename else 'Not set'}")
        else:
            settings.append("Custom Save: Disabled")

        self.static_tooltip_text = "\n".join(settings)
        
        if hasattr(self, 'indicator') and self.indicator:
            try:
                self.indicator.set_title(self.static_tooltip_text)
            except Exception as e:
                print(f"Error setting indicator title: {e}")

        # If recording is in progress, add dynamic information
        if self.is_recording:
            file_size_text = f"File Size: {self.convert_size(self.file_size)}"
            elapsed_time = time.time() - self.start_time
            elapsed_time_text = f"Elapsed Time: {self.format_time(elapsed_time)}"
            file_name_text = f"File Name: {os.path.basename(self.output_filename) if self.output_filename else 'N/A'}"
            recording_status_text = "Recording Info" if not self.is_paused else "Recording Paused"

            if self.timer_active:
                elapsed_time_since_start = time.time() - self.start_time
                timer_remaining_seconds = max(self.timer_seconds - elapsed_time_since_start, 0)
                timer_remaining = f"Timer Remaining: {self.format_time(timer_remaining_seconds)}"
                dynamic_info = f"\n{recording_status_text}\n{file_name_text}\n{file_size_text}\n{elapsed_time_text}\n{timer_remaining}"
            else:
                dynamic_info = f"\n{recording_status_text}\n{file_name_text}\n{file_size_text}\n{elapsed_time_text}"

            full_tooltip = f"{self.static_tooltip_text}\n{dynamic_info}"
            
            if hasattr(self, 'indicator') and self.indicator:
                try:
                    self.indicator.set_title(full_tooltip)
                except Exception as e:
                    print(f"Error setting indicator title: {e}")



    def update_tray_tooltip_continuously(self):
        while self.is_recording or self.is_paused:
            file_size_text = f"File Size: {self.convert_size(self.file_size)}"
            elapsed_time = time.time() - self.start_time
            elapsed_time_text = f"Elapsed Time: {self.format_time(elapsed_time)}"
            file_name_text = f"File Name: {os.path.basename(self.output_filename) if self.output_filename else 'N/A'}"
            recording_status_text = "Recording Info" if self.is_recording else "Recording Paused"

            if self.timer_active:
                elapsed_time_since_start = time.time() - self.start_time
                timer_remaining_seconds = max(self.timer_seconds - elapsed_time_since_start, 0)
                timer_remaining = f"Timer Remaining: {self.format_time(timer_remaining_seconds)}"
                tooltip_text = (
                    f"{self.static_tooltip_text}\n"
                    f"\n{recording_status_text}\n{file_name_text}\n{file_size_text}\n{elapsed_time_text}\n{timer_remaining}"
                )
            else:
                tooltip_text = (
                    f"{self.static_tooltip_text}\n"
                    f"\n{recording_status_text}\n{file_name_text}\n{file_size_text}\n{elapsed_time_text}"
                )

            GLib.idle_add(self.indicator.set_title, tooltip_text)
            GLib.idle_add(self.elapsed_time_menu_item.set_label, elapsed_time_text)
            time.sleep(1)  # Update every second

        # After the recording has stopped
        file_size_text = f"File Size: {self.convert_size(self.file_size)}"
        elapsed_time = time.time() - self.start_time
        elapsed_time_text = f"Elapsed Time: {self.format_time(elapsed_time)}"
        file_name_text = f"File Name: {os.path.basename(self.output_filename) if self.output_filename else 'N/A'}"

        tooltip_text = (
            f"{self.static_tooltip_text}\n"
            f"\nRecording Stopped\n{file_name_text}\n{file_size_text}\n{elapsed_time_text}"
        )
        GLib.idle_add(self.indicator.set_title, tooltip_text)
        GLib.idle_add(self.elapsed_time_menu_item.set_label, elapsed_time_text)





    #def update_recent_recordings_controls(self):
        #if not self.completed_recordings:
       #     self.recent_recordings_label_controls.set_text("Recent Recordings:\nNone")
        #else:
            #recent_recordings_text = "Recent Recordings:\n"
            #for recording, timestamp in sorted(self.completed_recordings, key=lambda x: x[1], reverse=True):
             #   filename = os.path.basename(recording)
             #   recent_recordings_text += f"{filename}\n"
            #self.recent_recordings_label_controls.set_text(recent_recordings_text)



    def stop_recording(self, widget):
        if self.is_recording:
            logging.debug("Stopping recording...")
            self.is_recording = False

            # Disable stop button and enable record button
            self.stop_button_settings.set_sensitive(False)
            self.stop_button.set_sensitive(False)
            self.settings_record_button.set_sensitive(True)
            self.controls_record_button.set_sensitive(True)
            if hasattr(self, 'tray_record_item'):
                self.tray_record_item.set_sensitive(True)

            self.status_label.set_text("Recording stopped.")

            # Stop the FFmpeg recording process
            if self.ffmpeg_process:
                try:
                    logging.debug("Terminating ffmpeg process")
                    self.ffmpeg_process.terminate()
                    self.ffmpeg_process.wait(timeout=20)
                except subprocess.TimeoutExpired:
                    logging.warning("FFmpeg process termination timed out. Attempting to kill...")
                    try:
                        self.ffmpeg_process.kill()
                        self.ffmpeg_process.wait(timeout=5)
                    except subprocess.TimeoutExpired:
                        logging.error("FFmpeg process could not be killed.")
                    except Exception as e:
                        logging.error(f"Error killing FFmpeg process: {e}")
                except Exception as e:
                    logging.error(f"Error terminating FFmpeg process: {e}")
                finally:
                    self.ffmpeg_process = None
                    logging.debug("ffmpeg process terminated")

            # Stop the audio monitor for the visualizer
            if hasattr(self, 'audio_monitor'):
                self.audio_monitor.set_state(Gst.State.NULL)
                del self.audio_monitor

            # Add the recording to the recent recordings list
            if self.output_filename:
                self.completed_recordings.append((self.output_filename, time.time()))
                self.update_recent_recording_info_label()

            # Reset timer if it was active
            self.timer_active = False
            self.timer_seconds = 0
            if self.timer_thread and self.timer_thread.is_alive():
                self.timer_thread.join(timeout=5)  # Wait for up to 5 seconds
                if self.timer_thread.is_alive():
                    logging.warning("Timer thread did not finish in time")
            self.timer_thread = None

            # Reset recording area if it was a custom region
            if self.is_custom_region:
                self.reset_recording_area()

            # Update UI elements
            GLib.idle_add(self.update_ui_for_recording_stop)




    def update_ui_for_recording_stop(self):
        logging.debug("Updating UI for recording stop...")
        
        self.status_label.set_text("Recording stopped.")
        self.settings_record_button.set_sensitive(True)
        self.controls_record_button.set_sensitive(True)
        logging.debug(f"Settings record button sensitivity after stop: {self.settings_record_button.get_sensitive()}")
        logging.debug(f"Controls record button sensitivity after stop: {self.controls_record_button.get_sensitive()}")
        
        if hasattr(self, 'tray_record_item'):
            self.tray_record_item.set_sensitive(True)
        self.stop_button.set_sensitive(False)
        self.pause_button.set_sensitive(False)
        self.resume_button.set_sensitive(False)

        # Update file size and elapsed time one last time
        if self.output_filename and os.path.exists(self.output_filename):
            final_size = os.path.getsize(self.output_filename)
            self.file_size_label.set_text(f"File size: {self.convert_size(final_size)}")
        
        elapsed_time = time.time() - self.start_time
        self.elapsed_time_menu_item.set_label(f"Elapsed Time: {self.format_time(elapsed_time)}")

        # Reset timer if it was active
        if hasattr(self, 'timer_checkbox'):
            self.timer_checkbox.set_active(False)
            if hasattr(self, 'timer_hours_combo'):
                self.timer_hours_combo.set_active(0)
            if hasattr(self, 'timer_minutes_combo'):
                self.timer_minutes_combo.set_active(0)

        # Update tray icon and tooltip
        self.update_tray_status(False)
        self.update_tray_tooltip()
        
        # Update recent recording info label
        self.update_recent_recording_info_label()

        logging.debug("UI update for recording stop completed")
        return False  # Important for GLib.idle_add



    def stop_recording_from_timer(self):
        logging.info("stop_recording_from_timer called")
        self.stop_recording(None)
        return False  # Important for GLib.idle_add


    def de_toggle_timer_checkbox(self):
        self.timer_checkbox.set_active(False)
        self.timer_hours_combo.set_active(0)  # Reset hours to 0
        self.timer_minutes_combo.set_active(0)  # Reset minutes to 0
        self.on_timer_toggled(self.timer_checkbox)  # Call this to update any related UI elements
        self.update_tray_tooltip()  # Update the tray tooltip to reflect the changes




    def capture_active_window(self, widget):
        window_info = self.get_active_window_info()
        if window_info:
            x_pos, y_pos, width, height = window_info
            self.custom_region_start_x = x_pos
            self.custom_region_start_y = y_pos
            self.custom_region_end_x = x_pos + width
            self.custom_region_end_y = y_pos + height
            self.recording_region = (x_pos, y_pos, width, height)
            self.status_label.set_text("Active window captured for recording.")

    def select_custom_region(self, widget=None):
        # Set the recording area to "Custom Region"
        self.recording_area_combo.set_active(self.recording_areas.index("Custom Region"))
        
        self.is_custom_region = True


        # Minimize the main window
        self.main_window.iconify()

        def run_xrectsel():
            try:
                output = subprocess.check_output(['xrectsel']).decode('utf-8').strip()
                if output:
                    match = re.match(r'(\d+)x(\d+)\+(\d+)\+(\d+)', output)
                    if match:
                        width, height, x, y = map(int, match.groups())
                        self.custom_region_start_x = x
                        self.custom_region_start_y = y
                        self.custom_region_end_x = x + width
                        self.custom_region_end_y = y + height
                        self.recording_region = (x, y, width, height)
                        GLib.idle_add(self.status_label.set_text, "Custom region selected. Recording will start now.")

                        time.sleep(0.5)

                        GLib.idle_add(self.start_recording, None)
                    else:
                        logging.error(f"Unexpected output format: {output}")
                        GLib.idle_add(self.status_label.set_text, f"Unexpected output format: {output}")
                        return None
            except subprocess.CalledProcessError as e:
                logging.error(f"Error selecting custom region: {e}")
                GLib.idle_add(self.status_label.set_text, f"Error selecting custom region: {e}")
                return None

        threading.Thread(target=run_xrectsel).start()

    def get_active_window_info(self):
        try:
            output = subprocess.check_output(['xwininfo', '-id', self.get_active_window_id()]).decode('utf-8')
            x_pos = int(re.search(r'Absolute upper-left X:\s+(\d+)', output).group(1))
            y_pos = int(re.search(r'Absolute upper-left Y:\s+(\d+)', output).group(1))
            width = int(re.search(r'Width:\s+(\d+)', output).group(1))
            height = int(re.search(r'Height:\s+(\d+)', output).group(1))
            return (x_pos, y_pos, width, height)
        except Exception as e:
            self.status_label.set_text(f"Error getting active window info: {e}")
            return None

    def get_active_window_id(self):
        try:
            output = subprocess.check_output(['xdotool', 'getactivewindow']).decode('utf-8').strip()
            return output
        except Exception as e:
            self.status_label.set_text(f"Error getting active window ID: {e}")
            return None

    def get_window_id_by_name(self, window_name):
        try:
            output = subprocess.check_output(['wmctrl', '-l']).decode('utf-8')
            for line in output.splitlines():
                if window_name in line:
                    return line.split()[0]
            return None
        except Exception as e:
            self.status_label.set_text(f"Error getting window ID by name: {e}")
            return None

    def get_window_info_by_name(self, window_name):
        window_id = self.get_window_id_by_name(window_name)
        if window_id:
            try:
                output = subprocess.check_output(['xwininfo', '-id', window_id]).decode('utf-8')
                x_pos = int(re.search(r'Absolute upper-left X:\s+(\d+)', output).group(1))
                y_pos = int(re.search(r'Absolute upper-left Y:\s+(\d+)', output).group(1))
                width = int(re.search(r'Width:\s+(\d+)', output).group(1))
                height = int(re.search(r'Height:\s+(\d+)', output).group(1))
                return (x_pos, y_pos, width, height)
            except Exception as e:
                self.status_label.set_text(f"Error getting window info by name: {e}")
                return None
        else:
            self.status_label.set_text("Error: Window not found.")
            return None

    def monitor_file_size(self):
        start_time = time.time()
        while self.is_recording:
            time.sleep(1)
            elapsed_time = time.time() - start_time
            if self.output_filename and os.path.exists(self.output_filename):
                size = os.path.getsize(self.output_filename)
                self.file_size = size
                GLib.idle_add(self.file_size_label.set_text, f"File size: {self.convert_size(size)}")
            else:
                GLib.idle_add(self.file_size_label.set_text, "File size: N/A")
            GLib.idle_add(self.status_label.set_text, f"Recording... Elapsed time: {self.format_time(elapsed_time)}")
            GLib.idle_add(self.elapsed_time_menu_item.set_label, f"Elapsed Time: {self.format_time(elapsed_time)}")

    def format_time(self, elapsed_time):
        minutes, seconds = divmod(elapsed_time, 60)
        hours, minutes = divmod(minutes, 60)
        return "{:02}:{:02}:{:02}".format(int(hours), int(minutes), int(seconds))

    def convert_size(self, size_bytes):
        if size_bytes == 0:
            return "0B"
        size_name = ("B", "KB", "MB", "GB", "TB")
        i = int(math.floor(math.log(size_bytes, 1024)))
        p = math.pow(1024, i)
        s = round(size_bytes / p, 2)
        return f"{s} {size_name[i]}"

    def on_webcam_overlay_toggled(self, button):
        self.is_webcam_overlay = button.get_active()
        self.update_tray_tooltip()

    def extract_camera_index(self, camera_text):
        match = re.search(r'/dev/video(\d+)', camera_text)
        if match:
            return int(match.group(1))
        else:
            raise ValueError(f"No valid camera index found in: {camera_text}")

    def show_camera_window(self, widget):
        selected_camera = self.camera_combo.get_active_text()
        selected_resolution = self.camera_resolution_combo.get_active_text()
        logging.debug(f"Selected camera: {selected_camera}, resolution: {selected_resolution}")
        if selected_camera:
            try:
                device_index = self.extract_camera_index(selected_camera)
                device = f"/dev/video{device_index}"
                logging.debug(f"Using device: {device}")
                resolution = selected_resolution if selected_resolution else "640x480"
                command = ['ffplay', '-f', 'v4l2', '-video_size', resolution, '-i', device, '-vf', 'hflip']

                self.camera_window = subprocess.Popen(command)
                time.sleep(0.5)
                self.bring_camera_window_to_front()
            except Exception as e:
                logging.error(f"Failed to open camera: {e}")
                self.status_label.set_text(f"Failed to open camera: {e}")
        else:
            logging.error("No camera selected")
            self.status_label.set_text("Error: No camera selected.")



    def bring_camera_window_to_front(self):
        if self.camera_window:
            try:
                output = subprocess.check_output(['xdotool', 'search', '--pid', str(self.camera_window.pid)]).decode('utf-8').strip()
                self.camera_window_id = output.split('\n')[-1]
                subprocess.run(['xdotool', 'windowactivate', '--sync', self.camera_window_id])
                subprocess.run(['xdotool', 'windowraise', self.camera_window_id])
                if self.is_camera_on_top:
                    subprocess.run(['xdotool', 'windowfocus', '--sync', self.camera_window_id])
                    subprocess.run(['xdotool', 'windowraise', self.camera_window_id])
                    subprocess.run(['wmctrl', '-i', '-r', self.camera_window_id, '-b', 'add,above'])
                else:
                    subprocess.run(['wmctrl', '-i', '-r', self.camera_window_id, '-b', 'remove,above'])
            except Exception as e:
                logging.error(f"Failed to bring camera window to front: {e}")

    def close_camera_window(self, widget):
        command = ['pkill', '-f', 'ffplay -f v4l2']
        try:
            subprocess.run(command)
        except Exception as e:
            logging.error(f"Failed to close camera windows: {e}")

    def on_keep_camera_on_top_toggled(self, button):
        self.is_camera_on_top = button.get_active()
        self.bring_camera_window_to_front()

    def get_available_cameras_v4l2(self):
        try:
            output = subprocess.check_output(['v4l2-ctl', '--list-devices']).decode('utf-8')
            devices = re.findall(r'([^\n]+)\n\t([^\n]+)', output)
            logging.debug(f"Available cameras: {devices}")
            cameras = []
            for device in devices:
                cameras.append(f"{device[0]} ({device[1]})")
            return cameras
        except subprocess.CalledProcessError as e:
            logging.error(f"Error getting available cameras: {e}")
            return []

    def create_tray_icon(self):
        self.indicator = AppIndicator3.Indicator.new(
            "screen-recorder-indicator",
            "media-playback-stop",  # Change the initial icon to the stop icon
            AppIndicator3.IndicatorCategory.APPLICATION_STATUS
        )
        self.indicator.set_status(AppIndicator3.IndicatorStatus.ACTIVE)

        menu = Gtk.Menu()

        show_item = Gtk.ImageMenuItem(label="Main/Settings Window")
        show_icon = Gtk.Image.new_from_icon_name("preferences-system", Gtk.IconSize.MENU)
        show_item.set_image(show_icon)
        show_item.connect("activate", self.show_window)
        menu.append(show_item)

        # Timer configuration in tray
        self.tray_timer_item = Gtk.CheckMenuItem(label="Enable Timer")
        self.tray_timer_item.set_active(False)
        self.tray_timer_item.connect("toggled", self.on_timer_toggled_tray)
        menu.append(self.tray_timer_item)

        timer_hours_item = Gtk.ImageMenuItem(label="Set Timer Hours")
        timer_hours_submenu = Gtk.Menu()
        self.timer_hours_group = []
        for hour in range(24):
            item = Gtk.RadioMenuItem.new_with_label_from_widget(None if not self.timer_hours_group else self.timer_hours_group[0], str(hour))
            item.connect("activate", self.set_timer_hours, hour)
            self.timer_hours_group.append(item)
            timer_hours_submenu.append(item)
        timer_hours_item.set_submenu(timer_hours_submenu)
        menu.append(timer_hours_item)

        timer_minutes_item = Gtk.ImageMenuItem(label="Set Timer Minutes")
        timer_minutes_submenu = Gtk.Menu()
        self.timer_minutes_group = []
        for minute in range(60):
            item = Gtk.RadioMenuItem.new_with_label_from_widget(None if not self.timer_minutes_group else self.timer_minutes_group[0], str(minute))
            item.connect("activate", self.set_timer_minutes, minute)
            self.timer_minutes_group.append(item)
            timer_minutes_submenu.append(item)
        timer_minutes_item.set_submenu(timer_minutes_submenu)
        menu.append(timer_minutes_item)

        # Initialize recording area group
        self.recording_area_group = []
        recording_area_menu = Gtk.ImageMenuItem(label="Select Recording Area")
        recording_area_icon = Gtk.Image.new_from_icon_name("video-display", Gtk.IconSize.MENU)
        recording_area_menu.set_image(recording_area_icon)
        recording_area_submenu = Gtk.Menu()

        full_screen_item = Gtk.RadioMenuItem.new_with_label_from_widget(None, "Full Screen")
        active_window_item = Gtk.RadioMenuItem.new_with_label_from_widget(full_screen_item, "Active Window")
        custom_region_item = Gtk.RadioMenuItem.new_with_label_from_widget(full_screen_item, "Custom Region")
        camera_only_item = Gtk.RadioMenuItem.new_with_label_from_widget(full_screen_item, "Camera Only")

        full_screen_item.connect("activate", self.set_recording_area, "Full Screen")
        active_window_item.connect("activate", self.set_recording_area, "Active Window")
        custom_region_item.connect("activate", self.set_recording_area, "Custom Region")
        camera_only_item.connect("activate", self.set_recording_area, "Camera Only")

        self.recording_area_group.extend([
            full_screen_item, active_window_item, custom_region_item, camera_only_item
        ])

        recording_area_submenu.append(full_screen_item)
        recording_area_submenu.append(active_window_item)
        recording_area_submenu.append(custom_region_item)
        recording_area_submenu.append(camera_only_item)

        recording_area_menu.set_submenu(recording_area_submenu)
        menu.append(recording_area_menu)

        # Initialize active window group
        self.active_window_group = []
        active_window_menu = Gtk.ImageMenuItem(label="Select Active Window")
        active_window_icon = Gtk.Image.new_from_icon_name("window", Gtk.IconSize.MENU)
        active_window_menu.set_image(active_window_icon)
        active_window_submenu = Gtk.Menu()

        active_windows = self.get_active_windows()
        for window in active_windows:
            item = Gtk.RadioMenuItem.new_with_label_from_widget(None if not self.active_window_group else self.active_window_group[0], window)
            item.connect("activate", self.set_active_window, window)
            self.active_window_group.append(item)
            active_window_submenu.append(item)
        active_window_menu.set_submenu(active_window_submenu)
        menu.append(active_window_menu)



        # Update the webcam position submenu in the tray icon
        webcam_position_menu = Gtk.ImageMenuItem(label="Webcam Position")
        webcam_position_icon = Gtk.Image.new_from_icon_name("camera-web", Gtk.IconSize.MENU)
        webcam_position_menu.set_image(webcam_position_icon)
        webcam_position_submenu = Gtk.Menu()

        self.webcam_position_group = []
        for position in self.webcam_positions:
            item = Gtk.RadioMenuItem.new_with_label_from_widget(
                None if not self.webcam_position_group else self.webcam_position_group[0],
                position
            )
            item.connect("activate", self.set_webcam_position, position)
            self.webcam_position_group.append(item)
            webcam_position_submenu.append(item)

        webcam_position_menu.set_submenu(webcam_position_submenu)
        menu.append(webcam_position_menu)


        # Update the create_tray_icon method to add a submenu for webcam size
        webcam_size_menu = Gtk.MenuItem(label="Webcam Overlay Size")
        webcam_size_submenu = Gtk.Menu()

        for size in [10, 20, 30, 40, 50]:
            item = Gtk.RadioMenuItem.new_with_label_from_widget(
                None if size == 10 else webcam_size_submenu.get_children()[0],
                f"{size}%"
            )
            item.connect("activate", self.set_webcam_size, size)
            webcam_size_submenu.append(item)

        webcam_size_menu.set_submenu(webcam_size_submenu)
        menu.append(webcam_size_menu)



        refresh_windows_item = Gtk.ImageMenuItem(label="Refresh Windows")
        refresh_icon = Gtk.Image.new_from_icon_name("view-refresh", Gtk.IconSize.MENU)
        refresh_windows_item.set_image(refresh_icon)
        refresh_windows_item.connect("activate", self.refresh_windows)
        menu.append(refresh_windows_item)

        # Initialize output format group
        self.output_format_group = []
        output_format_menu = Gtk.ImageMenuItem(label="Select Output Format")
        output_format_icon = Gtk.Image.new_from_icon_name("document-save", Gtk.IconSize.MENU)
        output_format_menu.set_image(output_format_icon)
        output_format_submenu = Gtk.Menu()

        mkv_item = Gtk.RadioMenuItem.new_with_label_from_widget(None, "mkv")
        mp4_item = Gtk.RadioMenuItem.new_with_label_from_widget(mkv_item, "mp4")
        webm_item = Gtk.RadioMenuItem.new_with_label_from_widget(mkv_item, "webm")
        mkv_item.set_active(True)
        mkv_item.connect("activate", self.set_output_format, "mkv")
        mp4_item.connect("activate", self.set_output_format, "mp4")
        webm_item.connect("activate", self.set_output_format, "webm")
        self.output_format_group.append(mkv_item)
        self.output_format_group.append(mp4_item)
        self.output_format_group.append(webm_item)

        output_format_submenu.append(mkv_item)
        output_format_submenu.append(mp4_item)
        output_format_submenu.append(webm_item)
        output_format_menu.set_submenu(output_format_submenu)
        menu.append(output_format_menu)

        # Initialize audio codec group
        self.audio_codec_group = []
        audio_codec_menu = Gtk.ImageMenuItem(label="Select Audio Codec")
        audio_codec_icon = Gtk.Image.new_from_icon_name("audio-x-generic", Gtk.IconSize.MENU)
        audio_codec_menu.set_image(audio_codec_icon)
        audio_codec_submenu = Gtk.Menu()

        aac_item = Gtk.RadioMenuItem.new_with_label_from_widget(None, "aac")
        mp3_item = Gtk.RadioMenuItem.new_with_label_from_widget(aac_item, "mp3")
        opus_item = Gtk.RadioMenuItem.new_with_label_from_widget(aac_item, "opus")
        aac_item.connect("activate", self.set_audio_codec, "aac")
        mp3_item.connect("activate", self.set_audio_codec, "mp3")
        opus_item.connect("activate", self.set_audio_codec, "opus")
        self.audio_codec_group.append(aac_item)
        self.audio_codec_group.append(mp3_item)
        self.audio_codec_group.append(opus_item)

        audio_codec_submenu.append(aac_item)
        audio_codec_submenu.append(mp3_item)
        audio_codec_submenu.append(opus_item)
        audio_codec_menu.set_submenu(audio_codec_submenu)
        menu.append(audio_codec_menu)

        # Initialize audio input config group
        self.audio_input_config_group = []
        audio_input_config_menu = Gtk.ImageMenuItem(label="Select Audio Input Configuration")
        audio_input_config_icon = Gtk.Image.new_from_icon_name("preferences-desktop-sound", Gtk.IconSize.MENU)
        audio_input_config_menu.set_image(audio_input_config_icon)
        audio_input_config_submenu = Gtk.Menu()

        primary_only_item = Gtk.RadioMenuItem.new_with_label_from_widget(None, "Primary Only")
        secondary_only_item = Gtk.RadioMenuItem.new_with_label_from_widget(primary_only_item, "Secondary Only")
        #both_item = Gtk.RadioMenuItem.new_with_label_from_widget(primary_only_item, "Both")
        primary_only_item.connect("activate", self.set_audio_input_config, "Primary Only")
        secondary_only_item.connect("activate", self.set_audio_input_config, "Secondary Only")
        #both_item.connect("activate", self.set_audio_input_config, "Both")
        self.audio_input_config_group.append(primary_only_item)
        self.audio_input_config_group.append(secondary_only_item)
        #self.audio_input_config_group.append(both_item)

        audio_input_config_submenu.append(primary_only_item)
        audio_input_config_submenu.append(secondary_only_item)
        #audio_input_config_submenu.append(both_item)
        audio_input_config_menu.set_submenu(audio_input_config_submenu)
        menu.append(audio_input_config_menu)

        # Initialize primary audio input group
        self.primary_audio_input_group = []
        primary_audio_input_menu = Gtk.ImageMenuItem(label="Select Primary Audio Input")
        primary_audio_input_icon = Gtk.Image.new_from_icon_name("audio-input-microphone", Gtk.IconSize.MENU)
        primary_audio_input_menu.set_image(primary_audio_input_icon)
        primary_audio_input_submenu = Gtk.Menu()

        for input_device in self.audio_inputs:
            item = Gtk.RadioMenuItem.new_with_label_from_widget(None if not self.primary_audio_input_group else self.primary_audio_input_group[0], input_device)
            item.connect("activate", self.set_primary_audio_input, input_device)
            self.primary_audio_input_group.append(item)
            primary_audio_input_submenu.append(item)
        primary_audio_input_menu.set_submenu(primary_audio_input_submenu)
        menu.append(primary_audio_input_menu)

        # Initialize secondary audio input group
        self.secondary_audio_input_group = []
        secondary_audio_input_menu = Gtk.ImageMenuItem(label="Select Secondary Audio Input")
        secondary_audio_input_icon = Gtk.Image.new_from_icon_name("audio-input-line", Gtk.IconSize.MENU)
        secondary_audio_input_menu.set_image(secondary_audio_input_icon)
        secondary_audio_input_submenu = Gtk.Menu()

        for input_device in self.secondary_audio_inputs:
            item = Gtk.RadioMenuItem.new_with_label_from_widget(None if not self.secondary_audio_input_group else self.secondary_audio_input_group[0], input_device)
            item.connect("activate", self.set_secondary_audio_input, input_device)
            self.secondary_audio_input_group.append(item)
            secondary_audio_input_submenu.append(item)
        secondary_audio_input_menu.set_submenu(secondary_audio_input_submenu)
        menu.append(secondary_audio_input_menu)

        select_custom_region_item = Gtk.ImageMenuItem(label="Select Custom Region")
        custom_region_icon = Gtk.Image.new_from_icon_name("image-x-generic", Gtk.IconSize.MENU)
        select_custom_region_item.set_image(custom_region_icon)
        select_custom_region_item.connect("activate", self.select_custom_region)
        menu.append(select_custom_region_item)

        # Add the Journal launcher
        journal_launcher_item = Gtk.ImageMenuItem(label="Journal")
        journal_launcher_icon = Gtk.Image.new_from_icon_name("media-record", Gtk.IconSize.MENU)
        journal_launcher_item.set_image(journal_launcher_icon)
        journal_launcher_item.connect("activate", self.launch_journal)
        menu.append(journal_launcher_item)

        record_item = Gtk.ImageMenuItem(label="Record")
        record_icon = Gtk.Image.new_from_icon_name("media-record", Gtk.IconSize.MENU)
        record_item.set_image(record_icon)
        record_item.connect("activate", self.start_recording)
        menu.append(record_item)
        self.tray_record_item = record_item  # Store a reference to the tray record item

        pause_item = Gtk.ImageMenuItem(label="Pause Recording")
        pause_icon = Gtk.Image.new_from_icon_name("media-playback-pause", Gtk.IconSize.MENU)
        pause_item.set_image(pause_icon)
        pause_item.connect("activate", self.pause_recording)
        menu.append(pause_item)

        resume_item = Gtk.ImageMenuItem(label="Resume Recording")
        resume_icon = Gtk.Image.new_from_icon_name("media-playback-start", Gtk.IconSize.MENU)
        resume_item.set_image(resume_icon)
        resume_item.connect("activate", self.resume_recording)
        menu.append(resume_item)

        stop_record_item = Gtk.ImageMenuItem(label="Stop Recording")
        stop_record_icon = Gtk.Image.new_from_icon_name("media-playback-stop", Gtk.IconSize.MENU)
        stop_record_item.set_image(stop_record_icon)
        stop_record_item.connect("activate", self.stop_recording)
        menu.append(stop_record_item)


        trim_item = Gtk.ImageMenuItem(label="Trim Recent Recording")
        trim_icon = Gtk.Image.new_from_icon_name("edit-cut", Gtk.IconSize.MENU)
        trim_item.set_image(trim_icon)
        trim_item.connect("activate", self.trim_video)
        menu.append(trim_item)



        self.recent_recording_menu_item = Gtk.ImageMenuItem(label="No recent recording")
        recent_recording_icon = Gtk.Image.new_from_icon_name("document-open-recent", Gtk.IconSize.MENU)
        self.recent_recording_menu_item.set_image(recent_recording_icon)
        self.recent_recording_menu_item.connect("activate", self.open_recent_recording)
        menu.append(self.recent_recording_menu_item)

        about_item = Gtk.ImageMenuItem(label="About Us")
        about_icon = Gtk.Image.new_from_icon_name("help-about", Gtk.IconSize.MENU)
        about_item.set_image(about_icon)
        about_item.connect("activate", self.show_about_dialog)
        menu.append(about_item)

        quit_item = Gtk.ImageMenuItem(label="Quit")
        quit_icon = Gtk.Image.new_from_icon_name("application-exit", Gtk.IconSize.MENU)
        quit_item.set_image(quit_icon)
        quit_item.connect("activate", self.quit_app)
        menu.append(quit_item)

        separator = Gtk.SeparatorMenuItem()
        menu.append(separator)

        self.recording_status_menu_item = Gtk.MenuItem(label="Not Recording")
        menu.append(self.recording_status_menu_item)

        self.file_size_menu_item = Gtk.MenuItem(label="File Size: 0B")
        menu.append(self.file_size_menu_item)

        self.elapsed_time_menu_item = Gtk.MenuItem(label="Elapsed Time: 00:00:00")
        menu.append(self.elapsed_time_menu_item)

        menu.show_all()
        self.indicator.set_menu(menu)

        self.update_tray_selection()  # Initialize the tray selections



    # Add this method to the ScreenRecorder class
    def set_webcam_size(self, widget, size):
        if widget.get_active():
            self.webcam_size_percentage = size
            self.webcam_size_scale.set_value(size)
            self.update_tray_tooltip()



    def set_webcam_position(self, widget, position):
        if widget.get_active():
            self.webcam_position_combo.set_active(self.webcam_positions.index(position))
            self.update_tray_tooltip()



    def create_menu_item_with_icon(self, label, icon_name):
        item = Gtk.ImageMenuItem(label=label)
        icon = Gtk.Image.new_from_icon_name(icon_name, Gtk.IconSize.MENU)
        item.set_image(icon)
        item.set_always_show_image(True)
        return item



    def on_timer_toggled_tray(self, widget):
        self.timer_active = widget.get_active()
        self.timer_checkbox.set_active(self.timer_active)
        self.on_timer_toggled(self.timer_checkbox)

    def set_timer_hours(self, widget, hours):
        if widget.get_active():
            self.timer_hours_combo.set_active(hours)
            self.on_timer_changed(self.timer_hours_combo)

    def set_timer_minutes(self, widget, minutes):
        if widget.get_active():
            self.timer_minutes_combo.set_active(minutes)
            self.on_timer_changed(self.timer_minutes_combo)

#---------Journal Area----------------------------#

    def launch_journal(self, widget):
        logging.info("Launching Journal")
        self.status_label.set_text("Initializing Journal...")

        try:
            # Toggle on the Journal mode checkbox
            self.journaling_mode_checkbox.set_active(True)
            self.is_journal_mode = True
            logging.info("Journal mode activated")

            # Step 1: Launch the web camera
            available_cameras = self.get_available_cameras_v4l2()
            if not available_cameras:
                raise Exception("No webcam detected")

            selected_camera = available_cameras[0]  # Select the first available camera
            selected_resolution = "640x480"
            device = f"/dev/video{self.extract_camera_index(selected_camera)}"
            command = ['ffplay', '-f', 'v4l2', '-video_size', selected_resolution, '-vf', 'hflip', device]

            self.camera_window = subprocess.Popen(command)
            time.sleep(2)  # Give more time for the camera window to open

            # Step 2: Refresh active windows to include the new camera window
            self.update_active_windows()
            active_windows = self.get_active_windows()
            logging.info(f"Updated active windows: {active_windows}")

            # Step 3: Find the active window corresponding to /dev/video0
            window_name = next((window for window in active_windows if "/dev/video0" in window), None)
            if window_name is None:
                raise Exception("Webcam window not found in active windows list")
            logging.info(f"Found webcam window: {window_name}")

            # Step 4: Set the recording area to Active Window and select the webcam window
            self.recording_area_combo.set_active(self.recording_areas.index("Active Window"))
            window_index = active_windows.index(window_name)
            self.active_window_combo.set_active(window_index)
            logging.info(f"Set recording area to Active Window and selected webcam window at index {window_index}")

            # Verify the selection
            if self.recording_area_combo.get_active_text() != "Active Window":
                raise Exception("Failed to set recording area to Active Window")
            if self.active_window_combo.get_active_text() != window_name:
                raise Exception("Failed to select the correct active window")

            # Step 5: Get window info and set the recording region
            window_info = self.get_window_info_by_name(window_name)
            if not window_info:
                raise Exception("Failed to get window info for webcam")
            self.custom_region_start_x, self.custom_region_start_y, width, height = window_info
            self.custom_region_end_x = self.custom_region_start_x + width
            self.custom_region_end_y = self.custom_region_start_y + height
            self.recording_region = (self.custom_region_start_x, self.custom_region_start_y, width, height)
            logging.info(f"Set recording region: {self.recording_region}")

            # Step 6: Set the primary audio input to the web camera
            self.refresh_audio_inputs()
            available_audio_inputs = self.audio_inputs
            logging.info(f"Available audio inputs: {available_audio_inputs}")

            # Look for any webcam-related audio input
            webcam_audio_input = next((input for input in available_audio_inputs if any(cam in input.lower() for cam in ["webcam", "camera", "video"])), None)
            if not webcam_audio_input:
                # If no webcam-specific audio input is found, use the default input
                webcam_audio_input = available_audio_inputs[0]
                logging.warning(f"No webcam-specific audio input found. Using default: {webcam_audio_input}")

            webcam_audio_index = self.audio_inputs.index(webcam_audio_input)
            self.audio_input_combo.set_active(webcam_audio_index)
            logging.info(f"Set primary audio input to: {webcam_audio_input}")

            # Verify the audio input selection
            if self.audio_input_combo.get_active_text() != webcam_audio_input:
                raise Exception(f"Failed to set the correct audio input. Expected: {webcam_audio_input}, Got: {self.audio_input_combo.get_active_text()}")
            

            # Step 7: Start recording
            self.start_recording(widget)
            if not self.is_recording:
                raise Exception("Failed to start recording")
            logging.info("Recording started successfully")

            # Step 8: Start monitoring the camera window
            threading.Thread(target=self.monitor_camera_window).start()

            self.status_label.set_text("Journal mode active. Recording in progress...")

        except Exception as e:
            logging.error(f"Error in launch_journal: {e}")
            self.status_label.set_text(f"Journal launch failed: {e}")
            if hasattr(self, 'camera_window') and self.camera_window:
                self.camera_window.terminate()
            
            # De-toggle the Journal mode
            self.journaling_mode_checkbox.set_active(False)
            self.is_journal_mode = False
            logging.info("Journal mode deactivated due to error")

        finally:
            # This block will run whether there was an exception or not
            if not self.is_journal_mode:
                logging.info("Journal mode is not active")
            else:
                logging.info("Journal mode is active")




    def refresh_audio_inputs(self):
            self.audio_inputs = self.get_available_audio_inputs()
            self.audio_input_combo.remove_all()
            for input_device in self.audio_inputs:
                self.audio_input_combo.append_text(input_device)
            self.audio_input_combo.set_active(0)
            logging.info(f"Refreshed audio inputs: {self.audio_inputs}")

    def close_camera_preview(self):
        if hasattr(self, 'camera_preview') and self.camera_preview:
            self.camera_preview.terminate()
            self.camera_preview.wait()
            self.camera_preview = None
            logging.info("Closed camera preview")

    def check_camera_window_opened(self):
        try:
            output = subprocess.check_output(['wmctrl', '-l']).decode('utf-8')
            return any("video" in line.lower() for line in output.splitlines())
        except subprocess.CalledProcessError:
            logging.error("Failed to check for camera window using wmctrl")
            return False

    def refresh_audio_inputs(self):
        self.audio_inputs = self.get_available_audio_inputs()
        self.audio_input_combo.remove_all()
        for input_device in self.audio_inputs:
            self.audio_input_combo.append_text(input_device)
        self.audio_input_combo.set_active(0)
        logging.info(f"Refreshed audio inputs: {self.audio_inputs}")




    def monitor_camera_window(self):
        while self.camera_window.poll() is None:
            time.sleep(1)
        
        # Camera window closed
        logging.info("Camera window closed. Stopping recording and deactivating Journal mode.")
        
        # Stop the recording
        GLib.idle_add(self.stop_recording, None)
        
        # De-toggle the Journal mode
        GLib.idle_add(self.deactivate_journal_mode)
        
        # Reset recording area and audio input
        GLib.idle_add(self.reset_recording_area)
        GLib.idle_add(self.reset_audio_input)


    def deactivate_journal_mode(self):
        self.journaling_mode_checkbox.set_active(False)
        self.is_journal_mode = False
        logging.info("Journal mode deactivated")
        self.status_label.set_text("Journal mode deactivated")
        

    def reset_recording_area(self):
        GLib.idle_add(self._reset_recording_area_impl)



    def _reset_recording_area_impl(self):
        # Update the main window's recording area combo box
        self.recording_area_combo.set_active(self.recording_areas.index("Full Screen"))
        
        # Update the status label
        self.status_label.set_text("Recording area reset to Full Screen.")
        
        # Update the tray tooltip
        self.update_tray_tooltip()
        
        # Reset custom region variables
        self.custom_region_start_x = None
        self.custom_region_start_y = None
        self.custom_region_end_x = None
        self.custom_region_end_y = None
        self.recording_region = None
        
        # Update the tray menu to reflect the change
        for item in self.recording_area_group:
            if item.get_label() == "Full Screen":
                item.set_active(True)
                break
        
        # Ensure the is_custom_region flag is reset
        self.is_custom_region = False
        
        return False  # This is needed for GLib.idle_add




    def reset_audio_input(self):
        default_audio_input = "analog-stereo.4.monitor"
        logging.info(f"Attempting to reset audio input to: {default_audio_input}")
        
        # Refresh the audio inputs
        self.refresh_audio_inputs()
        
        try:
            index = self.audio_inputs.index(default_audio_input)
            self.audio_input_combo.set_active(index)
            logging.info(f"Successfully reset audio input to {default_audio_input}")
        except ValueError:
            logging.warning(f"Default audio input '{default_audio_input}' not found. Using first available input.")
            if self.audio_inputs:
                self.audio_input_combo.set_active(0)
                logging.info(f"Set audio input to: {self.audio_inputs[0]}")
            else:
                logging.error("No audio inputs available")



#--------------Journal End------------------# 

    def set_active_window(self, widget, window):
        if widget.get_active():
            self.active_window_combo.set_active(self.active_window_combo.get_model().iter_n_children() - 1)
            self.update_tray_tooltip()

    def set_output_format(self, widget, format):
        if widget.get_active():
            self.output_format_combo.set_active(["mkv", "mp4", "webm"].index(format))
            self.update_tray_tooltip()

    def set_audio_codec(self, widget, codec):
        if widget.get_active():
            self.audio_codec_combo.set_active(self.audio_codecs.index(codec))
            self.update_tray_tooltip()

    def set_audio_input_config(self, widget, config):
        if widget.get_active():
            self.audio_input_config_combo.set_active(self.audio_input_configs.index(config))
            self.update_tray_tooltip()

    def set_primary_audio_input(self, widget, input_device):
        if widget.get_active():
            self.audio_input_combo.set_active(self.audio_inputs.index(input_device))
            self.update_tray_tooltip()

    def set_secondary_audio_input(self, widget, input_device):
        if widget.get_active():
            self.secondary_audio_input_combo.set_active(self.secondary_audio_inputs.index(input_device))
            self.update_tray_tooltip()

    def update_tray_selection(self):
        recording_area_active = self.recording_area_combo.get_active_text()
        for item in self.recording_area_group:
            if item.get_label() == recording_area_active:
                item.set_active(True)

        active_window_active = self.active_window_combo.get_active_text()
        for item in self.active_window_group:
            if item.get_label() == active_window_active:
                item.set_active(True)

        output_format_active = self.output_format_combo.get_active_text()
        for item in self.output_format_group:
            if item.get_label() == output_format_active:
                item.set_active(True)

        audio_codec_active = self.audio_codec_combo.get_active_text()
        for item in self.audio_codec_group:
            if item.get_label() == audio_codec_active:
                item.set_active(True)

        audio_input_config_active = self.audio_input_config_combo.get_active_text()
        for item in self.audio_input_config_group:
            if item.get_label() == audio_input_config_active:
                item.set_active(True)

        primary_audio_input_active = self.audio_input_combo.get_active_text()
        for item in self.primary_audio_input_group:
            if item.get_label() == primary_audio_input_active:
                item.set_active(True)

        secondary_audio_input_active = self.secondary_audio_input_combo.get_active_text()
        for item in self.secondary_audio_input_group:
            if item.get_label() == secondary_audio_input_active:
                item.set_active(True)



        webcam_position_active = self.webcam_position_combo.get_active_text()
        for item in self.webcam_position_group:
            if item.get_label() == webcam_position_active:
                item.set_active(True)


    def set_recording_area(self, widget, area):
        if widget.get_active():
            self.recording_area_combo.set_active(self.recording_areas.index(area))
            self.update_tray_tooltip()

    def update_recent_recording_menu_item(self):
        if self.completed_recordings:
            self.recent_recording_menu_item.set_label(f"Play Recent Recording: {os.path.basename(self.output_filename)}")
            self.recent_recording_menu_item.set_sensitive(True)
        else:
            self.recent_recording_menu_item.set_label("No recent recording")
            self.recent_recording_menu_item.set_sensitive(False)


    def open_recent_recording(self, widget):
        if self.completed_recordings:
            most_recent_recording = sorted(self.completed_recordings, key=lambda x: x[1], reverse=True)[0][0]
            if os.path.exists(most_recent_recording):
                subprocess.run(['xdg-open', most_recent_recording])
            else:
                self.status_label.set_text("Error: Recent recording file not found.")

    def show_window(self, widget):
        self.main_window.deiconify()
        self.main_window.present()

    def show_about_dialog(self, widget):
        about_dialog = Gtk.AboutDialog()
        about_dialog.set_program_name("Seekers Screen Recorder")
        about_dialog.set_version("2.0")
        about_dialog.set_comments("A powerful and easy-to-use screen recording application.")
        about_dialog.set_authors(["The Seeker", "Ben StormOS Dev", "Ricki aka YughioMaster88", "Fishman aka Pescado"])
        about_dialog.set_logo_icon_name("help-about")
        about_dialog.run()
        about_dialog.destroy()

    def quit_app(self, widget):
        self.cleanup_on_exit()
        Gtk.main_quit()

    def on_combobox_changed(self, combo):
        self.update_tray_tooltip()

if __name__ == "__main__":
    Gst.init(None)
    ScreenRecorder()
    Gtk.main()
